--- a/modules/pam_chroot/pam_chroot.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_chroot/pam_chroot.c	1697365917.536214513
@@ -0,0 +1,109 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+
+#include <pwd.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+#define PAM_SM_SESSION
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/openpam.h>
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char *dir, *end, *cwd, *user;
+	struct passwd *pwd;
+	char buf[PATH_MAX];
+
+	if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS ||
+	    user == NULL || (pwd = getpwnam(user)) == NULL)
+		return (PAM_SESSION_ERR);
+	if (pwd->pw_uid == 0 && !openpam_get_option(pamh, "also_root"))
+		return (PAM_SUCCESS);
+	if (pwd->pw_dir == NULL)
+		return (PAM_SESSION_ERR);
+	if ((end = strstr(pwd->pw_dir, "/./")) != NULL) {
+		if (snprintf(buf, sizeof(buf), "%.*s",
+		    (int)(end - pwd->pw_dir), pwd->pw_dir) > (int)sizeof(buf)) {
+			openpam_log(PAM_LOG_ERROR,
+			    "%s's home directory is too long", user);
+			return (PAM_SESSION_ERR);
+		}
+		dir = buf;
+		cwd = end + 2;
+	} else if ((dir = openpam_get_option(pamh, "dir")) != NULL) {
+		if ((cwd = openpam_get_option(pamh, "cwd")) == NULL)
+			cwd = "/";
+	} else {
+		if (openpam_get_option(pamh, "always")) {
+			openpam_log(PAM_LOG_ERROR,
+			    "%s has no chroot directory", user);
+			return (PAM_SESSION_ERR);
+		}
+		return (PAM_SUCCESS);
+	}
+
+	openpam_log(PAM_LOG_DEBUG, "chrooting %s to %s", dir, user);
+
+	if (chroot(dir) == -1) {
+		openpam_log(PAM_LOG_ERROR, "chroot(): %m");
+		return (PAM_SESSION_ERR);
+	}
+	if (chdir(cwd) == -1) {
+		openpam_log(PAM_LOG_ERROR, "chdir(): %m");
+		return (PAM_SESSION_ERR);
+	}
+	pam_setenv(pamh, "HOME", cwd, 1);
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_chroot");
--- a/modules/pam_deny/pam_deny.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_deny/pam_deny.c	1697365988.602325840
@@ -0,0 +1,93 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright 2001 Mark R V Murray
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <stddef.h>
+
+#define PAM_SM_AUTH
+#define PAM_SM_ACCOUNT
+#define PAM_SM_SESSION
+#define PAM_SM_PASSWORD
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char *user;
+	int r;
+
+	if ((r = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS)
+		return (r);
+
+	return (PAM_AUTH_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_CRED_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_AUTH_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_AUTHTOK_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SESSION_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SESSION_ERR);
+}
+
+PAM_MODULE_ENTRY("pam_deny");
--- a/modules/pam_echo/pam_echo.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_echo/pam_echo.c	1697366090.548655200
@@ -0,0 +1,156 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001,2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/openpam.h>
+
+static int
+_pam_echo(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	char msg[PAM_MAX_MSG_SIZE];
+	const void *str;
+	const char *p, *q;
+	int err, i, item;
+	size_t len;
+
+	if (flags & PAM_SILENT)
+		return (PAM_SUCCESS);
+	for (i = 0, len = 0; i < argc && len < sizeof(msg) - 1; ++i) {
+		if (i > 0)
+			msg[len++] = ' ';
+		for (p = argv[i]; *p != '\0' && len < sizeof(msg) - 1; ++p) {
+			if (*p != '%' || p[1] == '\0') {
+				msg[len++] = *p;
+				continue;
+			}
+			switch (*++p) {
+			case 'H':
+				item = PAM_RHOST;
+				break;
+			case 'h':
+				/* not implemented */
+				item = -1;
+				break;
+			case 's':
+				item = PAM_SERVICE;
+				break;
+			case 't':
+				item = PAM_TTY;
+				break;
+			case 'U':
+				item = PAM_RUSER;
+				break;
+			case 'u':
+				item = PAM_USER;
+				break;
+			default:
+				item = -1;
+				msg[len++] = *p;
+				break;
+			}
+			if (item == -1)
+				continue;
+			err = pam_get_item(pamh, item, &str);
+			if (err != PAM_SUCCESS)
+				return (err);
+			if (str == NULL)
+				str = "(null)";
+			for (q = str; *q != '\0' && len < sizeof(msg) - 1; ++q)
+				msg[len++] = *q;
+		}
+	}
+	msg[len] = '\0';
+	return (pam_info(pamh, "%s", msg));
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+
+	return (_pam_echo(pamh, flags, argc, argv));
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+
+	return (_pam_echo(pamh, flags, argc, argv));
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+
+	return (_pam_echo(pamh, flags, argc, argv));
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+
+	return (_pam_echo(pamh, flags, argc, argv));
+}
+
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+
+	if (flags & PAM_PRELIM_CHECK)
+		return (PAM_SUCCESS);
+	return (_pam_echo(pamh, flags, argc, argv));
+}
+
+PAM_MODULE_ENTRY("pam_echo");
--- a/modules/pam_exec/pam_exec.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_exec/pam_exec.c	1697366617.304701106
@@ -0,0 +1,710 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001,2003 Networks Associates Technology, Inc.
+ * Copyright (c) 2017-2019 Dag-Erling Smørgrav
+ * Copyright (c) 2018 Thomas Munro
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/poll.h>
+#include <sys/wait.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/openpam.h>
+
+#if __APPLE__
+void * reallocarray(void * in_ptr, size_t nmemb, size_t size) __DARWIN_EXTSN(reallocarray) __result_use_check;
+#define INFTIM -1
+#endif
+
+#define PAM_ITEM_ENV(n) { (n), #n }
+static struct {
+	int item;
+	const char *name;
+} pam_item_env[] = {
+	PAM_ITEM_ENV(PAM_SERVICE),
+	PAM_ITEM_ENV(PAM_USER),
+	PAM_ITEM_ENV(PAM_TTY),
+	PAM_ITEM_ENV(PAM_RHOST),
+	PAM_ITEM_ENV(PAM_RUSER),
+};
+#define NUM_PAM_ITEM_ENV (sizeof(pam_item_env) / sizeof(pam_item_env[0]))
+
+#define PAM_ERR_ENV_X(str, num) str "=" #num
+#define PAM_ERR_ENV(pam_err) PAM_ERR_ENV_X(#pam_err, pam_err)
+static const char *pam_err_env[] = {
+	PAM_ERR_ENV(PAM_SUCCESS),
+	PAM_ERR_ENV(PAM_OPEN_ERR),
+	PAM_ERR_ENV(PAM_SYMBOL_ERR),
+	PAM_ERR_ENV(PAM_SERVICE_ERR),
+	PAM_ERR_ENV(PAM_SYSTEM_ERR),
+	PAM_ERR_ENV(PAM_BUF_ERR),
+	PAM_ERR_ENV(PAM_CONV_ERR),
+	PAM_ERR_ENV(PAM_PERM_DENIED),
+	PAM_ERR_ENV(PAM_MAXTRIES),
+	PAM_ERR_ENV(PAM_AUTH_ERR),
+	PAM_ERR_ENV(PAM_NEW_AUTHTOK_REQD),
+	PAM_ERR_ENV(PAM_CRED_INSUFFICIENT),
+	PAM_ERR_ENV(PAM_AUTHINFO_UNAVAIL),
+	PAM_ERR_ENV(PAM_USER_UNKNOWN),
+	PAM_ERR_ENV(PAM_CRED_UNAVAIL),
+	PAM_ERR_ENV(PAM_CRED_EXPIRED),
+	PAM_ERR_ENV(PAM_CRED_ERR),
+	PAM_ERR_ENV(PAM_ACCT_EXPIRED),
+	PAM_ERR_ENV(PAM_AUTHTOK_EXPIRED),
+	PAM_ERR_ENV(PAM_SESSION_ERR),
+	PAM_ERR_ENV(PAM_AUTHTOK_ERR),
+	PAM_ERR_ENV(PAM_AUTHTOK_RECOVERY_ERR),
+	PAM_ERR_ENV(PAM_AUTHTOK_LOCK_BUSY),
+	PAM_ERR_ENV(PAM_AUTHTOK_DISABLE_AGING),
+	PAM_ERR_ENV(PAM_NO_MODULE_DATA),
+	PAM_ERR_ENV(PAM_IGNORE),
+	PAM_ERR_ENV(PAM_ABORT),
+	PAM_ERR_ENV(PAM_TRY_AGAIN),
+	PAM_ERR_ENV(PAM_MODULE_UNKNOWN),
+	PAM_ERR_ENV(PAM_DOMAIN_UNKNOWN),
+	PAM_ERR_ENV(PAM_NUM_ERR),
+};
+#define NUM_PAM_ERR_ENV (sizeof(pam_err_env) / sizeof(pam_err_env[0]))
+
+struct pe_opts {
+	int	return_prog_exit_status;
+	int	capture_stdout;
+	int	capture_stderr;
+	int	expose_authtok;
+	int	use_first_pass;
+};
+
+static int
+parse_options(const char *func, int *argc, const char **argv[],
+    struct pe_opts *options)
+{
+	int i;
+
+	/*
+	 * Parse options:
+	 *   return_prog_exit_status:
+	 *     use the program exit status as the return code of pam_exec
+	 *   --:
+	 *     stop options parsing; what follows is the command to execute
+	 */
+	memset(options, 0, sizeof(*options));
+
+	for (i = 0; i < *argc; ++i) {
+		if (strcmp((*argv)[i], "debug") == 0 ||
+		    strcmp((*argv)[i], "no_warn") == 0) {
+			/* ignore */
+		} else if (strcmp((*argv)[i], "capture_stdout") == 0) {
+			options->capture_stdout = 1;
+		} else if (strcmp((*argv)[i], "capture_stderr") == 0) {
+			options->capture_stderr = 1;
+		} else if (strcmp((*argv)[i], "return_prog_exit_status") == 0) {
+			options->return_prog_exit_status = 1;
+		} else if (strcmp((*argv)[i], "expose_authtok") == 0) {
+			options->expose_authtok = 1;
+		} else if (strcmp((*argv)[i], "use_first_pass") == 0) {
+			options->use_first_pass = 1;
+		} else {
+			if (strcmp((*argv)[i], "--") == 0) {
+				(*argc)--;
+				(*argv)++;
+			}
+			break;
+		}
+		openpam_log(PAM_LOG_DEBUG, "%s: option \"%s\" enabled",
+		    func, (*argv)[i]);
+	}
+
+	(*argc) -= i;
+	(*argv) += i;
+
+	return (0);
+}
+
+static int
+_pam_exec(pam_handle_t *pamh,
+    const char *func, int flags __unused, int argc, const char *argv[],
+    struct pe_opts *options)
+{
+	char buf[PAM_MAX_MSG_SIZE];
+	struct pollfd pfd[4];
+	const void *item;
+	char **envlist, *envstr, *resp, **tmp;
+	ssize_t rlen, wlen;
+	int envlen, extralen, i;
+	int pam_err, serrno, status;
+	int chin[2], chout[2], cherr[2], pd;
+	nfds_t nfds, nreadfds;
+	pid_t pid;
+	const char *authtok;
+	size_t authtok_size;
+	int rc;
+
+	pd = -1;
+	pid = 0;
+	chin[0] = chin[1] = chout[0] = chout[1] = cherr[0] = cherr[1] = -1;
+	envlist = NULL;
+
+#define OUT(ret) do { pam_err = (ret); goto out; } while (0)
+
+	/* Check there's a program name left after parsing options. */
+	if (argc < 1) {
+		openpam_log(PAM_LOG_ERROR, "%s: No program specified: aborting",
+		    func);
+		OUT(PAM_SERVICE_ERR);
+	}
+
+	/*
+	 * Set up the child's environment list.  It consists of the PAM
+	 * environment, a few hand-picked PAM items, the name of the
+	 * service function, and if return_prog_exit_status is set, the
+	 * numerical values of all PAM error codes.
+	 */
+
+	/* compute the final size of the environment. */
+	envlist = pam_getenvlist(pamh);
+	for (envlen = 0; envlist[envlen] != NULL; ++envlen)
+		/* nothing */ ;
+	extralen = NUM_PAM_ITEM_ENV + 1;
+	if (options->return_prog_exit_status)
+		extralen += NUM_PAM_ERR_ENV;
+	tmp = reallocarray(envlist, envlen + extralen + 1, sizeof(*envlist));
+	openpam_log(PAM_LOG_DEBUG, "envlen = %d extralen = %d tmp = %p",
+	    envlen, extralen, tmp);
+	if (tmp == NULL)
+		OUT(PAM_BUF_ERR);
+	envlist = tmp;
+	extralen += envlen;
+
+	/* copy selected PAM items to the environment */
+	for (i = 0; i < NUM_PAM_ITEM_ENV; ++i) {
+		pam_err = pam_get_item(pamh, pam_item_env[i].item, &item);
+		if (pam_err != PAM_SUCCESS || item == NULL)
+			continue;
+		if (asprintf(&envstr, "%s=%s", pam_item_env[i].name,
+		    (const char *)item) < 0)
+			OUT(PAM_BUF_ERR);
+		envlist[envlen++] = envstr;
+		envlist[envlen] = NULL;
+		openpam_log(PAM_LOG_DEBUG, "setenv %s", envstr);
+	}
+
+	/* add the name of the service function to the environment */
+	if (asprintf(&envstr, "PAM_SM_FUNC=%s", func) < 0)
+		OUT(PAM_BUF_ERR);
+	envlist[envlen++] = envstr;
+	envlist[envlen] = NULL;
+
+	/* add the PAM error codes to the environment. */
+	if (options->return_prog_exit_status) {
+		for (i = 0; i < (int)NUM_PAM_ERR_ENV; ++i) {
+			if ((envstr = strdup(pam_err_env[i])) == NULL)
+				OUT(PAM_BUF_ERR);
+			envlist[envlen++] = envstr;
+			envlist[envlen] = NULL;
+		}
+	}
+
+	openpam_log(PAM_LOG_DEBUG, "envlen = %d extralen = %d envlist = %p",
+	    envlen, extralen, envlist);
+
+	/* set up pipe and get authtok if requested */
+	if (options->expose_authtok) {
+		if (pipe(chin) != 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: pipe(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+		if (fcntl(chin[1], F_SETFL, O_NONBLOCK)) {
+			openpam_log(PAM_LOG_ERROR, "%s: fcntl(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+		if (options->use_first_pass ||
+		    strcmp(func, "pam_sm_setcred") == 0) {
+			/* don't prompt, only expose existing token */
+			rc = pam_get_item(pamh, PAM_AUTHTOK, &item);
+			authtok = item;
+			if (authtok == NULL && rc == PAM_SUCCESS) {
+				openpam_log(PAM_LOG_ERROR, 
+				    "%s: pam_get_authtok(): %s",
+				    func, "authentication token not available");
+				OUT(PAM_SYSTEM_ERR);
+			}
+
+		} else {
+			rc = pam_get_authtok(pamh, PAM_AUTHTOK, &authtok, NULL);
+		}
+		if (rc == PAM_SUCCESS) {
+			/* We include the trailing null terminator. */
+			authtok_size = strlen(authtok) + 1;
+		} else {
+			openpam_log(PAM_LOG_ERROR, "%s: pam_get_authtok(): %s",
+			    func, pam_strerror(pamh, rc));
+			OUT(PAM_SYSTEM_ERR);
+		}
+	}
+	/* set up pipes if capture was requested */
+	if (options->capture_stdout) {
+		if (pipe(chout) != 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: pipe(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+		if (fcntl(chout[0], F_SETFL, O_NONBLOCK) != 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: fcntl(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+	} else {
+		if ((chout[1] = open("/dev/null", O_RDWR)) < 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: /dev/null: %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+	}
+	if (options->capture_stderr) {
+		if (pipe(cherr) != 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: pipe(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+		if (fcntl(cherr[0], F_SETFL, O_NONBLOCK) != 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: fcntl(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+	} else {
+		if ((cherr[1] = open("/dev/null", O_RDWR)) < 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: /dev/null: %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+	}
+#if __APPLE__
+	if ((pid = fork()) == 0) {
+#else
+	if ((pid = pdfork(&pd, 0)) == 0) {
+#endif
+		/* child */
+		if ((chin[1] >= 0 && close(chin[1]) != 0) ||
+			(chout[0] >= 0 && close(chout[0]) != 0) ||
+		    (cherr[0] >= 0 && close(cherr[0]) != 0)) {
+			openpam_log(PAM_LOG_ERROR, "%s: close(): %m", func);
+		} else if (chin[0] >= 0 &&
+			dup2(chin[0], STDIN_FILENO) != STDIN_FILENO) {
+			openpam_log(PAM_LOG_ERROR, "%s: dup2(): %m", func);
+		} else if (dup2(chout[1], STDOUT_FILENO) != STDOUT_FILENO ||
+		    dup2(cherr[1], STDERR_FILENO) != STDERR_FILENO) {
+			openpam_log(PAM_LOG_ERROR, "%s: dup2(): %m", func);
+		} else {
+			execve(argv[0], (char * const *)argv,
+			    (char * const *)envlist);
+			openpam_log(PAM_LOG_ERROR, "%s: execve(%s): %m",
+			    func, argv[0]);
+		}
+		_exit(1);
+	}
+	/* parent */
+	if (pid == -1) {
+#if __APPLE__
+		openpam_log(PAM_LOG_ERROR, "%s: fork(): %m", func);
+#else
+		openpam_log(PAM_LOG_ERROR, "%s: pdfork(): %m", func);
+#endif
+		OUT(PAM_SYSTEM_ERR);
+	}
+	/* use poll() to watch the process and stdin / stdout / stderr */
+	if (chin[0] >= 0)
+		close(chin[0]);
+	if (chout[1] >= 0)
+		close(chout[1]);
+	if (cherr[1] >= 0)
+		close(cherr[1]);
+	memset(pfd, 0, sizeof pfd);
+	pfd[0].fd = pd;
+	pfd[0].events = POLLHUP;
+	nfds = 1;
+	nreadfds = 0;
+	if (options->capture_stdout) {
+		pfd[nfds].fd = chout[0];
+		pfd[nfds].events = POLLIN|POLLERR|POLLHUP;
+		nfds++;
+		nreadfds++;
+	}
+	if (options->capture_stderr) {
+		pfd[nfds].fd = cherr[0];
+		pfd[nfds].events = POLLIN|POLLERR|POLLHUP;
+		nfds++;
+		nreadfds++;
+	}
+	if (options->expose_authtok) {
+		pfd[nfds].fd = chin[1];
+		pfd[nfds].events = POLLOUT|POLLERR|POLLHUP;
+		nfds++;
+	}
+
+	/* loop until the process exits */
+	do {
+		if (poll(pfd, nfds, INFTIM) < 0) {
+			openpam_log(PAM_LOG_ERROR, "%s: poll(): %m", func);
+			OUT(PAM_SYSTEM_ERR);
+		}
+		/* are the stderr / stdout pipes ready for reading? */
+		for (i = 1; i < 1 + nreadfds; ++i) {
+			if ((pfd[i].revents & POLLIN) == 0)
+				continue;
+			if ((rlen = read(pfd[i].fd, buf, sizeof(buf) - 1)) < 0) {
+				openpam_log(PAM_LOG_ERROR, "%s: read(): %m",
+				    func);
+				OUT(PAM_SYSTEM_ERR);
+			} else if (rlen == 0) {
+				continue;
+			}
+			buf[rlen] = '\0';
+			(void)pam_prompt(pamh, pfd[i].fd == chout[0] ?
+			    PAM_TEXT_INFO : PAM_ERROR_MSG, &resp, "%s", buf);
+		}
+		/* is the stdin pipe ready for writing? */
+		if (options->expose_authtok && authtok_size > 0 &&
+			(pfd[nfds - 1].revents & POLLOUT) != 0) {
+			if ((wlen = write(chin[1], authtok, authtok_size)) < 0) {
+				if (errno == EAGAIN)
+					continue;
+				openpam_log(PAM_LOG_ERROR, "%s: write(): %m",
+				    func);
+				OUT(PAM_SYSTEM_ERR);
+			} else {
+				authtok += wlen;
+				authtok_size -= wlen;
+				if (authtok_size == 0) {
+					/* finished writing; close and forget the pipe */
+					close(chin[1]);
+					chin[1] = -1;
+					nfds--;
+				}
+			}
+		}
+	} while (pfd[0].revents == 0);
+
+	/* the child process has exited */
+	while (waitpid(pid, &status, 0) == -1) {
+		if (errno == EINTR)
+			continue;
+		openpam_log(PAM_LOG_ERROR, "%s: waitpid(): %m", func);
+		OUT(PAM_SYSTEM_ERR);
+	}
+
+	/* check exit code */
+	if (WIFSIGNALED(status)) {
+		openpam_log(PAM_LOG_ERROR, "%s: %s caught signal %d%s",
+		    func, argv[0], WTERMSIG(status),
+		    WCOREDUMP(status) ? " (core dumped)" : "");
+		OUT(PAM_SERVICE_ERR);
+	}
+	if (!WIFEXITED(status)) {
+		openpam_log(PAM_LOG_ERROR, "%s: unknown status 0x%x",
+		    func, status);
+		OUT(PAM_SERVICE_ERR);
+	}
+
+	if (options->return_prog_exit_status) {
+		openpam_log(PAM_LOG_DEBUG,
+		    "%s: Use program exit status as return value: %d",
+		    func, WEXITSTATUS(status));
+		OUT(WEXITSTATUS(status));
+	} else {
+		OUT(WEXITSTATUS(status) == 0 ? PAM_SUCCESS : PAM_PERM_DENIED);
+	}
+	/* unreachable */
+out:
+	serrno = errno;
+	if (pd >= 0)
+		close(pd);
+	if (chin[0] >= 0)
+		close(chin[0]);
+	if (chin[1] >= 0)
+		close(chin[1]);
+	if (chout[0] >= 0)
+		close(chout[0]);
+	if (chout[1] >= 0)
+		close(chout[1]);
+	if (cherr[0] >= 0)
+		close(cherr[0]);
+	if (cherr[0] >= 0)
+		close(cherr[1]);
+	if (envlist != NULL)
+		openpam_free_envlist(envlist);
+	errno = serrno;
+	return (pam_err);	
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_AUTHINFO_UNAVAIL:
+	case PAM_AUTH_ERR:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_CRED_INSUFFICIENT:
+	case PAM_IGNORE:
+	case PAM_MAXTRIES:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SYSTEM_ERR:
+	case PAM_USER_UNKNOWN:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_CRED_ERR:
+	case PAM_CRED_EXPIRED:
+	case PAM_CRED_UNAVAIL:
+	case PAM_IGNORE:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SYSTEM_ERR:
+	case PAM_USER_UNKNOWN:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_ACCT_EXPIRED:
+	case PAM_AUTH_ERR:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_IGNORE:
+	case PAM_NEW_AUTHTOK_REQD:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SYSTEM_ERR:
+	case PAM_USER_UNKNOWN:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_IGNORE:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SESSION_ERR:
+	case PAM_SYSTEM_ERR:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_IGNORE:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SESSION_ERR:
+	case PAM_SYSTEM_ERR:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh, int flags,
+    int argc, const char *argv[])
+{
+	int ret;
+	struct pe_opts options;
+
+	ret = parse_options(__func__, &argc, &argv, &options);
+	if (ret != 0)
+		return (PAM_SERVICE_ERR);
+
+	ret = _pam_exec(pamh, __func__, flags, argc, argv, &options);
+
+	/*
+	 * We must check that the program returned a valid code for this
+	 * function.
+	 */
+	switch (ret) {
+	case PAM_SUCCESS:
+	case PAM_ABORT:
+	case PAM_AUTHTOK_DISABLE_AGING:
+	case PAM_AUTHTOK_ERR:
+	case PAM_AUTHTOK_LOCK_BUSY:
+	case PAM_AUTHTOK_RECOVERY_ERR:
+	case PAM_BUF_ERR:
+	case PAM_CONV_ERR:
+	case PAM_IGNORE:
+	case PAM_PERM_DENIED:
+	case PAM_SERVICE_ERR:
+	case PAM_SYSTEM_ERR:
+	case PAM_TRY_AGAIN:
+		break;
+	default:
+		openpam_log(PAM_LOG_ERROR, "%s returned invalid code %d",
+		    argv[0], ret);
+		ret = PAM_SERVICE_ERR;
+	}
+
+	return (ret);
+}
+
+PAM_MODULE_ENTRY("pam_exec");
--- a/modules/pam_ftpusers/pam_ftpusers.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ftpusers/pam_ftpusers.c	1697367081.025234785
@@ -0,0 +1,129 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <ctype.h>
+#include <grp.h>
+#include <paths.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define PAM_SM_AUTH
+#define PAM_SM_ACCOUNT
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+#include <security/openpam.h>
+
+#if __APPLE__
+#include "Logging.h"
+#define _PATH_FTPUSERS  "/etc/ftpusers"
+PAM_DEFINE_LOG(ftpusers)
+#define PAM_LOG PAM_LOG_ftpusers()
+#endif
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct passwd *pwd;
+	struct group *grp;
+	const char *user;
+	int pam_err, found, allow;
+	char *line, *name, **mem;
+	size_t len, ulen;
+	FILE *f;
+
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	if (user == NULL || (pwd = getpwnam(user)) == NULL)
+		return (PAM_SERVICE_ERR);
+
+	found = 0;
+	ulen = strlen(user);
+	if ((f = fopen(_PATH_FTPUSERS, "r")) == NULL) {
+#if __APPLE__
+		os_log_error(PAM_LOG, "%s: %m", _PATH_FTPUSERS);
+#else
+		PAM_LOG("%s: %m", _PATH_FTPUSERS);
+#endif
+		goto done;
+	}
+	while (!found && (line = fgetln(f, &len)) != NULL) {
+		if (*line == '#')
+			continue;
+		while (len > 0 && isspace(line[len - 1]))
+			--len;
+		if (len == 0)
+			continue;
+		/* simple case first */
+		if (*line != '@') {
+			if (len == ulen && strncmp(user, line, len) == 0)
+				found = 1;
+			continue;
+		}
+		/* member of specified group? */
+		asprintf(&name, "%.*s", (int)len - 1, line + 1);
+		if (name == NULL) {
+			fclose(f);
+			return (PAM_BUF_ERR);
+		}
+		grp = getgrnam(name);
+		free(name);
+		if (grp == NULL)
+			continue;
+		for (mem = grp->gr_mem; mem && *mem && !found; ++mem)
+			if (strcmp(user, *mem) == 0)
+				found = 1;
+	}
+ done:
+	allow = (openpam_get_option(pamh, "disallow") == NULL);
+	if (found)
+		pam_err = allow ? PAM_SUCCESS : PAM_AUTH_ERR;
+	else
+		pam_err = allow ? PAM_AUTH_ERR : PAM_SUCCESS;
+	if (f != NULL)
+		fclose(f);
+	return (pam_err);
+}
+
+PAM_MODULE_ENTRY("pam_ftpusers");
--- a/modules/pam_guest/pam_guest.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_guest/pam_guest.c	1697367129.810077276
@@ -0,0 +1,114 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <string.h>
+
+#define PAM_SM_AUTH
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/openpam.h>
+
+#define DEFAULT_GUESTS	"guest"
+
+static int
+lookup(const char *str, const char *list)
+{
+	const char *next;
+	size_t len;
+
+	len = strlen(str);
+	while (*list != '\0') {
+		while (*list == ',')
+			++list;
+		if ((next = strchr(list, ',')) == NULL)
+			next = strchr(list, '\0');
+		if (next - list == (ptrdiff_t)len &&
+		    strncmp(list, str, len) == 0)
+			return (1);
+		list = next;
+	}
+	return (0);
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char *authtok, *guests, *user;
+	int err, is_guest;
+
+	/* get target account */
+	if (pam_get_user(pamh, &user, NULL) != PAM_SUCCESS || user == NULL)
+		return (PAM_AUTH_ERR);
+
+	/* get list of guest logins */
+	if ((guests = openpam_get_option(pamh, "guests")) == NULL)
+		guests = DEFAULT_GUESTS;
+
+	/* check if the target account is on the list */
+	is_guest = lookup(user, guests);
+
+	/* check password */
+	if (!openpam_get_option(pamh, "nopass")) {
+		err = pam_get_authtok(pamh, PAM_AUTHTOK, &authtok, NULL);
+		if (err != PAM_SUCCESS)
+			return (err);
+		if (openpam_get_option(pamh, "pass_is_user") &&
+		    strcmp(user, authtok) != 0)
+			return (PAM_AUTH_ERR);
+		if (openpam_get_option(pamh, "pass_as_ruser"))
+			pam_set_item(pamh, PAM_RUSER, authtok);
+	}
+
+	/* done */
+	if (is_guest) {
+		pam_setenv(pamh, "GUEST", user, 1);
+		return (PAM_SUCCESS);
+	}
+	return (PAM_AUTH_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t * pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_guest");
--- a/modules/pam_ksu/pam_ksu.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ksu/pam_ksu.c	1697368085.785942673
@@ -0,0 +1,335 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright (c) 2002 Jacques A. Vidrine <nectar@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#if __APPLE__
+#include <Heimdal/krb5.h>
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+/* Apple hidded these SPI from SDK */
+#define KRB5_DEFAULT_CCFILE_ROOT "%{TEMP}/krb5cc_"
+#define KRB5_DEFAULT_CCROOT "FILE:" KRB5_DEFAULT_CCFILE_ROOT
+#else
+#include <krb5.h>
+#endif
+
+#define PAM_SM_AUTH
+#define PAM_SM_CRED
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(ksu)
+#define PAM_LOG PAM_LOG_ksu()
+#endif
+
+static const char superuser[] = "root";
+
+static long	get_su_principal(krb5_context, const char *, const char *,
+		    char **, krb5_principal *);
+static int	auth_krb5(pam_handle_t *, krb5_context, const char *,
+		    krb5_principal);
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	krb5_context	 context;
+	krb5_principal	 su_principal;
+	const char	*user;
+	const void	*ruser;
+	char		*su_principal_name;
+	long		 rv;
+	int		 pamret;
+
+	pamret = pam_get_user(pamh, &user, NULL);
+	if (pamret != PAM_SUCCESS)
+		return (pamret);
+#if __APPLE__
+	os_log_debug(PAM_LOG, "Got user: %s", user);
+#else
+	PAM_LOG("Got user: %s", user);
+#endif
+	pamret = pam_get_item(pamh, PAM_RUSER, &ruser);
+	if (pamret != PAM_SUCCESS)
+		return (pamret);
+#if __APPLE__
+	os_log_debug(PAM_LOG, "Got ruser: %s", (const char *)ruser);
+#else
+	PAM_LOG("Got ruser: %s", (const char *)ruser);
+#endif
+	rv = krb5_init_context(&context);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_init_context failed: %s", msg);
+#else
+		PAM_LOG("krb5_init_context failed: %s", msg);
+#endif
+		krb5_free_error_message(context, msg);
+		return (PAM_SERVICE_ERR);
+	}
+	rv = get_su_principal(context, user, ruser, &su_principal_name, &su_principal);
+	if (rv != 0)
+		return (PAM_AUTH_ERR);
+#if __APPLE__
+	os_log_debug(PAM_LOG, "kuserok: %s -> %s", su_principal_name, user);
+#else
+	PAM_LOG("kuserok: %s -> %s", su_principal_name, user);
+#endif
+	rv = krb5_kuserok(context, su_principal, user);
+	pamret = rv ? auth_krb5(pamh, context, su_principal_name, su_principal) : PAM_AUTH_ERR;
+	free(su_principal_name);
+	krb5_free_principal(context, su_principal);
+	krb5_free_context(context);
+	return (pamret);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int ac __unused, const char *av[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+/* Authenticate using Kerberos 5.
+ *   pamh              -- The PAM handle.
+ *   context           -- An initialized krb5_context.
+ *   su_principal_name -- The target principal name, used only for password prompts.
+ *              If NULL, the password prompts will not include a principal
+ *              name.
+ *   su_principal      -- The target krb5_principal.
+ * Note that a valid keytab in the default location with a host entry
+ * must be available, and that the PAM application must have sufficient
+ * privileges to access it.
+ * Returns PAM_SUCCESS if authentication was successful, or an appropriate
+ * PAM error code if it was not.
+ */
+static int
+auth_krb5(pam_handle_t *pamh, krb5_context context, const char *su_principal_name,
+    krb5_principal su_principal)
+{
+	krb5_creds	 creds;
+	krb5_get_init_creds_opt *gic_opt;
+	krb5_verify_init_creds_opt vic_opt;
+	const char	*pass;
+	char		*prompt;
+	long		 rv;
+	int		 pamret;
+
+	prompt = NULL;
+	krb5_verify_init_creds_opt_init(&vic_opt);
+	if (su_principal_name != NULL)
+		(void)asprintf(&prompt, "Password for %s:", su_principal_name);
+	else
+		(void)asprintf(&prompt, "Password:");
+	if (prompt == NULL)
+		return (PAM_BUF_ERR);
+	pass = NULL;
+	pamret = pam_get_authtok(pamh, PAM_AUTHTOK, &pass, prompt);
+	free(prompt);
+	if (pamret != PAM_SUCCESS)
+		return (pamret);
+	rv = krb5_get_init_creds_opt_alloc(context, &gic_opt);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_get_init_creds_opt_alloc: %s", msg);
+#else
+		PAM_LOG("krb5_get_init_creds_opt_alloc: %s", msg);
+#endif
+		krb5_free_error_message(context, msg);
+		return (PAM_AUTH_ERR);
+	}
+	rv = krb5_get_init_creds_password(context, &creds, su_principal,
+	    pass, NULL, NULL, 0, NULL, gic_opt);
+	krb5_get_init_creds_opt_free(context, gic_opt);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_get_init_creds_password: %s", msg);
+#else
+		PAM_LOG("krb5_get_init_creds_password: %s", msg);
+#endif
+		krb5_free_error_message(context, msg);
+		return (PAM_AUTH_ERR);
+	}
+	krb5_verify_init_creds_opt_set_ap_req_nofail(&vic_opt, 1);
+	rv = krb5_verify_init_creds(context, &creds, NULL, NULL, NULL,
+	    &vic_opt);
+	krb5_free_cred_contents(context, &creds);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_verify_init_creds: %s", msg);
+#else
+		PAM_LOG("krb5_verify_init_creds: %s", msg);
+#endif
+		krb5_free_error_message(context, msg);
+		return (PAM_AUTH_ERR);
+	}
+	return (PAM_SUCCESS);
+}
+
+/* Determine the target principal given the current user and the target user.
+ *   context           -- An initialized krb5_context.
+ *   target_user       -- The target username.
+ *   current_user      -- The current username.
+ *   su_principal_name -- (out) The target principal name.
+ *   su_principal      -- (out) The target krb5_principal.
+ * When the target user is `root', the target principal will be a `root
+ * instance', e.g. `luser/root@REA.LM'.  Otherwise, the target principal
+ * will simply be the current user's default principal name.  Note that
+ * in any case, if KRB5CCNAME is set and a credentials cache exists, the
+ * principal name found there will be the `starting point', rather than
+ * the ruser parameter.
+ *
+ * Returns 0 for success, or a com_err error code on failure.
+ */
+static long
+get_su_principal(krb5_context context, const char *target_user, const char *current_user,
+    char **su_principal_name, krb5_principal *su_principal)
+{
+	krb5_principal	 default_principal;
+	krb5_ccache	 ccache;
+	char		*principal_name, *ccname, *p;
+	long		 rv;
+	uid_t		 euid, ruid;
+
+	*su_principal = NULL;
+	default_principal = NULL;
+	/* Unless KRB5CCNAME was explicitly set, we won't really be able
+	 * to look at the credentials cache since krb5_cc_default will
+	 * look at getuid().
+	 */
+	ruid = getuid();
+	euid = geteuid();
+	rv = seteuid(ruid);
+	if (rv != 0)
+		return (errno);
+	p = getenv("KRB5CCNAME");
+	if (p != NULL)
+		ccname = strdup(p);
+	else
+		(void)asprintf(&ccname, "%s%lu", KRB5_DEFAULT_CCROOT, (unsigned long)ruid);
+	if (ccname == NULL)
+		return (errno);
+	rv = krb5_cc_resolve(context, ccname, &ccache);
+	free(ccname);
+	if (rv == 0) {
+		rv = krb5_cc_get_principal(context, ccache, &default_principal);
+		krb5_cc_close(context, ccache);
+		if (rv != 0)
+			default_principal = NULL; /* just to be safe */
+	}
+	rv = seteuid(euid);
+	if (rv != 0)
+		return (errno);
+	if (default_principal == NULL) {
+		rv = krb5_make_principal(context, &default_principal, NULL, current_user, NULL);
+		if (rv != 0) {
+#if __APPLE__
+			os_log_error(PAM_LOG, "Could not determine default principal name.");
+#else
+			PAM_LOG("Could not determine default principal name.");
+#endif
+			return (rv);
+		}
+	}
+	/* Now that we have some principal, if the target account is
+	 * `root', then transform it into a `root' instance, e.g.
+	 * `user@REA.LM' -> `user/root@REA.LM'.
+	 */
+	rv = krb5_unparse_name(context, default_principal, &principal_name);
+	krb5_free_principal(context, default_principal);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_unparse_name: %s", msg);
+#else
+		PAM_LOG("krb5_unparse_name: %s", msg);
+#endif
+		krb5_free_error_message(context, msg);
+		return (rv);
+	}
+#if __APPLE__
+	os_log_debug(PAM_LOG, "Default principal name: %s", principal_name);
+#else
+	PAM_LOG("Default principal name: %s", principal_name);
+#endif
+	if (strcmp(target_user, superuser) == 0) {
+		p = strrchr(principal_name, '@');
+		if (p == NULL) {
+#if __APPLE__
+			os_log_error(PAM_LOG, "malformed principal name `%s'", principal_name);
+#else
+			PAM_LOG("malformed principal name `%s'", principal_name);
+#endif
+			free(principal_name);
+			return (rv);
+		}
+		*p++ = '\0';
+		*su_principal_name = NULL;
+		(void)asprintf(su_principal_name, "%s/%s@%s", principal_name, superuser, p);
+		free(principal_name);
+	} else
+		*su_principal_name = principal_name;
+
+	if (*su_principal_name == NULL)
+		return (errno);
+	rv = krb5_parse_name(context, *su_principal_name, &default_principal);
+	if (rv != 0) {
+		const char *msg = krb5_get_error_message(context, rv);
+#if __APPLE__
+		os_log_error(PAM_LOG, "krb5_parse_name `%s': %s", *su_principal_name, msg);
+#else
+		PAM_LOG("krb5_parse_name `%s': %s", *su_principal_name, msg);
+#endif
+		krb5_free_error_message(context, msg);
+		free(*su_principal_name);
+		return (rv);
+	}
+#if __APPLE__
+	os_log_debug(PAM_LOG, "Target principal name: %s", *su_principal_name);
+#else
+	PAM_LOG("Target principal name: %s", *su_principal_name);
+#endif
+	*su_principal = default_principal;
+	return (0);
+}
+
+PAM_MODULE_ENTRY("pam_ksu");
--- a/modules/pam_login_access/login_access.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_login_access/login_access.c	1697368549.715348463
@@ -0,0 +1,295 @@
+ /*
+  * This module implements a simple but effective form of login access
+  * control based on login names and on host (or domain) names, internet
+  * addresses (or network numbers), or on terminal line names in case of
+  * non-networked logins. Diagnostics are reported through syslog(3).
+  *
+  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
+  */
+
+#if 0
+#ifndef lint
+static char sccsid[] = "%Z% %M% %I% %E% %U%";
+#endif
+#endif
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <ctype.h>
+#include <errno.h>
+#include <grp.h>
+#include <netdb.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#include "pam_login_access.h"
+
+ /* Constants to be used in assignments only, not in comparisons... */
+
+#define YES             1
+#define NO              0
+
+static int	from_match(const char *, const char *, struct pam_login_access_options *);
+static int	list_match(char *, const char *,
+				int (*)(const char *, const char *,
+				struct pam_login_access_options *),
+				struct pam_login_access_options *);
+static int	netgroup_match(const char *, const char *, const char *);
+static int	string_match(const char *, const char *);
+static int	user_match(const char *, const char *, struct pam_login_access_options *);
+static int	group_match(const char *, const char *);
+
+/* login_access - match username/group and host/tty with access control file */
+
+int
+login_access(const char *user, const char *from,
+	struct pam_login_access_options *login_access_opts)
+{
+    FILE   *fp;
+    char    line[BUFSIZ];
+    char   *perm;			/* becomes permission field */
+    char   *users;			/* becomes list of login names */
+    char   *froms;			/* becomes list of terminals or hosts */
+    int     match = NO;
+    int     end;
+    int     lineno = 0;			/* for diagnostics */
+    const char *fieldsep = login_access_opts->fieldsep;
+
+    /*
+     * Process the table one line at a time and stop at the first match.
+     * Blank lines and lines that begin with a '#' character are ignored.
+     * Non-comment lines are broken at the ':' character. All fields are
+     * mandatory. The first field should be a "+" or "-" character. A
+     * non-existing table means no access control.
+     */
+
+    if ((fp = fopen(login_access_opts->accessfile, "r")) != NULL) {
+	while (!match && fgets(line, sizeof(line), fp)) {
+	    lineno++;
+	    if (line[end = strlen(line) - 1] != '\n') {
+		syslog(LOG_ERR, "%s: line %d: missing newline or line too long",
+		       login_access_opts->accessfile, lineno);
+		continue;
+	    }
+	    if (line[0] == '#')
+		continue;			/* comment line */
+	    while (end > 0 && isspace(line[end - 1]))
+		end--;
+	    line[end] = 0;			/* strip trailing whitespace */
+	    if (line[0] == 0)			/* skip blank lines */
+		continue;
+	    if (!(perm = strtok(line, fieldsep))
+		|| !(users = strtok((char *) 0, fieldsep))
+		|| !(froms = strtok((char *) 0, fieldsep))
+		|| strtok((char *) 0, fieldsep)) {
+		syslog(LOG_ERR, "%s: line %d: bad field count", login_access_opts->accessfile,
+		       lineno);
+		continue;
+	    }
+	    if (perm[0] != '+' && perm[0] != '-') {
+		syslog(LOG_ERR, "%s: line %d: bad first field", login_access_opts->accessfile,
+		       lineno);
+		continue;
+	    }
+	    match = (list_match(froms, from, from_match, login_access_opts)
+		     && list_match(users, user, user_match, login_access_opts));
+	}
+	(void) fclose(fp);
+    } else if (errno != ENOENT) {
+	syslog(LOG_ERR, "cannot open %s: %m", login_access_opts->accessfile);
+    }
+    return (match == 0 || (line[0] == '+'));
+}
+
+/* list_match - match an item against a list of tokens with exceptions */
+
+static int
+list_match(char *list, const char *item,
+    int (*match_fn)(const char *, const char *, struct pam_login_access_options *),
+    struct pam_login_access_options *login_access_opts)
+{
+    char   *tok;
+    int     match = NO;
+    const char *listsep = login_access_opts->listsep;
+
+    /*
+     * Process tokens one at a time. We have exhausted all possible matches
+     * when we reach an "EXCEPT" token or the end of the list. If we do find
+     * a match, look for an "EXCEPT" list and recurse to determine whether
+     * the match is affected by any exceptions.
+     */
+
+    for (tok = strtok(list, listsep); tok != NULL; tok = strtok((char *) 0, listsep)) {
+	if (strcmp(tok, "EXCEPT") == 0)	/* EXCEPT: give up */
+	    break;
+	if ((match = (*match_fn)(tok, item, login_access_opts)) != 0)	/* YES */
+	    break;
+    }
+    /* Process exceptions to matches. */
+
+    if (match != NO) {
+	while ((tok = strtok((char *) 0, listsep)) && strcmp(tok, "EXCEPT")) {
+	     /* VOID */ ;
+	}
+	if (tok == NULL ||
+	    list_match((char *) 0, item, match_fn, login_access_opts) == NO) {
+		return (match);
+	}
+    }
+    return (NO);
+}
+
+/* netgroup_match - match group against machine or user */
+
+static int
+netgroup_match(const char *group, const char *machine, const char *user)
+{
+    char domain[1024];
+    unsigned int i;
+
+    if (getdomainname(domain, sizeof(domain)) != 0 || *domain == '\0') {
+	syslog(LOG_ERR, "NIS netgroup support disabled: no NIS domain");
+	return (NO);
+    }
+
+    /* getdomainname() does not reliably terminate the string */
+    for (i = 0; i < sizeof(domain); ++i)
+	if (domain[i] == '\0')
+	    break;
+    if (i == sizeof(domain)) {
+	syslog(LOG_ERR, "NIS netgroup support disabled: invalid NIS domain");
+	return (NO);
+    }
+
+    if (innetgr(group, machine, user, domain) == 1)
+	return (YES);
+    return (NO);
+}
+
+/* group_match - match a group against one token */
+
+int
+group_match(const char *tok, const char *username)
+{
+    struct group *group;
+    struct passwd *passwd;
+    gid_t *grouplist;
+    int i, ret, ngroups = NGROUPS;
+
+    if ((passwd = getpwnam(username)) == NULL)
+	return (NO);
+    errno = 0;
+    if ((group = getgrnam(tok)) == NULL) {
+	if (errno != 0)
+	    syslog(LOG_ERR, "getgrnam() failed for %s: %s", username, strerror(errno));
+	else
+	    syslog(LOG_NOTICE, "group not found: %s", username);
+	return (NO);
+    }
+    if ((grouplist = calloc(ngroups, sizeof(gid_t))) == NULL) {
+	syslog(LOG_ERR, "cannot allocate memory for grouplist: %s", username);
+	return (NO);
+    }
+    ret = NO;
+    if (getgrouplist(username, passwd->pw_gid, grouplist, &ngroups) != 0)
+	syslog(LOG_ERR, "getgrouplist() failed for %s", username);
+    for (i = 0; i < ngroups; i++)
+	if (grouplist[i] == group->gr_gid)
+	    ret = YES;
+    free(grouplist);
+    return (ret);
+}
+
+/* user_match - match a username against one token */
+
+static int
+user_match(const char *tok, const char *string,
+	struct pam_login_access_options *login_access_opts)
+{
+    size_t stringlen;
+    char *grpstr;
+    int rc;
+
+    /*
+     * If a token has the magic value "ALL" the match always succeeds.
+     * Otherwise, return YES if the token fully matches the username, or if
+     * the token is a group that contains the username.
+     */
+
+    if (tok[0] == '@') {			/* netgroup */
+	return (netgroup_match(tok + 1, (char *) 0, string));
+    } else if (tok[0] == '(' && tok[(stringlen = strlen(&tok[1]))] == ')') {		/* group */
+	if ((grpstr = strndup(&tok[1], stringlen - 1)) == NULL) {
+	    syslog(LOG_ERR, "cannot allocate memory for %s", string);
+	    return (NO);
+	}
+	rc = group_match(grpstr, string);
+	free(grpstr);
+	return (rc);
+    } else if (string_match(tok, string)) {	/* ALL or exact match */
+	return (YES);
+    } else if (login_access_opts->defgroup == true) {/* try group membership */
+	return (group_match(tok, string));
+    }
+    return (NO);
+}
+
+/* from_match - match a host or tty against a list of tokens */
+
+static int
+from_match(const char *tok, const char *string,
+	struct pam_login_access_options *login_access_opts __unused)
+{
+    int     tok_len;
+    int     str_len;
+
+    /*
+     * If a token has the magic value "ALL" the match always succeeds. Return
+     * YES if the token fully matches the string. If the token is a domain
+     * name, return YES if it matches the last fields of the string. If the
+     * token has the magic value "LOCAL", return YES if the string does not
+     * contain a "." character. If the token is a network number, return YES
+     * if it matches the head of the string.
+     */
+
+    if (tok[0] == '@') {			/* netgroup */
+	return (netgroup_match(tok + 1, string, (char *) 0));
+    } else if (string_match(tok, string)) {	/* ALL or exact match */
+	return (YES);
+    } else if (tok[0] == '.') {			/* domain: match last fields */
+	if ((str_len = strlen(string)) > (tok_len = strlen(tok))
+	    && strcasecmp(tok, string + str_len - tok_len) == 0)
+	    return (YES);
+    } else if (strcmp(tok, "LOCAL") == 0) {	/* local: no dots */
+	if (strchr(string, '.') == NULL)
+	    return (YES);
+    } else if (tok[(tok_len = strlen(tok)) - 1] == '.'	/* network */
+	       && strncmp(tok, string, tok_len) == 0) {
+	return (YES);
+    }
+    return (NO);
+}
+
+/* string_match - match a string against one token */
+
+static int
+string_match(const char *tok, const char *string)
+{
+
+    /*
+     * If the token has the magic value "ALL" the match always succeeds.
+     * Otherwise, return YES if the token fully matches the string.
+     */
+
+    if (strcmp(tok, "ALL") == 0) {		/* all: always matches */
+	return (YES);
+    } else if (strcasecmp(tok, string) == 0) {	/* try exact match */
+	return (YES);
+    }
+    return (NO);
+}
--- a/modules/pam_login_access/pam_login_access.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_login_access/pam_login_access.c	1697368466.122705252
@@ -0,0 +1,141 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001 Mark R V Murray
+ * All rights reserved.
+ * Copyright (c) 2001 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#define _BSD_SOURCE
+
+#include <sys/param.h>
+#include <sys/types.h>
+
+#include <syslog.h>
+#include <unistd.h>
+
+#define PAM_SM_ACCOUNT
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+#include <security/openpam.h>
+
+#include "pam_login_access.h"
+
+#define OPT_ACCESSFILE		"accessfile"
+#define OPT_NOAUDIT		"noaudit"
+#define OPT_FIELDSEP		"fieldsep"
+#define OPT_LISTSEP		"listsep"
+#define OPT_NODEFGROUP		"nodefgroup"
+
+#define _PATH_LOGACCESS		"/etc/login.access"
+#define _FIELD_SEPARATOR	":"
+#define _LIST_SEPARATOR		", \t"
+
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(login_access)
+#define PAM_LOG PAM_LOG_login_access()
+#define PAM_LOG_DEBUG(...) \
+	os_log_debug(PAM_LOG, __VA_ARGS__)
+#define PAM_VERBOSE_ERROR(...) \
+	os_log_error(PAM_LOG, __VA_ARGS__)
+#endif
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct pam_login_access_options	login_access_opts;
+	const void *rhost, *tty, *user;
+	char hostname[MAXHOSTNAMELEN];
+	int pam_err;
+
+	pam_err = pam_get_item(pamh, PAM_USER, &user);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	if (user == NULL)
+		return (PAM_SERVICE_ERR);
+
+	PAM_LOG_DEBUG("Got user: %s", (const char *)user);
+
+	pam_err = pam_get_item(pamh, PAM_RHOST, &rhost);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	pam_err = pam_get_item(pamh, PAM_TTY, &tty);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	gethostname(hostname, sizeof hostname);
+	login_access_opts.defgroup = openpam_get_option(pamh, OPT_NODEFGROUP) == NULL ? true : false;
+	login_access_opts.audit = openpam_get_option(pamh, OPT_NOAUDIT) == NULL ? true : false;
+	if ((login_access_opts.accessfile = openpam_get_option(pamh, OPT_ACCESSFILE)) == NULL)
+		login_access_opts.accessfile = _PATH_LOGACCESS;
+	if ((login_access_opts.fieldsep = openpam_get_option(pamh, OPT_FIELDSEP)) == NULL)
+		login_access_opts.fieldsep = _FIELD_SEPARATOR;
+	if ((login_access_opts.listsep = openpam_get_option(pamh, OPT_LISTSEP)) == NULL)
+		login_access_opts.listsep = _LIST_SEPARATOR;
+
+	if (rhost != NULL && *(const char *)rhost != '\0') {
+		PAM_LOG_DEBUG("Checking login.access for user %s from host %s",
+		    (const char *)user, (const char *)rhost);
+		if (login_access(user, rhost, &login_access_opts) != 0)
+			return (PAM_SUCCESS);
+		PAM_VERBOSE_ERROR("%s is not allowed to log in from %s",
+		    (const char *)user, (const char *)rhost);
+	} else if (tty != NULL && *(const char *)tty != '\0') {
+		PAM_LOG_DEBUG("Checking login.access for user %s on tty %s",
+		    (const char *)user, (const char *)tty);
+		if (login_access(user, tty, &login_access_opts) != 0)
+			return (PAM_SUCCESS);
+		PAM_VERBOSE_ERROR("%s is not allowed to log in on %s",
+		    (const char *)user, (const char *)tty);
+	} else {
+		PAM_LOG_DEBUG("Checking login.access for user %s",
+		    (const char *)user);
+		if (login_access(user, "***unknown***", &login_access_opts) != 0)
+			return (PAM_SUCCESS);
+		PAM_VERBOSE_ERROR("%s is not allowed to log in",
+		    (const char *)user);
+	}
+
+	return (PAM_AUTH_ERR);
+}
+
+PAM_MODULE_ENTRY("pam_login_access");
--- a/modules/pam_login_access/pam_login_access.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_login_access/pam_login_access.h	1697368506.055803491
@@ -0,0 +1,50 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001 Mark R V Murray
+ * All rights reserved.
+ * Copyright (c) 2001 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdbool.h>
+
+struct pam_login_access_options {
+	bool		defgroup;
+	bool		audit;
+	const char	*accessfile;
+	/* Delimiters for fields and for lists of users, ttys or hosts. */
+	const char	*fieldsep; /* field separator */
+	const char	*listsep; /* list-element separator */
+};
+
+extern int login_access(const char *, const char *, struct pam_login_access_options *);
--- a/modules/pam_passwdqc/pam_macros.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/pam_macros.h	1697368935.551106908
@@ -0,0 +1,28 @@
+/*
+ * These macros are partially based on Linux-PAM's <security/_pam_macros.h>,
+ * which were organized by Cristian Gafton and I believe are in the public
+ * domain.
+ */
+
+#if !defined(_PAM_MACROS_H) && !defined(_pam_overwrite)
+#define _PAM_MACROS_H
+
+#include <string.h>
+#include <stdlib.h>
+
+#define _pam_overwrite(x) \
+	memset((x), 0, strlen((x)))
+
+#define _pam_drop_reply(/* struct pam_response * */ reply, /* int */ replies) \
+do { \
+	int i; \
+\
+	for (i = 0; i < (replies); i++) \
+	if ((reply)[i].resp) { \
+		_pam_overwrite((reply)[i].resp); \
+		free((reply)[i].resp); \
+	} \
+	if ((reply)) free((reply)); \
+} while (0)
+
+#endif
--- a/modules/pam_passwdqc/pam_passwdqc.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/pam_passwdqc.c	1697368892.962987872
@@ -0,0 +1,568 @@
+/*
+ * Copyright (c) 2000-2002 by Solar Designer. See LICENSE.
+ */
+
+#define _XOPEN_SOURCE 600
+#define _XOPEN_SOURCE_EXTENDED
+#define _XOPEN_VERSION 600
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <limits.h>
+#include <unistd.h>
+#include <pwd.h>
+#ifdef HAVE_SHADOW
+#include <shadow.h>
+#endif
+
+#define PAM_SM_PASSWORD
+#ifndef LINUX_PAM
+#include <security/pam_appl.h>
+#endif
+#include <security/pam_modules.h>
+
+#include "pam_macros.h"
+
+#if !defined(PAM_EXTERN) && !defined(PAM_STATIC)
+#define PAM_EXTERN			extern
+#endif
+
+#if !defined(PAM_AUTHTOK_RECOVERY_ERR) && defined(PAM_AUTHTOK_RECOVER_ERR)
+#define PAM_AUTHTOK_RECOVERY_ERR	PAM_AUTHTOK_RECOVER_ERR
+#endif
+
+#if defined(__sun__) && !defined(LINUX_PAM) && !defined(_OPENPAM)
+/* Sun's PAM doesn't use const here */
+#define lo_const
+#else
+#define lo_const			const
+#endif
+typedef lo_const void *pam_item_t;
+
+#include "passwdqc.h"
+
+#define F_ENFORCE_MASK			0x00000003
+#define F_ENFORCE_USERS			0x00000001
+#define F_ENFORCE_ROOT			0x00000002
+#define F_ENFORCE_EVERYONE		F_ENFORCE_MASK
+#define F_NON_UNIX			0x00000004
+#define F_ASK_OLDAUTHTOK_MASK		0x00000030
+#define F_ASK_OLDAUTHTOK_PRELIM		0x00000010
+#define F_ASK_OLDAUTHTOK_UPDATE		0x00000020
+#define F_CHECK_OLDAUTHTOK		0x00000040
+#define F_USE_FIRST_PASS		0x00000100
+#define F_USE_AUTHTOK			0x00000200
+
+typedef struct {
+	passwdqc_params_t qc;
+	int flags;
+	int retry;
+} params_t;
+
+static params_t defaults = {
+	{
+		{INT_MAX, 24, 12, 8, 7},	/* min */
+		40,				/* max */
+		3,				/* passphrase_words */
+		4,				/* match_length */
+		1,				/* similar_deny */
+		42				/* random_bits */
+	},
+	F_ENFORCE_EVERYONE,			/* flags */
+	3					/* retry */
+};
+
+#define PROMPT_OLDPASS \
+	"Enter current password: "
+#define PROMPT_NEWPASS1 \
+	"Enter new password: "
+#define PROMPT_NEWPASS2 \
+	"Re-type new password: "
+
+#define MESSAGE_MISCONFIGURED \
+	"System configuration error.  Please contact your administrator."
+#define MESSAGE_INVALID_OPTION \
+	"pam_passwdqc: Invalid option: \"%s\"."
+#define MESSAGE_INTRO_PASSWORD \
+	"\nYou can now choose the new password.\n"
+#define MESSAGE_INTRO_BOTH \
+	"\nYou can now choose the new password or passphrase.\n"
+#define MESSAGE_EXPLAIN_PASSWORD_1 \
+	"A valid password should be a mix of upper and lower case letters,\n" \
+	"digits and other characters.  You can use a%s %d character long\n" \
+	"password with characters from at least 3 of these 4 classes.\n" \
+	"Characters that form a common pattern are discarded by the check.\n"
+#define MESSAGE_EXPLAIN_PASSWORD_2 \
+	"A valid password should be a mix of upper and lower case letters,\n" \
+	"digits and other characters.  You can use a%s %d character long\n" \
+	"password with characters from at least 3 of these 4 classes, or\n" \
+	"a%s %d character long password containing characters from all the\n" \
+	"classes.  Characters that form a common pattern are discarded by\n" \
+	"the check.\n"
+#define MESSAGE_EXPLAIN_PASSPHRASE \
+	"A passphrase should be of at least %d words, %d to %d characters\n" \
+	"long and contain enough different characters.\n"
+#define MESSAGE_RANDOM \
+	"Alternatively, if noone else can see your terminal now, you can\n" \
+	"pick this as your password: \"%s\".\n"
+#define MESSAGE_RANDOMONLY \
+	"This system is configured to permit randomly generated passwords\n" \
+	"only.  If noone else can see your terminal now, you can pick this\n" \
+	"as your password: \"%s\".  Otherwise, come back later.\n"
+#define MESSAGE_RANDOMFAILED \
+	"This system is configured to use randomly generated passwords\n" \
+	"only, but the attempt to generate a password has failed.  This\n" \
+	"could happen for a number of reasons: you could have requested\n" \
+	"an impossible password length, or the access to kernel random\n" \
+	"number pool could have failed."
+#define MESSAGE_TOOLONG \
+	"This password may be too long for some services.  Choose another."
+#define MESSAGE_TRUNCATED \
+	"Warning: your longer password will be truncated to 8 characters."
+#define MESSAGE_WEAKPASS \
+	"Weak password: %s."
+#define MESSAGE_NOTRANDOM \
+	"Sorry, you've mistyped the password that was generated for you."
+#define MESSAGE_MISTYPED \
+	"Sorry, passwords do not match."
+#define MESSAGE_RETRY \
+	"Try again."
+
+static int converse(pam_handle_t *pamh, int style, lo_const char *text,
+    struct pam_response **resp)
+{
+	pam_item_t item;
+	lo_const struct pam_conv *conv;
+	struct pam_message msg, *pmsg;
+	int status;
+
+	status = pam_get_item(pamh, PAM_CONV, &item);
+	if (status != PAM_SUCCESS)
+		return status;
+	conv = item;
+
+	pmsg = &msg;
+	msg.msg_style = style;
+	msg.msg = (char *)text;
+
+	*resp = NULL;
+	return conv->conv(1, (lo_const struct pam_message **)&pmsg, resp,
+	    conv->appdata_ptr);
+}
+
+#ifdef __GNUC__
+__attribute__ ((format (printf, 3, 4)))
+#endif
+static int say(pam_handle_t *pamh, int style, const char *format, ...)
+{
+	va_list args;
+	char buffer[0x800];
+	int needed;
+	struct pam_response *resp;
+	int status;
+
+	va_start(args, format);
+	needed = vsnprintf(buffer, sizeof(buffer), format, args);
+	va_end(args);
+
+	if ((unsigned int)needed < sizeof(buffer)) {
+		status = converse(pamh, style, buffer, &resp);
+		_pam_overwrite(buffer);
+	} else {
+		status = PAM_ABORT;
+		memset(buffer, 0, sizeof(buffer));
+	}
+
+	return status;
+}
+
+static int check_max(params_t *params, pam_handle_t *pamh, const char *newpass)
+{
+	if ((int)strlen(newpass) > params->qc.max) {
+		if (params->qc.max != 8) {
+			say(pamh, PAM_ERROR_MSG, MESSAGE_TOOLONG);
+			return -1;
+		}
+		say(pamh, PAM_TEXT_INFO, MESSAGE_TRUNCATED);
+	}
+
+	return 0;
+}
+
+static int parse(params_t *params, pam_handle_t *pamh,
+    int argc, const char **argv)
+{
+	const char *p;
+	char *e;
+	int i;
+	unsigned long v;
+
+	while (argc) {
+		if (!strncmp(*argv, "min=", 4)) {
+			p = *argv + 4;
+			for (i = 0; i < 5; i++) {
+				if (!strncmp(p, "disabled", 8)) {
+					v = INT_MAX;
+					p += 8;
+				} else {
+					v = strtoul(p, &e, 10);
+					p = e;
+				}
+				if (i < 4 && *p++ != ',') break;
+				if (v > INT_MAX) break;
+				if (i && (int)v > params->qc.min[i - 1]) break;
+				params->qc.min[i] = v;
+			}
+			if (*p) break;
+		} else
+		if (!strncmp(*argv, "max=", 4)) {
+			v = strtoul(*argv + 4, &e, 10);
+			if (*e || v < 8 || v > INT_MAX) break;
+			params->qc.max = v;
+		} else
+		if (!strncmp(*argv, "passphrase=", 11)) {
+			v = strtoul(*argv + 11, &e, 10);
+			if (*e || v > INT_MAX) break;
+			params->qc.passphrase_words = v;
+		} else
+		if (!strncmp(*argv, "match=", 6)) {
+			v = strtoul(*argv + 6, &e, 10);
+			if (*e || v > INT_MAX) break;
+			params->qc.match_length = v;
+		} else
+		if (!strncmp(*argv, "similar=", 8)) {
+			if (!strcmp(*argv + 8, "permit"))
+				params->qc.similar_deny = 0;
+			else
+			if (!strcmp(*argv + 8, "deny"))
+				params->qc.similar_deny = 1;
+			else
+				break;
+		} else
+		if (!strncmp(*argv, "random=", 7)) {
+			v = strtoul(*argv + 7, &e, 10);
+			if (!strcmp(e, ",only")) {
+				e += 5;
+				params->qc.min[4] = INT_MAX;
+			}
+			if (*e || v > INT_MAX) break;
+			params->qc.random_bits = v;
+		} else
+		if (!strncmp(*argv, "enforce=", 8)) {
+			params->flags &= ~F_ENFORCE_MASK;
+			if (!strcmp(*argv + 8, "users"))
+				params->flags |= F_ENFORCE_USERS;
+			else
+			if (!strcmp(*argv + 8, "everyone"))
+				params->flags |= F_ENFORCE_EVERYONE;
+			else
+			if (strcmp(*argv + 8, "none"))
+				break;
+		} else
+		if (!strcmp(*argv, "non-unix")) {
+			if (params->flags & F_CHECK_OLDAUTHTOK) break;
+			params->flags |= F_NON_UNIX;
+		} else
+		if (!strncmp(*argv, "retry=", 6)) {
+			v = strtoul(*argv + 6, &e, 10);
+			if (*e || v > INT_MAX) break;
+			params->retry = v;
+		} else
+		if (!strncmp(*argv, "ask_oldauthtok", 14)) {
+			params->flags &= ~F_ASK_OLDAUTHTOK_MASK;
+			if (params->flags & F_USE_FIRST_PASS) break;
+			if (!strcmp(*argv + 14, "=update"))
+				params->flags |= F_ASK_OLDAUTHTOK_UPDATE;
+			else
+			if (!(*argv)[14])
+				params->flags |= F_ASK_OLDAUTHTOK_PRELIM;
+			else
+				break;
+		} else
+		if (!strcmp(*argv, "check_oldauthtok")) {
+			if (params->flags & F_NON_UNIX) break;
+			params->flags |= F_CHECK_OLDAUTHTOK;
+		} else
+		if (!strcmp(*argv, "use_first_pass")) {
+			if (params->flags & F_ASK_OLDAUTHTOK_MASK) break;
+			params->flags |= F_USE_FIRST_PASS | F_USE_AUTHTOK;
+		} else
+		if (!strcmp(*argv, "use_authtok")) {
+			params->flags |= F_USE_AUTHTOK;
+		} else
+			break;
+		argc--; argv++;
+	}
+
+	if (argc) {
+		if (getuid() != 0) {
+			say(pamh, PAM_ERROR_MSG, MESSAGE_MISCONFIGURED);
+		} else {
+			say(pamh, PAM_ERROR_MSG, MESSAGE_INVALID_OPTION, *argv);
+		}
+		return PAM_ABORT;
+	}
+
+	return PAM_SUCCESS;
+}
+
+PAM_EXTERN int pam_sm_chauthtok(pam_handle_t *pamh, int flags,
+    int argc, const char **argv)
+{
+	params_t params;
+	struct pam_response *resp;
+	struct passwd *pw, fake_pw;
+#ifdef HAVE_SHADOW
+	struct spwd *spw;
+#endif
+	pam_item_t item;
+	lo_const char *user, *oldpass, *curpass;
+	char *newpass, *randompass;
+	const char *reason;
+	int ask_oldauthtok;
+	int randomonly, enforce, retries_left, retry_wanted;
+	int status;
+
+	params = defaults;
+	status = parse(&params, pamh, argc, argv);
+	if (status != PAM_SUCCESS)
+		return status;
+
+	ask_oldauthtok = 0;
+	if (flags & PAM_PRELIM_CHECK) {
+		if (params.flags & F_ASK_OLDAUTHTOK_PRELIM)
+			ask_oldauthtok = 1;
+	} else
+	if (flags & PAM_UPDATE_AUTHTOK) {
+		if (params.flags & F_ASK_OLDAUTHTOK_UPDATE)
+			ask_oldauthtok = 1;
+	} else
+		return PAM_SERVICE_ERR;
+
+	if (ask_oldauthtok && getuid() != 0) {
+		status = converse(pamh, PAM_PROMPT_ECHO_OFF,
+		    PROMPT_OLDPASS, &resp);
+
+		if (status == PAM_SUCCESS) {
+			if (resp && resp->resp) {
+				status = pam_set_item(pamh,
+				    PAM_OLDAUTHTOK, resp->resp);
+				_pam_drop_reply(resp, 1);
+			} else
+				status = PAM_AUTHTOK_RECOVERY_ERR;
+		}
+
+		if (status != PAM_SUCCESS)
+			return status;
+	}
+
+	if (flags & PAM_PRELIM_CHECK)
+		return status;
+
+	status = pam_get_item(pamh, PAM_USER, &item);
+	if (status != PAM_SUCCESS)
+		return status;
+	user = item;
+
+	status = pam_get_item(pamh, PAM_OLDAUTHTOK, &item);
+	if (status != PAM_SUCCESS)
+		return status;
+	oldpass = item;
+
+	if (params.flags & F_NON_UNIX) {
+		pw = &fake_pw;
+		pw->pw_name = (char *)user;
+		pw->pw_gecos = "";
+	} else {
+		pw = getpwnam(user);
+		endpwent();
+		if (!pw)
+			return PAM_USER_UNKNOWN;
+		if ((params.flags & F_CHECK_OLDAUTHTOK) && getuid() != 0) {
+			if (!oldpass)
+				status = PAM_AUTH_ERR;
+			else
+#ifdef HAVE_SHADOW
+			if (!strcmp(pw->pw_passwd, "x")) {
+				spw = getspnam(user);
+				endspent();
+				if (spw) {
+					if (strcmp(crypt(oldpass, spw->sp_pwdp),
+					    spw->sp_pwdp))
+						status = PAM_AUTH_ERR;
+					memset(spw->sp_pwdp, 0,
+					    strlen(spw->sp_pwdp));
+				} else
+					status = PAM_AUTH_ERR;
+			} else
+#endif
+			if (strcmp(crypt(oldpass, pw->pw_passwd),
+			    pw->pw_passwd))
+				status = PAM_AUTH_ERR;
+		}
+		memset(pw->pw_passwd, 0, strlen(pw->pw_passwd));
+		if (status != PAM_SUCCESS)
+			return status;
+	}
+
+	randomonly = params.qc.min[4] > params.qc.max;
+
+	if (getuid() != 0)
+		enforce = params.flags & F_ENFORCE_USERS;
+	else
+		enforce = params.flags & F_ENFORCE_ROOT;
+
+	if (params.flags & F_USE_AUTHTOK) {
+		status = pam_get_item(pamh, PAM_AUTHTOK, &item);
+		if (status != PAM_SUCCESS)
+			return status;
+		curpass = item;
+		if (!curpass || (check_max(&params, pamh, curpass) && enforce))
+			return PAM_AUTHTOK_ERR;
+		reason = _passwdqc_check(&params.qc, curpass, oldpass, pw);
+		if (reason) {
+			say(pamh, PAM_ERROR_MSG, MESSAGE_WEAKPASS, reason);
+			if (enforce)
+				status = PAM_AUTHTOK_ERR;
+		}
+		return status;
+	}
+
+	retries_left = params.retry;
+
+retry:
+	retry_wanted = 0;
+
+	if (!randomonly &&
+	    params.qc.passphrase_words && params.qc.min[2] <= params.qc.max)
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_INTRO_BOTH);
+	else
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_INTRO_PASSWORD);
+	if (status != PAM_SUCCESS)
+		return status;
+
+	if (!randomonly && params.qc.min[3] <= params.qc.min[4])
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_EXPLAIN_PASSWORD_1,
+		    params.qc.min[3] == 8 || params.qc.min[3] == 11 ? "n" : "",
+		    params.qc.min[3]);
+	else
+	if (!randomonly)
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_EXPLAIN_PASSWORD_2,
+		    params.qc.min[3] == 8 || params.qc.min[3] == 11 ? "n" : "",
+		    params.qc.min[3],
+		    params.qc.min[4] == 8 || params.qc.min[4] == 11 ? "n" : "",
+		    params.qc.min[4]);
+	if (status != PAM_SUCCESS)
+		return status;
+
+	if (!randomonly &&
+	    params.qc.passphrase_words &&
+	    params.qc.min[2] <= params.qc.max) {
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_EXPLAIN_PASSPHRASE,
+		    params.qc.passphrase_words,
+		    params.qc.min[2], params.qc.max);
+		if (status != PAM_SUCCESS)
+			return status;
+	}
+
+	randompass = _passwdqc_random(&params.qc);
+	if (randompass) {
+		status = say(pamh, PAM_TEXT_INFO, randomonly ?
+		    MESSAGE_RANDOMONLY : MESSAGE_RANDOM, randompass);
+		if (status != PAM_SUCCESS) {
+			_pam_overwrite(randompass);
+			randompass = NULL;
+		}
+	} else
+	if (randomonly) {
+		say(pamh, PAM_ERROR_MSG, getuid() != 0 ?
+		    MESSAGE_MISCONFIGURED : MESSAGE_RANDOMFAILED);
+		return PAM_AUTHTOK_ERR;
+	}
+
+	status = converse(pamh, PAM_PROMPT_ECHO_OFF, PROMPT_NEWPASS1, &resp);
+	if (status == PAM_SUCCESS && (!resp || !resp->resp))
+		status = PAM_AUTHTOK_ERR;
+
+	if (status != PAM_SUCCESS) {
+		if (randompass) _pam_overwrite(randompass);
+		return status;
+	}
+
+	newpass = strdup(resp->resp);
+
+	_pam_drop_reply(resp, 1);
+
+	if (!newpass) {
+		if (randompass) _pam_overwrite(randompass);
+		return status;
+	}
+
+	if (check_max(&params, pamh, newpass) && enforce) {
+		status = PAM_AUTHTOK_ERR;
+		retry_wanted = 1;
+	}
+
+	reason = NULL;
+	if (status == PAM_SUCCESS &&
+	    (!randompass || !strstr(newpass, randompass)) &&
+	    (randomonly ||
+	    (reason = _passwdqc_check(&params.qc, newpass, oldpass, pw)))) {
+		if (randomonly)
+			say(pamh, PAM_ERROR_MSG, MESSAGE_NOTRANDOM);
+		else
+			say(pamh, PAM_ERROR_MSG, MESSAGE_WEAKPASS, reason);
+		if (enforce) {
+			status = PAM_AUTHTOK_ERR;
+			retry_wanted = 1;
+		}
+	}
+
+	if (status == PAM_SUCCESS)
+		status = converse(pamh, PAM_PROMPT_ECHO_OFF,
+		    PROMPT_NEWPASS2, &resp);
+	if (status == PAM_SUCCESS) {
+		if (resp && resp->resp) {
+			if (strcmp(newpass, resp->resp)) {
+				status = say(pamh,
+				    PAM_ERROR_MSG, MESSAGE_MISTYPED);
+				if (status == PAM_SUCCESS) {
+					status = PAM_AUTHTOK_ERR;
+					retry_wanted = 1;
+				}
+			}
+			_pam_drop_reply(resp, 1);
+		} else
+			status = PAM_AUTHTOK_ERR;
+	}
+
+	if (status == PAM_SUCCESS)
+		status = pam_set_item(pamh, PAM_AUTHTOK, newpass);
+
+	if (randompass) _pam_overwrite(randompass);
+	_pam_overwrite(newpass);
+	free(newpass);
+
+	if (retry_wanted && --retries_left > 0) {
+		status = say(pamh, PAM_TEXT_INFO, MESSAGE_RETRY);
+		if (status == PAM_SUCCESS)
+			goto retry;
+	}
+
+	return status;
+}
+
+#ifdef PAM_MODULE_ENTRY
+PAM_MODULE_ENTRY("pam_passwdqc");
+#elif defined(PAM_STATIC)
+struct pam_module _pam_passwdqc_modstruct = {
+	"pam_passwdqc",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	pam_sm_chauthtok
+};
+#endif
--- a/modules/pam_passwdqc/passwdqc.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/passwdqc.h	1697368932.813125460
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2000-2002 by Solar Designer. See LICENSE.
+ */
+
+#ifndef _PASSWDQC_H
+#define _PASSWDQC_H
+
+#include <pwd.h>
+
+typedef struct {
+	int min[5], max;
+	int passphrase_words;
+	int match_length;
+	int similar_deny;
+	int random_bits;
+} passwdqc_params_t;
+
+extern char _passwdqc_wordset_4k[0x1000][6];
+
+extern const char *_passwdqc_check(passwdqc_params_t *params,
+    const char *newpass, const char *oldpass, struct passwd *pw);
+extern char *_passwdqc_random(passwdqc_params_t *params);
+
+#endif
--- a/modules/pam_passwdqc/passwdqc_check.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/passwdqc_check.c	1697368895.894908741
@@ -0,0 +1,361 @@
+/*
+ * Copyright (c) 2000-2002 by Solar Designer. See LICENSE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <pwd.h>
+
+#include "passwdqc.h"
+
+#define REASON_ERROR \
+	"check failed"
+
+#define REASON_SAME \
+	"is the same as the old one"
+#define REASON_SIMILAR \
+	"is based on the old one"
+
+#define REASON_SHORT \
+	"too short"
+#define REASON_LONG \
+	"too long"
+
+#define REASON_SIMPLESHORT \
+	"not enough different characters or classes for this length"
+#define REASON_SIMPLE \
+	"not enough different characters or classes"
+
+#define REASON_PERSONAL \
+	"based on personal login information"
+
+#define REASON_WORD \
+	"based on a dictionary word and not a passphrase"
+
+#define FIXED_BITS			15
+
+typedef unsigned long fixed;
+
+/*
+ * Calculates the expected number of different characters for a random
+ * password of a given length. The result is rounded down. We use this
+ * with the _requested_ minimum length (so longer passwords don't have
+ * to meet this strict requirement for their length).
+ */
+static int expected_different(int charset, int length)
+{
+	fixed x, y, z;
+
+	x = ((fixed)(charset - 1) << FIXED_BITS) / charset;
+	y = x;
+	while (--length > 0) y = (y * x) >> FIXED_BITS;
+	z = (fixed)charset * (((fixed)1 << FIXED_BITS) - y);
+
+	return (int)(z >> FIXED_BITS);
+}
+
+/*
+ * A password is too simple if it is too short for its class, or doesn't
+ * contain enough different characters for its class, or doesn't contain
+ * enough words for a passphrase.
+ */
+static int is_simple(passwdqc_params_t *params, const char *newpass)
+{
+	int length, classes, words, chars;
+	int digits, lowers, uppers, others, unknowns;
+	int c, p;
+
+	length = classes = words = chars = 0;
+	digits = lowers = uppers = others = unknowns = 0;
+	p = ' ';
+	while ((c = (unsigned char)newpass[length])) {
+		length++;
+
+		if (!isascii(c)) unknowns++; else
+		if (isdigit(c)) digits++; else
+		if (islower(c)) lowers++; else
+		if (isupper(c)) uppers++; else
+			others++;
+
+		if (isascii(c) && isalpha(c) && isascii(p) && !isalpha(p))
+			words++;
+		p = c;
+
+		if (!strchr(&newpass[length], c))
+			chars++;
+	}
+
+	if (!length) return 1;
+
+/* Upper case characters and digits used in common ways don't increase the
+ * strength of a password */
+	c = (unsigned char)newpass[0];
+	if (uppers && isascii(c) && isupper(c)) uppers--;
+	c = (unsigned char)newpass[length - 1];
+	if (digits && isascii(c) && isdigit(c)) digits--;
+
+/* Count the number of different character classes we've seen. We assume
+ * that there're no non-ASCII characters for digits. */
+	classes = 0;
+	if (digits) classes++;
+	if (lowers) classes++;
+	if (uppers) classes++;
+	if (others) classes++;
+	if (unknowns && (!classes || (digits && classes == 1))) classes++;
+
+	for (; classes > 0; classes--)
+	switch (classes) {
+	case 1:
+		if (length >= params->min[0] &&
+		    chars >= expected_different(10, params->min[0]) - 1)
+			return 0;
+		return 1;
+
+	case 2:
+		if (length >= params->min[1] &&
+		    chars >= expected_different(36, params->min[1]) - 1)
+			return 0;
+		if (!params->passphrase_words ||
+		    words < params->passphrase_words)
+			continue;
+		if (length >= params->min[2] &&
+		    chars >= expected_different(27, params->min[2]) - 1)
+			return 0;
+		continue;
+
+	case 3:
+		if (length >= params->min[3] &&
+		    chars >= expected_different(62, params->min[3]) - 1)
+			return 0;
+		continue;
+
+	case 4:
+		if (length >= params->min[4] &&
+		    chars >= expected_different(95, params->min[4]) - 1)
+			return 0;
+		continue;
+	}
+
+	return 1;
+}
+
+static char *unify(const char *src)
+{
+	const char *sptr;
+	char *dst, *dptr;
+	int c;
+
+	if (!(dst = malloc(strlen(src) + 1)))
+		return NULL;
+
+	sptr = src;
+	dptr = dst;
+	do {
+		c = (unsigned char)*sptr;
+		if (isascii(c) && isupper(c))
+			*dptr++ = tolower(c);
+		else
+			*dptr++ = *sptr;
+	} while (*sptr++);
+
+	return dst;
+}
+
+static char *reverse(const char *src)
+{
+	const char *sptr;
+	char *dst, *dptr;
+
+	if (!(dst = malloc(strlen(src) + 1)))
+		return NULL;
+
+	sptr = &src[strlen(src)];
+	dptr = dst;
+	while (sptr > src)
+		*dptr++ = *--sptr;
+	*dptr = '\0';
+
+	return dst;
+}
+
+static void clean(char *dst)
+{
+	if (dst) {
+		memset(dst, 0, strlen(dst));
+		free(dst);
+	}
+}
+
+/*
+ * Needle is based on haystack if both contain a long enough common
+ * substring and needle would be too simple for a password with the
+ * substring removed.
+ */
+static int is_based(passwdqc_params_t *params,
+    const char *haystack, const char *needle, const char *original)
+{
+	char *scratch;
+	int length;
+	int i, j;
+	const char *p;
+	int match;
+
+	if (!params->match_length)	/* disabled */
+		return 0;
+
+	if (params->match_length < 0)	/* misconfigured */
+		return 1;
+
+	if (strstr(haystack, needle))	/* based on haystack entirely */
+		return 1;
+
+	scratch = NULL;
+
+	length = strlen(needle);
+	for (i = 0; i <= length - params->match_length; i++)
+	for (j = params->match_length; i + j <= length; j++) {
+		match = 0;
+		for (p = haystack; *p; p++)
+		if (*p == needle[i] && !strncmp(p, &needle[i], j)) {
+			match = 1;
+			if (!scratch) {
+				if (!(scratch = malloc(length + 1)))
+					return 1;
+			}
+			memcpy(scratch, original, i);
+			memcpy(&scratch[i], &original[i + j],
+			    length + 1 - (i + j));
+			if (is_simple(params, scratch)) {
+				clean(scratch);
+				return 1;
+			}
+		}
+		if (!match) break;
+	}
+
+	clean(scratch);
+
+	return 0;
+}
+
+/*
+ * This wordlist check is now the least important given the checks above
+ * and the support for passphrases (which are based on dictionary words,
+ * and checked by other means). It is still useful to trap simple short
+ * passwords (if short passwords are allowed) that are word-based, but
+ * passed the other checks due to uncommon capitalization, digits, and
+ * special characters. We (mis)use the same set of words that are used
+ * to generate random passwords. This list is much smaller than those
+ * used for password crackers, and it doesn't contain common passwords
+ * that aren't short English words. Perhaps support for large wordlists
+ * should still be added, even though this is now of little importance.
+ */
+static int is_word_based(passwdqc_params_t *params,
+    const char *needle, const char *original)
+{
+	char word[7];
+	char *unified;
+	int i;
+
+	word[6] = '\0';
+	for (i = 0; i < 0x1000; i++) {
+		memcpy(word, _passwdqc_wordset_4k[i], 6);
+		if ((int)strlen(word) < params->match_length) continue;
+		unified = unify(word);
+		if (is_based(params, unified, needle, original)) {
+			clean(unified);
+			return 1;
+		}
+		clean(unified);
+	}
+
+	return 0;
+}
+
+const char *_passwdqc_check(passwdqc_params_t *params,
+    const char *newpass, const char *oldpass, struct passwd *pw)
+{
+	char truncated[9], *reversed;
+	char *u_newpass, *u_reversed;
+	char *u_oldpass;
+	char *u_name, *u_gecos;
+	const char *reason;
+	int length;
+
+	reversed = NULL;
+	u_newpass = u_reversed = NULL;
+	u_oldpass = NULL;
+	u_name = u_gecos = NULL;
+
+	reason = NULL;
+
+	if (oldpass && !strcmp(oldpass, newpass))
+		reason = REASON_SAME;
+
+	length = strlen(newpass);
+
+	if (!reason && length < params->min[4])
+		reason = REASON_SHORT;
+
+	if (!reason && length > params->max) {
+		if (params->max == 8) {
+			truncated[0] = '\0';
+			strncat(truncated, newpass, 8);
+			newpass = truncated;
+			if (oldpass && !strncmp(oldpass, newpass, 8))
+				reason = REASON_SAME;
+		} else
+			reason = REASON_LONG;
+	}
+
+	if (!reason && is_simple(params, newpass)) {
+		if (length < params->min[1] && params->min[1] <= params->max)
+			reason = REASON_SIMPLESHORT;
+		else
+			reason = REASON_SIMPLE;
+	}
+
+	if (!reason) {
+		if ((reversed = reverse(newpass))) {
+			u_newpass = unify(newpass);
+			u_reversed = unify(reversed);
+			if (oldpass)
+				u_oldpass = unify(oldpass);
+			if (pw) {
+				u_name = unify(pw->pw_name);
+				u_gecos = unify(pw->pw_gecos);
+			}
+		}
+		if (!reversed ||
+		    !u_newpass || !u_reversed ||
+		    (oldpass && !u_oldpass) ||
+		    (pw && (!u_name || !u_gecos)))
+			reason = REASON_ERROR;
+	}
+
+	if (!reason && oldpass && params->similar_deny &&
+	    (is_based(params, u_oldpass, u_newpass, newpass) ||
+	    is_based(params, u_oldpass, u_reversed, reversed)))
+		reason = REASON_SIMILAR;
+
+	if (!reason && pw &&
+	    (is_based(params, u_name, u_newpass, newpass) ||
+	    is_based(params, u_name, u_reversed, reversed) ||
+	    is_based(params, u_gecos, u_newpass, newpass) ||
+	    is_based(params, u_gecos, u_reversed, reversed)))
+		reason = REASON_PERSONAL;
+
+	if (!reason && (int)strlen(newpass) < params->min[2] &&
+	    (is_word_based(params, u_newpass, newpass) ||
+	    is_word_based(params, u_reversed, reversed)))
+		reason = REASON_WORD;
+
+	memset(truncated, 0, sizeof(truncated));
+	clean(reversed);
+	clean(u_newpass); clean(u_reversed);
+	clean(u_oldpass);
+	clean(u_name); clean(u_gecos);
+
+	return reason;
+}
--- a/modules/pam_passwdqc/passwdqc_random.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/passwdqc_random.c	1697368900.039659224
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2000-2002 by Solar Designer. See LICENSE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include "passwdqc.h"
+
+#define SEPARATORS			"_,.;:-!&"
+
+static int read_loop(int fd, char *buffer, int count)
+{
+	int offset, block;
+
+	offset = 0;
+	while (count > 0) {
+		block = read(fd, &buffer[offset], count);
+
+		if (block < 0) {
+			if (errno == EINTR) continue;
+			return block;
+		}
+		if (!block) return offset;
+
+		offset += block;
+		count -= block;
+	}
+
+	return offset;
+}
+
+char *_passwdqc_random(passwdqc_params_t *params)
+{
+	static char output[0x100];
+	int bits;
+	int use_separators, count, i;
+	unsigned int length;
+	char *start, *end;
+	int fd;
+	unsigned char bytes[2];
+
+	if (!(bits = params->random_bits))
+		return NULL;
+
+	count = 1 + ((bits - 12) + 14) / 15;
+	use_separators = ((bits + 11) / 12 != count);
+
+	length = count * 7 - 1;
+	if (length >= sizeof(output) || (int)length > params->max)
+		return NULL;
+
+	if ((fd = open("/dev/urandom", O_RDONLY)) < 0) return NULL;
+
+	length = 0;
+	do {
+		if (read_loop(fd, bytes, sizeof(bytes)) != sizeof(bytes)) {
+			close(fd);
+			return NULL;
+		}
+
+		i = (((int)bytes[1] & 0x0f) << 8) | (int)bytes[0];
+		start = _passwdqc_wordset_4k[i];
+		end = memchr(start, '\0', 6);
+		if (!end) end = start + 6;
+		if (length + (end - start) >= sizeof(output) - 1) {
+			close(fd);
+			return NULL;
+		}
+		memcpy(&output[length], start, end - start);
+		length += end - start;
+		bits -= 12;
+
+		if (use_separators && bits > 3) {
+			i = ((int)bytes[1] & 0x70) >> 4;
+			output[length++] = SEPARATORS[i];
+			bits -= 3;
+		} else
+		if (bits > 0)
+			output[length++] = ' ';
+	} while (bits > 0);
+
+	memset(bytes, 0, sizeof(bytes));
+	output[length] = '\0';
+
+	close(fd);
+
+	return output;
+}
--- a/modules/pam_passwdqc/wordset_4k.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_passwdqc/wordset_4k.c	1697368903.163412222
@@ -0,0 +1,4108 @@
+/*
+ * 4096 English words for generation of easy to memorize random passphrases.
+ * This list comes from a passphrase generator mentioned on sci.crypt, and I
+ * believe is in the public domain.
+ *
+ * I've replaced two 7-character words to save space.
+ */
+
+#include "passwdqc.h"
+
+char _passwdqc_wordset_4k[0x1000][6] = {
+	"Adam",
+	"Afghan",
+	"Alaska",
+	"Alice",
+	"Allah",
+	"Amazon",
+	"Andrew",
+	"Anglo",
+	"Angola",
+	"Antony",
+	"April",
+	"Arab",
+	"Arctic",
+	"Athens",
+	"Austin",
+	"Bach",
+	"Baltic",
+	"Basque",
+	"Berlin",
+	"Bible",
+	"Bombay",
+	"Bonn",
+	"Boston",
+	"Brazil",
+	"Briton",
+	"Buddha",
+	"Burma",
+	"Caesar",
+	"Cairo",
+	"Canada",
+	"Carl",
+	"Carol",
+	"Celtic",
+	"Chile",
+	"China",
+	"Christ",
+	"Congo",
+	"Cuba",
+	"Cyprus",
+	"Czech",
+	"Dallas",
+	"Danish",
+	"Darwin",
+	"David",
+	"Delhi",
+	"Derby",
+	"Diana",
+	"Dublin",
+	"Dutch",
+	"East",
+	"Eden",
+	"Edward",
+	"Eric",
+	"Essex",
+	"Europe",
+	"Eve",
+	"Exodus",
+	"France",
+	"French",
+	"Friday",
+	"Gandhi",
+	"Gaul",
+	"Gemini",
+	"Geneva",
+	"George",
+	"German",
+	"Gloria",
+	"God",
+	"Gothic",
+	"Greece",
+	"Greek",
+	"Hague",
+	"Haiti",
+	"Hanoi",
+	"Harry",
+	"Havana",
+	"Hawaii",
+	"Hebrew",
+	"Henry",
+	"Hermes",
+	"Hindu",
+	"Hitler",
+	"Idaho",
+	"Inca",
+	"India",
+	"Indian",
+	"Iowa",
+	"Iran",
+	"Iraq",
+	"Irish",
+	"Isaac",
+	"Isabel",
+	"Islam",
+	"Israel",
+	"Italy",
+	"Ivan",
+	"Jack",
+	"Jacob",
+	"James",
+	"Japan",
+	"Java",
+	"Jersey",
+	"Jesus",
+	"Jewish",
+	"Jim",
+	"John",
+	"Jordan",
+	"Joseph",
+	"Judas",
+	"Judy",
+	"July",
+	"June",
+	"Kansas",
+	"Karl",
+	"Kenya",
+	"Koran",
+	"Korea",
+	"Kuwait",
+	"Laos",
+	"Latin",
+	"Leo",
+	"Libya",
+	"Lima",
+	"Lisbon",
+	"Liz",
+	"London",
+	"Louvre",
+	"Lucy",
+	"Luther",
+	"Madame",
+	"Madrid",
+	"Malta",
+	"Maria",
+	"Mars",
+	"Mary",
+	"Maya",
+	"Mecca",
+	"Mexico",
+	"Miami",
+	"Mickey",
+	"Milan",
+	"Monaco",
+	"Monday",
+	"Moscow",
+	"Moses",
+	"Moslem",
+	"Mrs",
+	"Munich",
+	"Muslim",
+	"Naples",
+	"Nazi",
+	"Nepal",
+	"Newark",
+	"Nile",
+	"Nobel",
+	"North",
+	"Norway",
+	"Ohio",
+	"Oscar",
+	"Oslo",
+	"Oxford",
+	"Panama",
+	"Paris",
+	"Pascal",
+	"Paul",
+	"Peking",
+	"Peru",
+	"Peter",
+	"Philip",
+	"Poland",
+	"Polish",
+	"Prague",
+	"Quebec",
+	"Rex",
+	"Rhine",
+	"Ritz",
+	"Robert",
+	"Roman",
+	"Rome",
+	"Rosa",
+	"Russia",
+	"Sahara",
+	"Sam",
+	"Saturn",
+	"Saudi",
+	"Saxon",
+	"Scot",
+	"Seoul",
+	"Somali",
+	"Sony",
+	"Soviet",
+	"Spain",
+	"Stalin",
+	"Sudan",
+	"Suez",
+	"Sunday",
+	"Sweden",
+	"Swiss",
+	"Sydney",
+	"Syria",
+	"Taiwan",
+	"Tarzan",
+	"Taurus",
+	"Tehran",
+	"Teresa",
+	"Texas",
+	"Thomas",
+	"Tibet",
+	"Tokyo",
+	"Tom",
+	"Turk",
+	"Turkey",
+	"Uganda",
+	"Venice",
+	"Venus",
+	"Vienna",
+	"Viking",
+	"Virgo",
+	"Warsaw",
+	"West",
+	"Yale",
+	"Yemen",
+	"York",
+	"Zaire",
+	"Zurich",
+	"aback",
+	"abbey",
+	"abbot",
+	"abide",
+	"ablaze",
+	"able",
+	"aboard",
+	"abode",
+	"abort",
+	"abound",
+	"about",
+	"above",
+	"abroad",
+	"abrupt",
+	"absent",
+	"absorb",
+	"absurd",
+	"abuse",
+	"accent",
+	"accept",
+	"access",
+	"accord",
+	"accuse",
+	"ace",
+	"ache",
+	"aching",
+	"acid",
+	"acidic",
+	"acorn",
+	"acre",
+	"across",
+	"act",
+	"action",
+	"active",
+	"actor",
+	"actual",
+	"acute",
+	"adapt",
+	"add",
+	"added",
+	"addict",
+	"adept",
+	"adhere",
+	"adjust",
+	"admire",
+	"admit",
+	"adobe",
+	"adopt",
+	"adrift",
+	"adult",
+	"adverb",
+	"advert",
+	"aerial",
+	"afar",
+	"affair",
+	"affect",
+	"afford",
+	"afield",
+	"afloat",
+	"afraid",
+	"afresh",
+	"after",
+	"again",
+	"age",
+	"agency",
+	"agenda",
+	"agent",
+	"aghast",
+	"agile",
+	"ago",
+	"agony",
+	"agree",
+	"agreed",
+	"ahead",
+	"aid",
+	"aide",
+	"aim",
+	"air",
+	"airman",
+	"airy",
+	"akin",
+	"alarm",
+	"albeit",
+	"album",
+	"alert",
+	"alibi",
+	"alien",
+	"alight",
+	"align",
+	"alike",
+	"alive",
+	"alkali",
+	"all",
+	"alley",
+	"allied",
+	"allow",
+	"alloy",
+	"ally",
+	"almond",
+	"almost",
+	"aloft",
+	"alone",
+	"along",
+	"aloof",
+	"aloud",
+	"alpha",
+	"alpine",
+	"also",
+	"altar",
+	"alter",
+	"always",
+	"amaze",
+	"amber",
+	"ambush",
+	"amen",
+	"amend",
+	"amid",
+	"amidst",
+	"amiss",
+	"among",
+	"amount",
+	"ample",
+	"amuse",
+	"anchor",
+	"and",
+	"anew",
+	"angel",
+	"anger",
+	"angle",
+	"angry",
+	"animal",
+	"ankle",
+	"annoy",
+	"annual",
+	"answer",
+	"anthem",
+	"anti",
+	"any",
+	"anyhow",
+	"anyway",
+	"apart",
+	"apathy",
+	"apex",
+	"apiece",
+	"appeal",
+	"appear",
+	"apple",
+	"apply",
+	"apron",
+	"arcade",
+	"arcane",
+	"arch",
+	"ardent",
+	"are",
+	"area",
+	"argue",
+	"arid",
+	"arise",
+	"arm",
+	"armful",
+	"armpit",
+	"army",
+	"aroma",
+	"around",
+	"arouse",
+	"array",
+	"arrest",
+	"arrive",
+	"arrow",
+	"arson",
+	"art",
+	"artery",
+	"artful",
+	"artist",
+	"ascent",
+	"ashen",
+	"ashore",
+	"aside",
+	"ask",
+	"asleep",
+	"aspect",
+	"assay",
+	"assent",
+	"assert",
+	"assess",
+	"asset",
+	"assign",
+	"assist",
+	"assume",
+	"assure",
+	"asthma",
+	"astute",
+	"asylum",
+	"ate",
+	"atlas",
+	"atom",
+	"atomic",
+	"attach",
+	"attack",
+	"attain",
+	"attend",
+	"attic",
+	"auburn",
+	"audio",
+	"audit",
+	"august",
+	"aunt",
+	"auntie",
+	"aura",
+	"author",
+	"auto",
+	"autumn",
+	"avail",
+	"avenge",
+	"avenue",
+	"avert",
+	"avid",
+	"avoid",
+	"await",
+	"awake",
+	"awaken",
+	"award",
+	"aware",
+	"awash",
+	"away",
+	"awful",
+	"awhile",
+	"axes",
+	"axiom",
+	"axis",
+	"axle",
+	"aye",
+	"babe",
+	"baby",
+	"back",
+	"backup",
+	"bacon",
+	"bad",
+	"badge",
+	"badly",
+	"bag",
+	"baggy",
+	"bail",
+	"bait",
+	"bake",
+	"baker",
+	"bakery",
+	"bald",
+	"ball",
+	"ballad",
+	"ballet",
+	"ballot",
+	"bamboo",
+	"ban",
+	"banal",
+	"banana",
+	"band",
+	"bang",
+	"bank",
+	"bar",
+	"barber",
+	"bare",
+	"barely",
+	"barge",
+	"bark",
+	"barley",
+	"barn",
+	"baron",
+	"barrel",
+	"barren",
+	"basalt",
+	"base",
+	"basic",
+	"basil",
+	"basin",
+	"basis",
+	"basket",
+	"bass",
+	"bat",
+	"batch",
+	"bath",
+	"baton",
+	"battle",
+	"bay",
+	"beach",
+	"beacon",
+	"beak",
+	"beam",
+	"bean",
+	"bear",
+	"beard",
+	"beast",
+	"beat",
+	"beauty",
+	"become",
+	"bed",
+	"beech",
+	"beef",
+	"beefy",
+	"beep",
+	"beer",
+	"beet",
+	"beetle",
+	"before",
+	"beggar",
+	"begin",
+	"behalf",
+	"behave",
+	"behind",
+	"beige",
+	"being",
+	"belief",
+	"bell",
+	"belly",
+	"belong",
+	"below",
+	"belt",
+	"bench",
+	"bend",
+	"benign",
+	"bent",
+	"berry",
+	"berth",
+	"beset",
+	"beside",
+	"best",
+	"bestow",
+	"bet",
+	"beta",
+	"betray",
+	"better",
+	"beware",
+	"beyond",
+	"bias",
+	"biceps",
+	"bicker",
+	"bid",
+	"big",
+	"bigger",
+	"bike",
+	"bile",
+	"bill",
+	"binary",
+	"bind",
+	"biopsy",
+	"birch",
+	"bird",
+	"birdie",
+	"birth",
+	"bishop",
+	"bit",
+	"bitch",
+	"bite",
+	"bitter",
+	"black",
+	"blade",
+	"blame",
+	"bland",
+	"blast",
+	"blaze",
+	"bleak",
+	"blend",
+	"bless",
+	"blew",
+	"blind",
+	"blink",
+	"blip",
+	"bliss",
+	"blitz",
+	"block",
+	"blond",
+	"blood",
+	"bloody",
+	"bloom",
+	"blot",
+	"blouse",
+	"blow",
+	"blue",
+	"bluff",
+	"blunt",
+	"blur",
+	"blush",
+	"boar",
+	"board",
+	"boast",
+	"boat",
+	"bodily",
+	"body",
+	"bogus",
+	"boil",
+	"bold",
+	"bolt",
+	"bomb",
+	"bond",
+	"bone",
+	"bonnet",
+	"bonus",
+	"bony",
+	"book",
+	"boom",
+	"boost",
+	"boot",
+	"booth",
+	"booze",
+	"border",
+	"bore",
+	"borrow",
+	"bosom",
+	"boss",
+	"both",
+	"bother",
+	"bottle",
+	"bottom",
+	"bought",
+	"bounce",
+	"bound",
+	"bounty",
+	"bout",
+	"bovine",
+	"bow",
+	"bowel",
+	"bowl",
+	"box",
+	"boy",
+	"boyish",
+	"brace",
+	"brain",
+	"brainy",
+	"brake",
+	"bran",
+	"branch",
+	"brand",
+	"brandy",
+	"brass",
+	"brave",
+	"bravo",
+	"breach",
+	"bread",
+	"break",
+	"breast",
+	"breath",
+	"bred",
+	"breed",
+	"breeze",
+	"brew",
+	"brick",
+	"bride",
+	"bridge",
+	"brief",
+	"bright",
+	"brim",
+	"brine",
+	"bring",
+	"brink",
+	"brisk",
+	"broad",
+	"broke",
+	"broken",
+	"bronze",
+	"brook",
+	"broom",
+	"brown",
+	"bruise",
+	"brush",
+	"brutal",
+	"brute",
+	"bubble",
+	"buck",
+	"bucket",
+	"buckle",
+	"budget",
+	"buffet",
+	"buggy",
+	"build",
+	"bulb",
+	"bulge",
+	"bulk",
+	"bulky",
+	"bull",
+	"bullet",
+	"bully",
+	"bump",
+	"bumpy",
+	"bunch",
+	"bundle",
+	"bunk",
+	"bunny",
+	"burden",
+	"bureau",
+	"burial",
+	"buried",
+	"burly",
+	"burn",
+	"burnt",
+	"burrow",
+	"burst",
+	"bury",
+	"bus",
+	"bush",
+	"bust",
+	"bustle",
+	"busy",
+	"but",
+	"butler",
+	"butt",
+	"butter",
+	"button",
+	"buy",
+	"buyer",
+	"buzz",
+	"bye",
+	"byte",
+	"cab",
+	"cabin",
+	"cable",
+	"cache",
+	"cactus",
+	"cage",
+	"cake",
+	"calf",
+	"call",
+	"caller",
+	"calm",
+	"calmly",
+	"came",
+	"camel",
+	"camera",
+	"camp",
+	"campus",
+	"can",
+	"canal",
+	"canary",
+	"cancel",
+	"cancer",
+	"candid",
+	"candle",
+	"candy",
+	"cane",
+	"canine",
+	"canoe",
+	"canopy",
+	"canvas",
+	"canyon",
+	"cap",
+	"cape",
+	"car",
+	"carbon",
+	"card",
+	"care",
+	"career",
+	"caress",
+	"cargo",
+	"carnal",
+	"carp",
+	"carpet",
+	"carrot",
+	"carry",
+	"cart",
+	"cartel",
+	"case",
+	"cash",
+	"cask",
+	"cast",
+	"castle",
+	"casual",
+	"cat",
+	"catch",
+	"cater",
+	"cattle",
+	"caught",
+	"causal",
+	"cause",
+	"cave",
+	"cease",
+	"celery",
+	"cell",
+	"cellar",
+	"cement",
+	"censor",
+	"census",
+	"cereal",
+	"cervix",
+	"chain",
+	"chair",
+	"chalk",
+	"chalky",
+	"champ",
+	"chance",
+	"change",
+	"chant",
+	"chaos",
+	"chap",
+	"chapel",
+	"charge",
+	"charm",
+	"chart",
+	"chase",
+	"chat",
+	"cheap",
+	"cheat",
+	"check",
+	"cheek",
+	"cheeky",
+	"cheer",
+	"cheery",
+	"cheese",
+	"chef",
+	"cherry",
+	"chess",
+	"chest",
+	"chew",
+	"chic",
+	"chick",
+	"chief",
+	"child",
+	"chill",
+	"chilly",
+	"chin",
+	"chip",
+	"choice",
+	"choir",
+	"choose",
+	"chop",
+	"choppy",
+	"chord",
+	"chorus",
+	"chose",
+	"chosen",
+	"chrome",
+	"chunk",
+	"chunky",
+	"church",
+	"cider",
+	"cigar",
+	"cinema",
+	"circa",
+	"circle",
+	"circus",
+	"cite",
+	"city",
+	"civic",
+	"civil",
+	"clad",
+	"claim",
+	"clammy",
+	"clan",
+	"clap",
+	"clash",
+	"clasp",
+	"class",
+	"clause",
+	"claw",
+	"clay",
+	"clean",
+	"clear",
+	"clergy",
+	"clerk",
+	"clever",
+	"click",
+	"client",
+	"cliff",
+	"climax",
+	"climb",
+	"clinch",
+	"cling",
+	"clinic",
+	"clip",
+	"cloak",
+	"clock",
+	"clone",
+	"close",
+	"closer",
+	"closet",
+	"cloth",
+	"cloud",
+	"cloudy",
+	"clout",
+	"clown",
+	"club",
+	"clue",
+	"clumsy",
+	"clung",
+	"clutch",
+	"coach",
+	"coal",
+	"coarse",
+	"coast",
+	"coat",
+	"coax",
+	"cobalt",
+	"cobra",
+	"coca",
+	"cock",
+	"cocoa",
+	"code",
+	"coffee",
+	"coffin",
+	"cohort",
+	"coil",
+	"coin",
+	"coke",
+	"cold",
+	"collar",
+	"colon",
+	"colony",
+	"colt",
+	"column",
+	"comb",
+	"combat",
+	"come",
+	"comedy",
+	"comic",
+	"commit",
+	"common",
+	"compel",
+	"comply",
+	"concur",
+	"cone",
+	"confer",
+	"consul",
+	"convex",
+	"convey",
+	"convoy",
+	"cook",
+	"cool",
+	"cope",
+	"copper",
+	"copy",
+	"coral",
+	"cord",
+	"core",
+	"cork",
+	"corn",
+	"corner",
+	"corps",
+	"corpse",
+	"corpus",
+	"cortex",
+	"cosmic",
+	"cosmos",
+	"cost",
+	"costly",
+	"cosy",
+	"cotton",
+	"couch",
+	"cough",
+	"could",
+	"count",
+	"county",
+	"coup",
+	"couple",
+	"coupon",
+	"course",
+	"court",
+	"cousin",
+	"cove",
+	"cover",
+	"covert",
+	"cow",
+	"coward",
+	"cowboy",
+	"crab",
+	"crack",
+	"cradle",
+	"craft",
+	"crafty",
+	"crag",
+	"crane",
+	"crap",
+	"crash",
+	"crate",
+	"crater",
+	"crawl",
+	"crazy",
+	"creak",
+	"cream",
+	"creamy",
+	"create",
+	"credit",
+	"creed",
+	"creek",
+	"creep",
+	"creepy",
+	"crept",
+	"crest",
+	"crew",
+	"cried",
+	"crime",
+	"crisis",
+	"crisp",
+	"critic",
+	"croft",
+	"crook",
+	"crop",
+	"cross",
+	"crow",
+	"crowd",
+	"crown",
+	"crude",
+	"cruel",
+	"cruise",
+	"crunch",
+	"crush",
+	"crust",
+	"crux",
+	"cry",
+	"crypt",
+	"cube",
+	"cubic",
+	"cuckoo",
+	"cuff",
+	"cult",
+	"cup",
+	"curb",
+	"cure",
+	"curfew",
+	"curl",
+	"curry",
+	"curse",
+	"cursor",
+	"curve",
+	"custom",
+	"cut",
+	"cute",
+	"cycle",
+	"cyclic",
+	"cynic",
+	"dad",
+	"daddy",
+	"dagger",
+	"daily",
+	"dairy",
+	"daisy",
+	"dale",
+	"damage",
+	"damn",
+	"damp",
+	"dampen",
+	"dance",
+	"danger",
+	"dare",
+	"dark",
+	"darken",
+	"dash",
+	"data",
+	"date",
+	"dawn",
+	"day",
+	"dead",
+	"deadly",
+	"deaf",
+	"deal",
+	"dealer",
+	"dean",
+	"dear",
+	"death",
+	"debate",
+	"debit",
+	"debris",
+	"debt",
+	"debtor",
+	"decade",
+	"decay",
+	"decent",
+	"decide",
+	"deck",
+	"decor",
+	"decree",
+	"deduce",
+	"deed",
+	"deep",
+	"deeply",
+	"deer",
+	"defeat",
+	"defect",
+	"defend",
+	"defer",
+	"define",
+	"defy",
+	"degree",
+	"deity",
+	"delay",
+	"delete",
+	"delta",
+	"demand",
+	"demise",
+	"demo",
+	"demon",
+	"demure",
+	"denial",
+	"denote",
+	"dense",
+	"dental",
+	"deny",
+	"depart",
+	"depend",
+	"depict",
+	"deploy",
+	"depot",
+	"depth",
+	"deputy",
+	"derive",
+	"desert",
+	"design",
+	"desire",
+	"desist",
+	"desk",
+	"detail",
+	"detect",
+	"deter",
+	"detest",
+	"detour",
+	"device",
+	"devil",
+	"devise",
+	"devoid",
+	"devote",
+	"devour",
+	"dial",
+	"diary",
+	"dice",
+	"dictum",
+	"did",
+	"die",
+	"diesel",
+	"diet",
+	"differ",
+	"digest",
+	"digit",
+	"dine",
+	"dinghy",
+	"dinner",
+	"diode",
+	"dire",
+	"direct",
+	"dirt",
+	"dirty",
+	"disc",
+	"disco",
+	"dish",
+	"disk",
+	"dismal",
+	"dispel",
+	"ditch",
+	"dive",
+	"divert",
+	"divide",
+	"divine",
+	"dizzy",
+	"docile",
+	"dock",
+	"doctor",
+	"dog",
+	"dogma",
+	"dole",
+	"doll",
+	"dollar",
+	"dolly",
+	"domain",
+	"dome",
+	"domino",
+	"donate",
+	"done",
+	"donkey",
+	"donor",
+	"doom",
+	"door",
+	"dorsal",
+	"dose",
+	"double",
+	"doubt",
+	"dough",
+	"dour",
+	"dove",
+	"down",
+	"dozen",
+	"draft",
+	"drag",
+	"dragon",
+	"drain",
+	"drama",
+	"drank",
+	"draw",
+	"drawer",
+	"dread",
+	"dream",
+	"dreary",
+	"dress",
+	"drew",
+	"dried",
+	"drift",
+	"drill",
+	"drink",
+	"drip",
+	"drive",
+	"driver",
+	"drop",
+	"drove",
+	"drown",
+	"drug",
+	"drum",
+	"drunk",
+	"dry",
+	"dual",
+	"duck",
+	"duct",
+	"due",
+	"duel",
+	"duet",
+	"duke",
+	"dull",
+	"duly",
+	"dumb",
+	"dummy",
+	"dump",
+	"dune",
+	"dung",
+	"duress",
+	"during",
+	"dusk",
+	"dust",
+	"dusty",
+	"duty",
+	"dwarf",
+	"dwell",
+	"dyer",
+	"dying",
+	"dynamo",
+	"each",
+	"eager",
+	"eagle",
+	"ear",
+	"earl",
+	"early",
+	"earn",
+	"earth",
+	"ease",
+	"easel",
+	"easily",
+	"easter",
+	"easy",
+	"eat",
+	"eaten",
+	"eater",
+	"echo",
+	"eddy",
+	"edge",
+	"edible",
+	"edict",
+	"edit",
+	"editor",
+	"eerie",
+	"eerily",
+	"effect",
+	"effort",
+	"egg",
+	"ego",
+	"eight",
+	"eighth",
+	"eighty",
+	"either",
+	"elbow",
+	"elder",
+	"eldest",
+	"elect",
+	"eleven",
+	"elicit",
+	"elite",
+	"else",
+	"elude",
+	"elves",
+	"embark",
+	"emblem",
+	"embryo",
+	"emerge",
+	"emit",
+	"empire",
+	"employ",
+	"empty",
+	"enable",
+	"enamel",
+	"end",
+	"endure",
+	"enemy",
+	"energy",
+	"engage",
+	"engine",
+	"enjoy",
+	"enlist",
+	"enough",
+	"ensure",
+	"entail",
+	"enter",
+	"entire",
+	"entry",
+	"envoy",
+	"envy",
+	"enzyme",
+	"epic",
+	"epoch",
+	"equal",
+	"equate",
+	"equip",
+	"equity",
+	"era",
+	"erase",
+	"erect",
+	"erode",
+	"erotic",
+	"errant",
+	"error",
+	"escape",
+	"escort",
+	"essay",
+	"estate",
+	"esteem",
+	"ethic",
+	"ethnic",
+	"evade",
+	"even",
+	"event",
+	"ever",
+	"every",
+	"evict",
+	"evil",
+	"evoke",
+	"evolve",
+	"exact",
+	"exam",
+	"exceed",
+	"excel",
+	"except",
+	"excess",
+	"excise",
+	"excite",
+	"excuse",
+	"exempt",
+	"exert",
+	"exile",
+	"exist",
+	"exit",
+	"exotic",
+	"expand",
+	"expect",
+	"expert",
+	"expire",
+	"export",
+	"expose",
+	"extend",
+	"extra",
+	"eye",
+	"eyed",
+	"fabric",
+	"face",
+	"facial",
+	"fact",
+	"factor",
+	"fade",
+	"fail",
+	"faint",
+	"fair",
+	"fairly",
+	"fairy",
+	"faith",
+	"fake",
+	"falcon",
+	"fall",
+	"false",
+	"falter",
+	"fame",
+	"family",
+	"famine",
+	"famous",
+	"fan",
+	"fancy",
+	"far",
+	"farce",
+	"fare",
+	"farm",
+	"farmer",
+	"fast",
+	"fasten",
+	"faster",
+	"fat",
+	"fatal",
+	"fate",
+	"father",
+	"fatty",
+	"fault",
+	"faulty",
+	"fauna",
+	"fear",
+	"feast",
+	"feat",
+	"fed",
+	"fee",
+	"feeble",
+	"feed",
+	"feel",
+	"feet",
+	"fell",
+	"fellow",
+	"felt",
+	"female",
+	"fence",
+	"fend",
+	"ferry",
+	"fetal",
+	"fetch",
+	"feudal",
+	"fever",
+	"few",
+	"fewer",
+	"fiance",
+	"fiasco",
+	"fiddle",
+	"field",
+	"fiend",
+	"fierce",
+	"fiery",
+	"fifth",
+	"fifty",
+	"fig",
+	"fight",
+	"figure",
+	"file",
+	"fill",
+	"filled",
+	"filler",
+	"film",
+	"filter",
+	"filth",
+	"filthy",
+	"final",
+	"finale",
+	"find",
+	"fine",
+	"finger",
+	"finish",
+	"finite",
+	"fire",
+	"firm",
+	"firmly",
+	"first",
+	"fiscal",
+	"fish",
+	"fisher",
+	"fist",
+	"fit",
+	"fitful",
+	"five",
+	"fix",
+	"flag",
+	"flair",
+	"flak",
+	"flame",
+	"flank",
+	"flap",
+	"flare",
+	"flash",
+	"flask",
+	"flat",
+	"flaw",
+	"fled",
+	"flee",
+	"fleece",
+	"fleet",
+	"flesh",
+	"fleshy",
+	"flew",
+	"flick",
+	"flight",
+	"flimsy",
+	"flint",
+	"flirt",
+	"float",
+	"flock",
+	"flood",
+	"floor",
+	"floppy",
+	"flora",
+	"floral",
+	"flour",
+	"flow",
+	"flower",
+	"fluent",
+	"fluffy",
+	"fluid",
+	"flung",
+	"flurry",
+	"flush",
+	"flute",
+	"flux",
+	"fly",
+	"flyer",
+	"foal",
+	"foam",
+	"focal",
+	"focus",
+	"fog",
+	"foil",
+	"fold",
+	"folk",
+	"follow",
+	"folly",
+	"fond",
+	"fondly",
+	"font",
+	"food",
+	"fool",
+	"foot",
+	"for",
+	"forbid",
+	"force",
+	"ford",
+	"forest",
+	"forge",
+	"forget",
+	"fork",
+	"form",
+	"formal",
+	"format",
+	"former",
+	"fort",
+	"forth",
+	"forty",
+	"forum",
+	"fossil",
+	"foster",
+	"foul",
+	"found",
+	"four",
+	"fourth",
+	"fox",
+	"foyer",
+	"frail",
+	"frame",
+	"franc",
+	"frank",
+	"fraud",
+	"free",
+	"freed",
+	"freely",
+	"freer",
+	"freeze",
+	"frenzy",
+	"fresh",
+	"friar",
+	"fridge",
+	"fried",
+	"friend",
+	"fright",
+	"fringe",
+	"frock",
+	"frog",
+	"from",
+	"front",
+	"frost",
+	"frosty",
+	"frown",
+	"frozen",
+	"frugal",
+	"fruit",
+	"fudge",
+	"fuel",
+	"fulfil",
+	"full",
+	"fully",
+	"fun",
+	"fund",
+	"funny",
+	"fur",
+	"furry",
+	"fury",
+	"fuse",
+	"fusion",
+	"fuss",
+	"fussy",
+	"futile",
+	"future",
+	"fuzzy",
+	"gadget",
+	"gag",
+	"gain",
+	"gala",
+	"galaxy",
+	"gale",
+	"gall",
+	"galley",
+	"gallon",
+	"gallop",
+	"gamble",
+	"game",
+	"gamma",
+	"gang",
+	"gap",
+	"garage",
+	"garden",
+	"garlic",
+	"gas",
+	"gasp",
+	"gate",
+	"gather",
+	"gauge",
+	"gaunt",
+	"gave",
+	"gay",
+	"gaze",
+	"gear",
+	"geese",
+	"gender",
+	"gene",
+	"genial",
+	"genius",
+	"genre",
+	"gentle",
+	"gently",
+	"gentry",
+	"genus",
+	"get",
+	"ghetto",
+	"ghost",
+	"giant",
+	"gift",
+	"giggle",
+	"gill",
+	"gilt",
+	"ginger",
+	"girl",
+	"give",
+	"given",
+	"glad",
+	"glade",
+	"glance",
+	"gland",
+	"glare",
+	"glass",
+	"glassy",
+	"gleam",
+	"glee",
+	"glide",
+	"global",
+	"globe",
+	"gloom",
+	"gloomy",
+	"glory",
+	"gloss",
+	"glossy",
+	"glove",
+	"glow",
+	"glue",
+	"goal",
+	"goat",
+	"gold",
+	"golden",
+	"golf",
+	"gone",
+	"gong",
+	"good",
+	"goose",
+	"gorge",
+	"gory",
+	"gosh",
+	"gospel",
+	"gossip",
+	"got",
+	"govern",
+	"gown",
+	"grab",
+	"grace",
+	"grade",
+	"grain",
+	"grand",
+	"grant",
+	"grape",
+	"graph",
+	"grasp",
+	"grass",
+	"grassy",
+	"grate",
+	"grave",
+	"gravel",
+	"gravy",
+	"gray",
+	"grease",
+	"greasy",
+	"great",
+	"greed",
+	"greedy",
+	"green",
+	"greet",
+	"grew",
+	"grey",
+	"grid",
+	"grief",
+	"grill",
+	"grim",
+	"grin",
+	"grind",
+	"grip",
+	"grit",
+	"gritty",
+	"groan",
+	"groin",
+	"groom",
+	"groove",
+	"gross",
+	"ground",
+	"group",
+	"grove",
+	"grow",
+	"grown",
+	"growth",
+	"grudge",
+	"grunt",
+	"guard",
+	"guess",
+	"guest",
+	"guide",
+	"guild",
+	"guilt",
+	"guilty",
+	"guise",
+	"guitar",
+	"gulf",
+	"gully",
+	"gun",
+	"gunman",
+	"guru",
+	"gut",
+	"guy",
+	"gypsy",
+	"habit",
+	"hack",
+	"had",
+	"hail",
+	"hair",
+	"hairy",
+	"hale",
+	"half",
+	"hall",
+	"halt",
+	"hamlet",
+	"hammer",
+	"hand",
+	"handle",
+	"handy",
+	"hang",
+	"hangar",
+	"happen",
+	"happy",
+	"harass",
+	"hard",
+	"harder",
+	"hardly",
+	"hare",
+	"harem",
+	"harm",
+	"harp",
+	"harsh",
+	"has",
+	"hash",
+	"hassle",
+	"haste",
+	"hasten",
+	"hasty",
+	"hat",
+	"hatch",
+	"hate",
+	"haul",
+	"haunt",
+	"have",
+	"haven",
+	"havoc",
+	"hawk",
+	"hazard",
+	"haze",
+	"hazel",
+	"hazy",
+	"head",
+	"heal",
+	"health",
+	"heap",
+	"hear",
+	"heard",
+	"heart",
+	"hearth",
+	"hearty",
+	"heat",
+	"heater",
+	"heaven",
+	"heavy",
+	"heck",
+	"hectic",
+	"hedge",
+	"heel",
+	"hefty",
+	"height",
+	"heir",
+	"held",
+	"helium",
+	"helix",
+	"hell",
+	"hello",
+	"helm",
+	"helmet",
+	"help",
+	"hemp",
+	"hence",
+	"her",
+	"herald",
+	"herb",
+	"herd",
+	"here",
+	"hereby",
+	"hernia",
+	"hero",
+	"heroic",
+	"heroin",
+	"hey",
+	"heyday",
+	"hick",
+	"hidden",
+	"hide",
+	"high",
+	"higher",
+	"highly",
+	"hill",
+	"him",
+	"hind",
+	"hint",
+	"hippy",
+	"hire",
+	"his",
+	"hiss",
+	"hit",
+	"hive",
+	"hoard",
+	"hoarse",
+	"hobby",
+	"hockey",
+	"hold",
+	"holder",
+	"hole",
+	"hollow",
+	"holly",
+	"holy",
+	"home",
+	"honest",
+	"honey",
+	"hood",
+	"hook",
+	"hope",
+	"horn",
+	"horny",
+	"horrid",
+	"horror",
+	"horse",
+	"hose",
+	"host",
+	"hot",
+	"hotel",
+	"hound",
+	"hour",
+	"house",
+	"hover",
+	"how",
+	"huge",
+	"hull",
+	"human",
+	"humane",
+	"humble",
+	"humid",
+	"hung",
+	"hunger",
+	"hungry",
+	"hunt",
+	"hurdle",
+	"hurl",
+	"hurry",
+	"hurt",
+	"hush",
+	"hut",
+	"hybrid",
+	"hymn",
+	"hyphen",
+	"ice",
+	"icing",
+	"icon",
+	"idea",
+	"ideal",
+	"idiom",
+	"idiot",
+	"idle",
+	"idly",
+	"idol",
+	"ignite",
+	"ignore",
+	"ill",
+	"image",
+	"immune",
+	"impact",
+	"imply",
+	"import",
+	"impose",
+	"incest",
+	"inch",
+	"income",
+	"incur",
+	"indeed",
+	"index",
+	"indoor",
+	"induce",
+	"inept",
+	"inert",
+	"infant",
+	"infect",
+	"infer",
+	"influx",
+	"inform",
+	"inject",
+	"injure",
+	"injury",
+	"inlaid",
+	"inland",
+	"inlet",
+	"inmate",
+	"inn",
+	"innate",
+	"inner",
+	"input",
+	"insane",
+	"insect",
+	"insert",
+	"inset",
+	"inside",
+	"insist",
+	"insult",
+	"insure",
+	"intact",
+	"intake",
+	"intend",
+	"inter",
+	"into",
+	"invade",
+	"invent",
+	"invest",
+	"invite",
+	"invoke",
+	"inward",
+	"iron",
+	"ironic",
+	"irony",
+	"island",
+	"isle",
+	"issue",
+	"itch",
+	"item",
+	"itself",
+	"ivory",
+	"jacket",
+	"jade",
+	"jaguar",
+	"jail",
+	"jargon",
+	"jaw",
+	"jazz",
+	"jeep",
+	"jelly",
+	"jerky",
+	"jest",
+	"jet",
+	"jewel",
+	"job",
+	"jock",
+	"jockey",
+	"join",
+	"joint",
+	"joke",
+	"jolly",
+	"jolt",
+	"joy",
+	"joyful",
+	"joyous",
+	"judge",
+	"juice",
+	"juicy",
+	"jumble",
+	"jumbo",
+	"jump",
+	"jungle",
+	"junior",
+	"junk",
+	"junta",
+	"jury",
+	"just",
+	"karate",
+	"keel",
+	"keen",
+	"keep",
+	"keeper",
+	"kept",
+	"kernel",
+	"kettle",
+	"key",
+	"khaki",
+	"kick",
+	"kid",
+	"kidnap",
+	"kidney",
+	"kill",
+	"killer",
+	"kin",
+	"kind",
+	"kindly",
+	"king",
+	"kiss",
+	"kite",
+	"kitten",
+	"knack",
+	"knee",
+	"knew",
+	"knife",
+	"knight",
+	"knit",
+	"knob",
+	"knock",
+	"knot",
+	"know",
+	"known",
+	"label",
+	"lace",
+	"lack",
+	"lad",
+	"ladder",
+	"laden",
+	"lady",
+	"lagoon",
+	"laity",
+	"lake",
+	"lamb",
+	"lame",
+	"lamp",
+	"lance",
+	"land",
+	"lane",
+	"lap",
+	"lapse",
+	"large",
+	"larval",
+	"laser",
+	"last",
+	"latch",
+	"late",
+	"lately",
+	"latent",
+	"later",
+	"latest",
+	"latter",
+	"laugh",
+	"launch",
+	"lava",
+	"lavish",
+	"law",
+	"lawful",
+	"lawn",
+	"lawyer",
+	"lay",
+	"layer",
+	"layman",
+	"lazy",
+	"lead",
+	"leader",
+	"leaf",
+	"leafy",
+	"league",
+	"leak",
+	"leaky",
+	"lean",
+	"leap",
+	"learn",
+	"lease",
+	"leash",
+	"least",
+	"leave",
+	"led",
+	"ledge",
+	"left",
+	"leg",
+	"legacy",
+	"legal",
+	"legend",
+	"legion",
+	"lemon",
+	"lend",
+	"length",
+	"lens",
+	"lent",
+	"leper",
+	"lesion",
+	"less",
+	"lessen",
+	"lesser",
+	"lesson",
+	"lest",
+	"let",
+	"lethal",
+	"letter",
+	"level",
+	"lever",
+	"levy",
+	"lewis",
+	"liable",
+	"liar",
+	"libel",
+	"lice",
+	"lick",
+	"lid",
+	"lie",
+	"lied",
+	"life",
+	"lift",
+	"light",
+	"like",
+	"likely",
+	"limb",
+	"lime",
+	"limit",
+	"limp",
+	"line",
+	"linear",
+	"linen",
+	"linger",
+	"link",
+	"lion",
+	"lip",
+	"liquid",
+	"liquor",
+	"list",
+	"listen",
+	"lit",
+	"live",
+	"lively",
+	"liver",
+	"lizard",
+	"load",
+	"loaf",
+	"loan",
+	"lobby",
+	"lobe",
+	"local",
+	"locate",
+	"lock",
+	"locus",
+	"lodge",
+	"loft",
+	"lofty",
+	"log",
+	"logic",
+	"logo",
+	"lone",
+	"lonely",
+	"long",
+	"longer",
+	"look",
+	"loop",
+	"loose",
+	"loosen",
+	"loot",
+	"lord",
+	"lorry",
+	"lose",
+	"loss",
+	"lost",
+	"lot",
+	"lotion",
+	"lotus",
+	"loud",
+	"loudly",
+	"lounge",
+	"lousy",
+	"love",
+	"lovely",
+	"lover",
+	"low",
+	"lower",
+	"lowest",
+	"loyal",
+	"lucid",
+	"luck",
+	"lucky",
+	"lull",
+	"lump",
+	"lumpy",
+	"lunacy",
+	"lunar",
+	"lunch",
+	"lung",
+	"lure",
+	"lurid",
+	"lush",
+	"lust",
+	"lute",
+	"luxury",
+	"lying",
+	"lymph",
+	"lynch",
+	"lyric",
+	"macho",
+	"macro",
+	"mad",
+	"madam",
+	"made",
+	"mafia",
+	"magic",
+	"magma",
+	"magnet",
+	"magnum",
+	"maid",
+	"maiden",
+	"mail",
+	"main",
+	"mainly",
+	"major",
+	"make",
+	"maker",
+	"male",
+	"malice",
+	"mall",
+	"malt",
+	"mammal",
+	"manage",
+	"mane",
+	"mania",
+	"manic",
+	"manner",
+	"manor",
+	"mantle",
+	"manual",
+	"manure",
+	"many",
+	"map",
+	"maple",
+	"marble",
+	"march",
+	"mare",
+	"margin",
+	"marina",
+	"mark",
+	"market",
+	"marry",
+	"marsh",
+	"martin",
+	"martyr",
+	"mask",
+	"mason",
+	"mass",
+	"mast",
+	"master",
+	"match",
+	"mate",
+	"matrix",
+	"matter",
+	"mature",
+	"maxim",
+	"may",
+	"maybe",
+	"mayor",
+	"maze",
+	"mead",
+	"meadow",
+	"meal",
+	"mean",
+	"meant",
+	"meat",
+	"medal",
+	"media",
+	"median",
+	"medic",
+	"medium",
+	"meet",
+	"mellow",
+	"melody",
+	"melon",
+	"melt",
+	"member",
+	"memo",
+	"memory",
+	"menace",
+	"mend",
+	"mental",
+	"mentor",
+	"menu",
+	"mercy",
+	"mere",
+	"merely",
+	"merge",
+	"merger",
+	"merit",
+	"merry",
+	"mesh",
+	"mess",
+	"messy",
+	"met",
+	"metal",
+	"meter",
+	"method",
+	"methyl",
+	"metric",
+	"metro",
+	"mid",
+	"midday",
+	"middle",
+	"midst",
+	"midway",
+	"might",
+	"mighty",
+	"mild",
+	"mildew",
+	"mile",
+	"milk",
+	"milky",
+	"mill",
+	"mimic",
+	"mince",
+	"mind",
+	"mine",
+	"mini",
+	"mink",
+	"minor",
+	"mint",
+	"minus",
+	"minute",
+	"mirror",
+	"mirth",
+	"misery",
+	"miss",
+	"mist",
+	"misty",
+	"mite",
+	"mix",
+	"moan",
+	"moat",
+	"mobile",
+	"mock",
+	"mode",
+	"model",
+	"modem",
+	"modern",
+	"modest",
+	"modify",
+	"module",
+	"moist",
+	"molar",
+	"mole",
+	"molten",
+	"moment",
+	"money",
+	"monies",
+	"monk",
+	"monkey",
+	"month",
+	"mood",
+	"moody",
+	"moon",
+	"moor",
+	"moral",
+	"morale",
+	"morbid",
+	"more",
+	"morgue",
+	"mortal",
+	"mortar",
+	"mosaic",
+	"mosque",
+	"moss",
+	"most",
+	"mostly",
+	"moth",
+	"mother",
+	"motion",
+	"motive",
+	"motor",
+	"mould",
+	"mount",
+	"mourn",
+	"mouse",
+	"mouth",
+	"move",
+	"movie",
+	"much",
+	"muck",
+	"mucus",
+	"mud",
+	"muddle",
+	"muddy",
+	"mule",
+	"mummy",
+	"murder",
+	"murky",
+	"murmur",
+	"muscle",
+	"museum",
+	"music",
+	"mussel",
+	"must",
+	"mutant",
+	"mute",
+	"mutiny",
+	"mutter",
+	"mutton",
+	"mutual",
+	"muzzle",
+	"myopic",
+	"myriad",
+	"myself",
+	"mystic",
+	"myth",
+	"nadir",
+	"nail",
+	"naked",
+	"name",
+	"namely",
+	"nape",
+	"napkin",
+	"narrow",
+	"nasal",
+	"nasty",
+	"nation",
+	"native",
+	"nature",
+	"nausea",
+	"naval",
+	"nave",
+	"navy",
+	"near",
+	"nearer",
+	"nearly",
+	"neat",
+	"neatly",
+	"neck",
+	"need",
+	"needle",
+	"needy",
+	"negate",
+	"neon",
+	"nephew",
+	"nerve",
+	"nest",
+	"neural",
+	"never",
+	"newly",
+	"next",
+	"nice",
+	"nicely",
+	"niche",
+	"nickel",
+	"niece",
+	"night",
+	"nimble",
+	"nine",
+	"ninety",
+	"ninth",
+	"noble",
+	"nobody",
+	"node",
+	"noise",
+	"noisy",
+	"non",
+	"none",
+	"noon",
+	"nor",
+	"norm",
+	"normal",
+	"nose",
+	"nosy",
+	"not",
+	"note",
+	"notice",
+	"notify",
+	"notion",
+	"nought",
+	"noun",
+	"novel",
+	"novice",
+	"now",
+	"nozzle",
+	"nude",
+	"null",
+	"numb",
+	"number",
+	"nurse",
+	"nylon",
+	"nymph",
+	"oak",
+	"oasis",
+	"oath",
+	"obese",
+	"obey",
+	"object",
+	"oblige",
+	"oboe",
+	"obtain",
+	"occult",
+	"occupy",
+	"occur",
+	"ocean",
+	"octave",
+	"odd",
+	"off",
+	"offend",
+	"offer",
+	"office",
+	"offset",
+	"often",
+	"oil",
+	"oily",
+	"okay",
+	"old",
+	"older",
+	"oldest",
+	"olive",
+	"omega",
+	"omen",
+	"omit",
+	"once",
+	"one",
+	"onion",
+	"only",
+	"onset",
+	"onto",
+	"onus",
+	"onward",
+	"opaque",
+	"open",
+	"openly",
+	"opera",
+	"opium",
+	"oppose",
+	"optic",
+	"option",
+	"oracle",
+	"oral",
+	"orange",
+	"orbit",
+	"orchid",
+	"ordeal",
+	"order",
+	"organ",
+	"orgasm",
+	"orient",
+	"origin",
+	"ornate",
+	"orphan",
+	"other",
+	"otter",
+	"ought",
+	"ounce",
+	"our",
+	"out",
+	"outer",
+	"output",
+	"outset",
+	"oval",
+	"oven",
+	"over",
+	"overt",
+	"owe",
+	"owing",
+	"owl",
+	"own",
+	"owner",
+	"oxide",
+	"oxygen",
+	"oyster",
+	"ozone",
+	"pace",
+	"pack",
+	"packet",
+	"pact",
+	"paddle",
+	"paddy",
+	"pagan",
+	"page",
+	"paid",
+	"pain",
+	"paint",
+	"pair",
+	"palace",
+	"pale",
+	"palm",
+	"panel",
+	"panic",
+	"papa",
+	"papal",
+	"paper",
+	"parade",
+	"parcel",
+	"pardon",
+	"parent",
+	"parish",
+	"park",
+	"parody",
+	"parrot",
+	"part",
+	"partly",
+	"party",
+	"pass",
+	"past",
+	"paste",
+	"pastel",
+	"pastor",
+	"pastry",
+	"pat",
+	"patch",
+	"patent",
+	"path",
+	"patio",
+	"patrol",
+	"patron",
+	"pause",
+	"pave",
+	"pawn",
+	"pay",
+	"peace",
+	"peach",
+	"peak",
+	"pear",
+	"pearl",
+	"pedal",
+	"peel",
+	"peer",
+	"pelvic",
+	"pelvis",
+	"pen",
+	"penal",
+	"pence",
+	"pencil",
+	"penis",
+	"penny",
+	"people",
+	"pepper",
+	"per",
+	"perch",
+	"peril",
+	"period",
+	"perish",
+	"permit",
+	"person",
+	"pest",
+	"petite",
+	"petrol",
+	"petty",
+	"phase",
+	"phone",
+	"photo",
+	"phrase",
+	"piano",
+	"pick",
+	"picket",
+	"picnic",
+	"pie",
+	"piece",
+	"pier",
+	"pierce",
+	"piety",
+	"pig",
+	"pigeon",
+	"piggy",
+	"pike",
+	"pile",
+	"pill",
+	"pillar",
+	"pillow",
+	"pilot",
+	"pin",
+	"pinch",
+	"pine",
+	"pink",
+	"pint",
+	"pious",
+	"pipe",
+	"pirate",
+	"piss",
+	"pistol",
+	"piston",
+	"pit",
+	"pitch",
+	"pity",
+	"pivot",
+	"pixel",
+	"pizza",
+	"place",
+	"placid",
+	"plague",
+	"plain",
+	"plan",
+	"plane",
+	"planet",
+	"plank",
+	"plant",
+	"plasma",
+	"plate",
+	"play",
+	"player",
+	"plea",
+	"plead",
+	"please",
+	"pledge",
+	"plenty",
+	"plenum",
+	"plight",
+	"plot",
+	"ploy",
+	"plug",
+	"plum",
+	"plump",
+	"plunge",
+	"plural",
+	"plus",
+	"plush",
+	"pocket",
+	"poem",
+	"poet",
+	"poetic",
+	"poetry",
+	"point",
+	"poison",
+	"polar",
+	"pole",
+	"police",
+	"policy",
+	"polite",
+	"poll",
+	"pollen",
+	"polo",
+	"pond",
+	"ponder",
+	"pony",
+	"pool",
+	"poor",
+	"poorly",
+	"pop",
+	"pope",
+	"poppy",
+	"pore",
+	"pork",
+	"port",
+	"portal",
+	"pose",
+	"posh",
+	"post",
+	"postal",
+	"pot",
+	"potato",
+	"potent",
+	"pouch",
+	"pound",
+	"pour",
+	"powder",
+	"power",
+	"praise",
+	"pray",
+	"prayer",
+	"preach",
+	"prefer",
+	"prefix",
+	"press",
+	"pretty",
+	"price",
+	"pride",
+	"priest",
+	"primal",
+	"prime",
+	"prince",
+	"print",
+	"prior",
+	"prism",
+	"prison",
+	"privy",
+	"prize",
+	"probe",
+	"profit",
+	"prompt",
+	"prone",
+	"proof",
+	"propel",
+	"proper",
+	"prose",
+	"proton",
+	"proud",
+	"prove",
+	"proven",
+	"proxy",
+	"prune",
+	"psalm",
+	"pseudo",
+	"psyche",
+	"pub",
+	"public",
+	"puff",
+	"pull",
+	"pulp",
+	"pulpit",
+	"pulsar",
+	"pulse",
+	"pump",
+	"punch",
+	"punish",
+	"punk",
+	"pupil",
+	"puppet",
+	"puppy",
+	"pure",
+	"purely",
+	"purge",
+	"purify",
+	"purple",
+	"purse",
+	"pursue",
+	"push",
+	"pushy",
+	"pussy",
+	"put",
+	"putt",
+	"puzzle",
+	"quaint",
+	"quake",
+	"quarry",
+	"quartz",
+	"quay",
+	"queen",
+	"queer",
+	"query",
+	"quest",
+	"queue",
+	"quick",
+	"quid",
+	"quiet",
+	"quilt",
+	"quirk",
+	"quit",
+	"quite",
+	"quiver",
+	"quiz",
+	"quota",
+	"quote",
+	"rabbit",
+	"race",
+	"racial",
+	"racism",
+	"rack",
+	"racket",
+	"radar",
+	"radio",
+	"radish",
+	"radius",
+	"raffle",
+	"raft",
+	"rage",
+	"raid",
+	"rail",
+	"rain",
+	"rainy",
+	"raise",
+	"rally",
+	"ramp",
+	"random",
+	"range",
+	"rank",
+	"ransom",
+	"rape",
+	"rapid",
+	"rare",
+	"rarely",
+	"rarity",
+	"rash",
+	"rat",
+	"rate",
+	"rather",
+	"ratify",
+	"ratio",
+	"rattle",
+	"rave",
+	"raven",
+	"raw",
+	"ray",
+	"razor",
+	"reach",
+	"react",
+	"read",
+	"reader",
+	"ready",
+	"real",
+	"really",
+	"realm",
+	"reap",
+	"rear",
+	"reason",
+	"rebel",
+	"recall",
+	"recent",
+	"recess",
+	"recipe",
+	"reckon",
+	"record",
+	"recoup",
+	"rector",
+	"red",
+	"redeem",
+	"reduce",
+	"reed",
+	"reef",
+	"refer",
+	"reform",
+	"refuge",
+	"refuse",
+	"regal",
+	"regard",
+	"regent",
+	"regime",
+	"region",
+	"regret",
+	"reign",
+	"reject",
+	"relate",
+	"relax",
+	"relay",
+	"relic",
+	"relief",
+	"relish",
+	"rely",
+	"remain",
+	"remark",
+	"remedy",
+	"remind",
+	"remit",
+	"remote",
+	"remove",
+	"renal",
+	"render",
+	"rent",
+	"rental",
+	"repair",
+	"repeal",
+	"repeat",
+	"repent",
+	"reply",
+	"report",
+	"rescue",
+	"resent",
+	"reside",
+	"resign",
+	"resin",
+	"resist",
+	"resort",
+	"rest",
+	"result",
+	"resume",
+	"retail",
+	"retain",
+	"retina",
+	"retire",
+	"return",
+	"reveal",
+	"review",
+	"revise",
+	"revive",
+	"revolt",
+	"reward",
+	"rhino",
+	"rhyme",
+	"rhythm",
+	"ribbon",
+	"rice",
+	"rich",
+	"rick",
+	"rid",
+	"ride",
+	"rider",
+	"ridge",
+	"rife",
+	"rifle",
+	"rift",
+	"right",
+	"rigid",
+	"ring",
+	"rinse",
+	"riot",
+	"ripe",
+	"ripen",
+	"ripple",
+	"rise",
+	"risk",
+	"risky",
+	"rite",
+	"ritual",
+	"rival",
+	"river",
+	"road",
+	"roar",
+	"roast",
+	"rob",
+	"robe",
+	"robin",
+	"robot",
+	"robust",
+	"rock",
+	"rocket",
+	"rocky",
+	"rod",
+	"rode",
+	"rodent",
+	"rogue",
+	"role",
+	"roll",
+	"roof",
+	"room",
+	"root",
+	"rope",
+	"rose",
+	"rosy",
+	"rotate",
+	"rotor",
+	"rotten",
+	"rouge",
+	"rough",
+	"round",
+	"route",
+	"rover",
+	"row",
+	"royal",
+	"rubble",
+	"ruby",
+	"rudder",
+	"rude",
+	"rugby",
+	"ruin",
+	"rule",
+	"ruler",
+	"rumble",
+	"rump",
+	"run",
+	"rune",
+	"rung",
+	"runway",
+	"rural",
+	"rush",
+	"rust",
+	"rustic",
+	"rusty",
+	"sack",
+	"sacred",
+	"sad",
+	"saddle",
+	"sadism",
+	"sadly",
+	"safari",
+	"safe",
+	"safely",
+	"safer",
+	"safety",
+	"saga",
+	"sage",
+	"said",
+	"sail",
+	"sailor",
+	"saint",
+	"sake",
+	"salad",
+	"salary",
+	"sale",
+	"saline",
+	"saliva",
+	"salmon",
+	"saloon",
+	"salt",
+	"salty",
+	"salute",
+	"same",
+	"sample",
+	"sand",
+	"sandy",
+	"sane",
+	"sash",
+	"satan",
+	"satin",
+	"satire",
+	"sauce",
+	"sauna",
+	"savage",
+	"save",
+	"say",
+	"scale",
+	"scalp",
+	"scan",
+	"scant",
+	"scar",
+	"scarce",
+	"scare",
+	"scarf",
+	"scary",
+	"scene",
+	"scenic",
+	"scent",
+	"school",
+	"scope",
+	"score",
+	"scorn",
+	"scotch",
+	"scout",
+	"scrap",
+	"scream",
+	"screen",
+	"screw",
+	"script",
+	"scroll",
+	"scrub",
+	"scum",
+	"sea",
+	"seal",
+	"seam",
+	"seaman",
+	"search",
+	"season",
+	"seat",
+	"second",
+	"secret",
+	"sect",
+	"sector",
+	"secure",
+	"see",
+	"seed",
+	"seeing",
+	"seek",
+	"seem",
+	"seize",
+	"seldom",
+	"select",
+	"self",
+	"sell",
+	"seller",
+	"semi",
+	"senate",
+	"send",
+	"senile",
+	"senior",
+	"sense",
+	"sensor",
+	"sent",
+	"sentry",
+	"sequel",
+	"serene",
+	"serial",
+	"series",
+	"sermon",
+	"serum",
+	"serve",
+	"server",
+	"set",
+	"settle",
+	"seven",
+	"severe",
+	"sewage",
+	"sex",
+	"sexual",
+	"sexy",
+	"shabby",
+	"shade",
+	"shadow",
+	"shady",
+	"shaft",
+	"shaggy",
+	"shah",
+	"shake",
+	"shaky",
+	"shall",
+	"sham",
+	"shame",
+	"shape",
+	"share",
+	"shark",
+	"sharp",
+	"shawl",
+	"she",
+	"shear",
+	"sheen",
+	"sheep",
+	"sheer",
+	"sheet",
+	"shelf",
+	"shell",
+	"sherry",
+	"shield",
+	"shift",
+	"shine",
+	"shiny",
+	"ship",
+	"shire",
+	"shirt",
+	"shit",
+	"shiver",
+	"shock",
+	"shoe",
+	"shook",
+	"shoot",
+	"shop",
+	"shore",
+	"short",
+	"shot",
+	"should",
+	"shout",
+	"show",
+	"shower",
+	"shrank",
+	"shrewd",
+	"shrill",
+	"shrimp",
+	"shrine",
+	"shrink",
+	"shrub",
+	"shrug",
+	"shut",
+	"shy",
+	"shyly",
+	"sick",
+	"side",
+	"siege",
+	"sigh",
+	"sight",
+	"sigma",
+	"sign",
+	"signal",
+	"silent",
+	"silk",
+	"silken",
+	"silky",
+	"sill",
+	"silly",
+	"silver",
+	"simple",
+	"simply",
+	"since",
+	"sinful",
+	"sing",
+	"singer",
+	"single",
+	"sink",
+	"sir",
+	"siren",
+	"sister",
+	"sit",
+	"site",
+	"six",
+	"sixth",
+	"sixty",
+	"size",
+	"sketch",
+	"skill",
+	"skin",
+	"skinny",
+	"skip",
+	"skirt",
+	"skull",
+	"sky",
+	"slab",
+	"slack",
+	"slain",
+	"slam",
+	"slang",
+	"slap",
+	"slate",
+	"slater",
+	"slave",
+	"sleek",
+	"sleep",
+	"sleepy",
+	"sleeve",
+	"slice",
+	"slick",
+	"slid",
+	"slide",
+	"slight",
+	"slim",
+	"slimy",
+	"sling",
+	"slip",
+	"slit",
+	"slogan",
+	"slope",
+	"sloppy",
+	"slot",
+	"slow",
+	"slowly",
+	"slug",
+	"slum",
+	"slump",
+	"smack",
+	"small",
+	"smart",
+	"smash",
+	"smear",
+	"smell",
+	"smelly",
+	"smelt",
+	"smile",
+	"smoke",
+	"smoky",
+	"smooth",
+	"smug",
+	"snack",
+	"snail",
+	"snake",
+	"snap",
+	"snatch",
+	"sneak",
+	"snow",
+	"snowy",
+	"snug",
+	"soak",
+	"soap",
+	"sober",
+	"soccer",
+	"social",
+	"sock",
+	"socket",
+	"soda",
+	"sodden",
+	"sodium",
+	"sofa",
+	"soft",
+	"soften",
+	"softly",
+	"soggy",
+	"soil",
+	"solar",
+	"sold",
+	"sole",
+	"solely",
+	"solemn",
+	"solid",
+	"solo",
+	"solve",
+	"some",
+	"son",
+	"sonar",
+	"sonata",
+	"song",
+	"sonic",
+	"soon",
+	"sooner",
+	"soot",
+	"soothe",
+	"sordid",
+	"sore",
+	"sorrow",
+	"sorry",
+	"sort",
+	"soul",
+	"sound",
+	"soup",
+	"sour",
+	"source",
+	"space",
+	"spade",
+	"span",
+	"spare",
+	"spark",
+	"sparse",
+	"spasm",
+	"spat",
+	"spate",
+	"speak",
+	"spear",
+	"speech",
+	"speed",
+	"speedy",
+	"spell",
+	"spend",
+	"sperm",
+	"sphere",
+	"spice",
+	"spicy",
+	"spider",
+	"spiky",
+	"spill",
+	"spin",
+	"spinal",
+	"spine",
+	"spiral",
+	"spirit",
+	"spit",
+	"spite",
+	"splash",
+	"split",
+	"spoil",
+	"spoke",
+	"sponge",
+	"spoon",
+	"sport",
+	"spot",
+	"spouse",
+	"spray",
+	"spread",
+	"spree",
+	"spring",
+	"sprint",
+	"spur",
+	"squad",
+	"square",
+	"squash",
+	"squat",
+	"squid",
+	"stab",
+	"stable",
+	"stack",
+	"staff",
+	"stage",
+	"stain",
+	"stair",
+	"stake",
+	"stale",
+	"stall",
+	"stamp",
+	"stance",
+	"stand",
+	"staple",
+	"star",
+	"starch",
+	"stare",
+	"stark",
+	"start",
+	"starve",
+	"state",
+	"static",
+	"statue",
+	"status",
+	"stay",
+	"stead",
+	"steady",
+	"steak",
+	"steal",
+	"steam",
+	"steel",
+	"steep",
+	"steer",
+	"stem",
+	"stench",
+	"step",
+	"stereo",
+	"stern",
+	"stew",
+	"stick",
+	"sticky",
+	"stiff",
+	"stifle",
+	"stigma",
+	"still",
+	"sting",
+	"stint",
+	"stir",
+	"stitch",
+	"stock",
+	"stocky",
+	"stone",
+	"stony",
+	"stool",
+	"stop",
+	"store",
+	"storm",
+	"stormy",
+	"story",
+	"stout",
+	"stove",
+	"strain",
+	"strait",
+	"strand",
+	"strap",
+	"strata",
+	"straw",
+	"stray",
+	"streak",
+	"stream",
+	"street",
+	"stress",
+	"strict",
+	"stride",
+	"strife",
+	"strike",
+	"string",
+	"strip",
+	"strive",
+	"stroke",
+	"stroll",
+	"strong",
+	"stud",
+	"studio",
+	"study",
+	"stuff",
+	"stuffy",
+	"stunt",
+	"stupid",
+	"sturdy",
+	"style",
+	"submit",
+	"subtle",
+	"subtly",
+	"suburb",
+	"such",
+	"suck",
+	"sudden",
+	"sue",
+	"suffer",
+	"sugar",
+	"suit",
+	"suite",
+	"suitor",
+	"sullen",
+	"sultan",
+	"sum",
+	"summer",
+	"summit",
+	"summon",
+	"sun",
+	"sunny",
+	"sunset",
+	"super",
+	"superb",
+	"supper",
+	"supple",
+	"supply",
+	"sure",
+	"surely",
+	"surf",
+	"surge",
+	"survey",
+	"suture",
+	"swamp",
+	"swan",
+	"swap",
+	"swarm",
+	"sway",
+	"swear",
+	"sweat",
+	"sweaty",
+	"sweep",
+	"sweet",
+	"swell",
+	"swift",
+	"swim",
+	"swine",
+	"swing",
+	"swirl",
+	"switch",
+	"sword",
+	"swore",
+	"symbol",
+	"synod",
+	"syntax",
+	"syrup",
+	"system",
+	"table",
+	"tablet",
+	"taboo",
+	"tacit",
+	"tackle",
+	"tact",
+	"tactic",
+	"tail",
+	"tailor",
+	"take",
+	"tale",
+	"talent",
+	"talk",
+	"tall",
+	"tally",
+	"tame",
+	"tandem",
+	"tangle",
+	"tank",
+	"tap",
+	"tape",
+	"target",
+	"tariff",
+	"tart",
+	"task",
+	"taste",
+	"tasty",
+	"tattoo",
+	"taut",
+	"tavern",
+	"tax",
+	"taxi",
+	"tea",
+	"teach",
+	"teak",
+	"team",
+	"tear",
+	"tease",
+	"tech",
+	"teeth",
+	"tell",
+	"temper",
+	"temple",
+	"tempo",
+	"tempt",
+	"ten",
+	"tenant",
+	"tend",
+	"tender",
+	"tendon",
+	"tennis",
+	"tenor",
+	"tense",
+	"tensor",
+	"tent",
+	"tenth",
+	"tenure",
+	"term",
+	"terror",
+	"test",
+	"text",
+	"than",
+	"thank",
+	"that",
+	"the",
+	"their",
+	"them",
+	"theme",
+	"then",
+	"thence",
+	"theory",
+	"there",
+	"these",
+	"thesis",
+	"they",
+	"thick",
+	"thief",
+	"thigh",
+	"thin",
+	"thing",
+	"think",
+	"third",
+	"thirst",
+	"thirty",
+	"this",
+	"thorn",
+	"those",
+	"though",
+	"thread",
+	"threat",
+	"three",
+	"thrill",
+	"thrive",
+	"throat",
+	"throne",
+	"throng",
+	"throw",
+	"thrust",
+	"thud",
+	"thug",
+	"thumb",
+	"thus",
+	"thyme",
+	"tick",
+	"ticket",
+	"tidal",
+	"tide",
+	"tidy",
+	"tie",
+	"tier",
+	"tiger",
+	"tight",
+	"tile",
+	"till",
+	"tilt",
+	"timber",
+	"time",
+	"timid",
+	"tin",
+	"tiny",
+	"tip",
+	"tissue",
+	"title",
+	"toad",
+	"toast",
+	"today",
+	"toilet",
+	"token",
+	"told",
+	"toll",
+	"tomato",
+	"tomb",
+	"tonal",
+	"tone",
+	"tongue",
+	"tonic",
+	"too",
+	"took",
+	"tool",
+	"tooth",
+	"top",
+	"topaz",
+	"topic",
+	"torch",
+	"torque",
+	"torso",
+	"tort",
+	"toss",
+	"total",
+	"touch",
+	"tough",
+	"tour",
+	"toward",
+	"towel",
+	"tower",
+	"town",
+	"toxic",
+	"toxin",
+	"trace",
+	"track",
+	"tract",
+	"trade",
+	"tragic",
+	"trail",
+	"train",
+	"trait",
+	"tram",
+	"trance",
+	"trap",
+	"trauma",
+	"travel",
+	"tray",
+	"tread",
+	"treat",
+	"treaty",
+	"treble",
+	"tree",
+	"trek",
+	"tremor",
+	"trench",
+	"trend",
+	"trendy",
+	"trial",
+	"tribal",
+	"tribe",
+	"trick",
+	"tricky",
+	"tried",
+	"trifle",
+	"trim",
+	"trio",
+	"trip",
+	"triple",
+	"troop",
+	"trophy",
+	"trot",
+	"trough",
+	"trout",
+	"truce",
+	"truck",
+	"true",
+	"truly",
+	"trunk",
+	"trust",
+	"truth",
+	"try",
+	"tsar",
+	"tube",
+	"tumble",
+	"tuna",
+	"tundra",
+	"tune",
+	"tung",
+	"tunic",
+	"tunnel",
+	"turban",
+	"turf",
+	"turn",
+	"turtle",
+	"tutor",
+	"tweed",
+	"twelve",
+	"twenty",
+	"twice",
+	"twin",
+	"twist",
+	"two",
+	"tycoon",
+	"tying",
+	"type",
+	"tyrant",
+	"ugly",
+	"ulcer",
+	"ultra",
+	"umpire",
+	"unable",
+	"uncle",
+	"under",
+	"uneasy",
+	"unfair",
+	"unify",
+	"union",
+	"unique",
+	"unit",
+	"unite",
+	"unity",
+	"unlike",
+	"unrest",
+	"unruly",
+	"until",
+	"update",
+	"upheld",
+	"uphill",
+	"uphold",
+	"upon",
+	"uproar",
+	"upset",
+	"upshot",
+	"uptake",
+	"upturn",
+	"upward",
+	"urban",
+	"urge",
+	"urgent",
+	"urging",
+	"urine",
+	"usable",
+	"usage",
+	"use",
+	"useful",
+	"user",
+	"usual",
+	"uterus",
+	"utmost",
+	"utter",
+	"vacant",
+	"vacuum",
+	"vagina",
+	"vague",
+	"vain",
+	"valet",
+	"valid",
+	"valley",
+	"value",
+	"valve",
+	"van",
+	"vanish",
+	"vanity",
+	"vary",
+	"vase",
+	"vast",
+	"vat",
+	"vault",
+	"vector",
+	"veil",
+	"vein",
+	"velvet",
+	"vendor",
+	"veneer",
+	"venom",
+	"vent",
+	"venue",
+	"verb",
+	"verbal",
+	"verge",
+	"verify",
+	"verity",
+	"verse",
+	"versus",
+	"very",
+	"vessel",
+	"vest",
+	"veto",
+	"via",
+	"viable",
+	"vicar",
+	"vice",
+	"victim",
+	"victor",
+	"video",
+	"view",
+	"vigil",
+	"vile",
+	"villa",
+	"vine",
+	"vinyl",
+	"viola",
+	"violet",
+	"violin",
+	"viral",
+	"virgin",
+	"virtue",
+	"virus",
+	"visa",
+	"vision",
+	"visit",
+	"visual",
+	"vital",
+	"vivid",
+	"vocal",
+	"vodka",
+	"vogue",
+	"voice",
+	"void",
+	"volley",
+	"volume",
+	"vomit",
+	"vote",
+	"vowel",
+	"voyage",
+	"vulgar",
+	"wade",
+	"wage",
+	"waist",
+	"wait",
+	"waiter",
+	"wake",
+	"walk",
+	"walker",
+	"wall",
+	"wallet",
+	"walnut",
+	"wander",
+	"want",
+	"war",
+	"warden",
+	"warm",
+	"warmth",
+	"warn",
+	"warp",
+	"wary",
+	"was",
+	"wash",
+	"wasp",
+	"waste",
+	"watch",
+	"water",
+	"watery",
+	"wave",
+	"way",
+	"weak",
+	"weaken",
+	"wealth",
+	"weapon",
+	"wear",
+	"weary",
+	"wedge",
+	"wee",
+	"weed",
+	"week",
+	"weekly",
+	"weep",
+	"weight",
+	"weird",
+	"well",
+	"were",
+	"wet",
+	"whale",
+	"wharf",
+	"what",
+	"wheat",
+	"wheel",
+	"when",
+	"whence",
+	"where",
+	"which",
+	"whiff",
+	"whig",
+	"while",
+	"whim",
+	"whip",
+	"whisky",
+	"white",
+	"who",
+	"whole",
+	"wholly",
+	"whom",
+	"whore",
+	"whose",
+	"why",
+	"wide",
+	"widely",
+	"widen",
+	"wider",
+	"widow",
+	"width",
+	"wife",
+	"wild",
+	"wildly",
+	"wilful",
+	"will",
+	"willow",
+	"win",
+	"wind",
+	"window",
+	"windy",
+	"wine",
+	"wing",
+	"wink",
+	"winner",
+	"winter",
+	"wipe",
+	"wire",
+	"wisdom",
+	"wise",
+	"wish",
+	"wit",
+	"witch",
+	"with",
+	"within",
+	"witty",
+	"wizard",
+	"woke",
+	"wolf",
+	"wolves",
+	"woman",
+	"womb",
+	"won",
+	"wonder",
+	"wood",
+	"wooden",
+	"woods",
+	"woody",
+	"wool",
+	"word",
+	"work",
+	"worker",
+	"world",
+	"worm",
+	"worry",
+	"worse",
+	"worst",
+	"worth",
+	"worthy",
+	"would",
+	"wound",
+	"wrap",
+	"wrath",
+	"wreath",
+	"wreck",
+	"wright",
+	"wrist",
+	"writ",
+	"write",
+	"writer",
+	"wrong",
+	"xerox",
+	"yacht",
+	"yard",
+	"yarn",
+	"yeah",
+	"year",
+	"yeast",
+	"yellow",
+	"yet",
+	"yield",
+	"yogurt",
+	"yolk",
+	"you",
+	"young",
+	"your",
+	"youth",
+	"zeal",
+	"zebra",
+	"zenith",
+	"zero",
+	"zigzag",
+	"zinc",
+	"zombie",
+	"zone"
+};
--- a/modules/pam_permit/pam_permit.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_permit/pam_permit.c	1697368996.392485079
@@ -0,0 +1,93 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause
+ *
+ * Copyright 2001 Mark R V Murray
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <stddef.h>
+
+#define	PAM_SM_AUTH
+#define	PAM_SM_ACCOUNT
+#define	PAM_SM_SESSION
+#define	PAM_SM_PASSWORD
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char *user;
+	int r;
+
+	if ((r = pam_get_user(pamh, &user, NULL)) != PAM_SUCCESS)
+		return (r);
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_permit");
--- a/modules/pam_radius/pam_radius.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_radius/pam_radius.c	1697370850.162339934
@@ -0,0 +1,429 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright 1998 Juniper Networks, Inc.
+ * All rights reserved.
+ * Copyright (c) 2001-2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ * Copyright (c) 2015-2018 The University of Oslo
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <netdb.h>
+#include <pwd.h>
+#include <radlib.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#define PAM_SM_AUTH
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+#define PAM_OPT_CONF		"conf"
+#define PAM_OPT_TEMPLATE_USER	"template_user"
+#define PAM_OPT_NAS_ID		"nas_id"
+#define PAM_OPT_NAS_IPADDR	"nas_ipaddr"
+#define PAM_OPT_NO_REPLYMSG	"no_reply_message"
+
+#define	MAX_CHALLENGE_MSGS	10
+#define	PASSWORD_PROMPT		"RADIUS Password:"
+
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(radius)
+#define PAM_LOG PAM_LOG_radius()
+#define PAM_LOG_DEBUG(...) \
+	os_log_debug(PAM_LOG, __VA_ARGS__)
+#define PAM_VERBOSE_ERROR(...) \
+	os_log_error(PAM_LOG, __VA_ARGS__)
+#endif
+
+static int	 build_access_request(struct rad_handle *, const char *,
+		    const char *, const char *, const char *, const char *,
+		    const void *, size_t);
+static int	 do_accept(pam_handle_t *, struct rad_handle *);
+static int	 do_challenge(pam_handle_t *, struct rad_handle *,
+		    const char *, const char *, const char *, const char *);
+
+/*
+ * Construct an access request, but don't send it.  Returns 0 on success,
+ * -1 on failure.
+ */
+static int
+build_access_request(struct rad_handle *radh, const char *user,
+    const char *pass, const char *nas_id, const char *nas_ipaddr,
+    const char *rhost, const void *state, size_t state_len)
+{
+	int error;
+	char host[MAXHOSTNAMELEN];
+	struct sockaddr_in *haddr;
+	struct addrinfo hints;
+	struct addrinfo *res;
+
+	if (rad_create_request(radh, RAD_ACCESS_REQUEST) == -1) {
+		syslog(LOG_CRIT, "rad_create_request: %s", rad_strerror(radh));
+		return (-1);
+	}
+	if (nas_id == NULL ||
+	    (nas_ipaddr != NULL && strlen(nas_ipaddr) == 0)) {
+		if (gethostname(host, sizeof host) != -1) {
+			if (nas_id == NULL)
+				nas_id = host;
+			if (nas_ipaddr != NULL && strlen(nas_ipaddr) == 0)
+				nas_ipaddr = host;
+		}
+	}
+	if ((user != NULL &&
+	    rad_put_string(radh, RAD_USER_NAME, user) == -1) ||
+	    (pass != NULL &&
+	    rad_put_string(radh, RAD_USER_PASSWORD, pass) == -1) ||
+	    (nas_id != NULL &&
+	    rad_put_string(radh, RAD_NAS_IDENTIFIER, nas_id) == -1)) {
+		syslog(LOG_CRIT, "rad_put_string: %s", rad_strerror(radh));
+		return (-1);
+	}
+	if (nas_ipaddr != NULL) {
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_family = AF_INET;
+		if (getaddrinfo(nas_ipaddr, NULL, &hints, &res) == 0 &&
+		    res != NULL && res->ai_family == AF_INET) {
+			haddr = (struct sockaddr_in *)res->ai_addr;
+			error = rad_put_addr(radh, RAD_NAS_IP_ADDRESS,
+			    haddr->sin_addr);
+			freeaddrinfo(res);
+			if (error == -1) {
+				syslog(LOG_CRIT, "rad_put_addr: %s",
+				    rad_strerror(radh));
+				return (-1);
+			}
+		}
+	}
+	if (rhost != NULL &&
+	    rad_put_string(radh, RAD_CALLING_STATION_ID, rhost) == -1) {
+		syslog(LOG_CRIT, "rad_put_string: %s", rad_strerror(radh));
+		return (-1);
+	}
+	if (state != NULL &&
+	    rad_put_attr(radh, RAD_STATE, state, state_len) == -1) {
+		syslog(LOG_CRIT, "rad_put_attr: %s", rad_strerror(radh));
+		return (-1);
+	}
+	if (rad_put_int(radh, RAD_SERVICE_TYPE, RAD_AUTHENTICATE_ONLY) == -1) {
+		syslog(LOG_CRIT, "rad_put_int: %s", rad_strerror(radh));
+		return (-1);
+	}
+	return (0);
+}
+
+static int
+do_accept(pam_handle_t *pamh, struct rad_handle *radh)
+{
+	int attrtype;
+	const void *attrval;
+	size_t attrlen;
+	char *s;
+
+	while ((attrtype = rad_get_attr(radh, &attrval, &attrlen)) > 0) {
+		switch (attrtype) {
+		case RAD_USER_NAME:
+			if ((s = rad_cvt_string(attrval, attrlen)) == NULL)
+				goto enomem;
+			pam_set_item(pamh, PAM_USER, s);
+			free(s);
+			break;
+		case RAD_REPLY_MESSAGE:
+			if ((s = rad_cvt_string(attrval, attrlen)) == NULL)
+				goto enomem;
+			if (!openpam_get_option(pamh, PAM_OPT_NO_REPLYMSG))
+				pam_info(pamh, "%s", s);
+			free(s);
+			break;
+		default:
+			PAM_LOG_DEBUG("%s(): ignoring RADIUS attribute %d",
+			    __func__, attrtype);
+		}
+	}
+	if (attrtype == -1) {
+		syslog(LOG_CRIT, "rad_get_attr: %s", rad_strerror(radh));
+		return (-1);
+	}
+	return (0);
+enomem:
+	syslog(LOG_CRIT, "%s(): out of memory", __func__);
+	return (-1);
+}
+
+static int
+do_reject(pam_handle_t *pamh, struct rad_handle *radh)
+{
+	int attrtype;
+	const void *attrval;
+	size_t attrlen;
+	char *s;
+
+	while ((attrtype = rad_get_attr(radh, &attrval, &attrlen)) > 0) {
+		switch (attrtype) {
+		case RAD_REPLY_MESSAGE:
+			if ((s = rad_cvt_string(attrval, attrlen)) == NULL)
+				goto enomem;
+			if (!openpam_get_option(pamh, PAM_OPT_NO_REPLYMSG))
+				pam_error(pamh, "%s", s);
+			free(s);
+			break;
+		default:
+			PAM_LOG_DEBUG("%s(): ignoring RADIUS attribute %d",
+			    __func__, attrtype);
+		}
+	}
+	if (attrtype < 0) {
+		syslog(LOG_CRIT, "rad_get_attr: %s", rad_strerror(radh));
+		return (-1);
+	}
+	return (0);
+enomem:
+	syslog(LOG_CRIT, "%s(): out of memory", __func__);
+	return (-1);
+}
+
+static int
+do_challenge(pam_handle_t *pamh, struct rad_handle *radh, const char *user,
+    const char *nas_id, const char *nas_ipaddr, const char *rhost)
+{
+	int retval;
+	int attrtype;
+	const void *attrval;
+	size_t attrlen;
+	const void *state;
+	size_t statelen;
+	struct pam_message msgs[MAX_CHALLENGE_MSGS];
+	const struct pam_message *msg_ptrs[MAX_CHALLENGE_MSGS];
+	struct pam_response *resp;
+	int num_msgs;
+	const void *item;
+	const struct pam_conv *conv;
+
+	state = NULL;
+	statelen = 0;
+	num_msgs = 0;
+	while ((attrtype = rad_get_attr(radh, &attrval, &attrlen)) > 0) {
+		switch (attrtype) {
+
+		case RAD_STATE:
+			state = attrval;
+			statelen = attrlen;
+			break;
+
+		case RAD_REPLY_MESSAGE:
+			if (num_msgs >= MAX_CHALLENGE_MSGS) {
+				syslog(LOG_CRIT,
+				    "Too many RADIUS challenge messages");
+				return (PAM_SERVICE_ERR);
+			}
+			msgs[num_msgs].msg = rad_cvt_string(attrval, attrlen);
+			if (msgs[num_msgs].msg == NULL) {
+				syslog(LOG_CRIT,
+				    "rad_cvt_string: out of memory");
+				return (PAM_SERVICE_ERR);
+			}
+			msgs[num_msgs].msg_style = PAM_TEXT_INFO;
+			msg_ptrs[num_msgs] = &msgs[num_msgs];
+			num_msgs++;
+			break;
+		}
+	}
+	if (attrtype == -1) {
+		syslog(LOG_CRIT, "rad_get_attr: %s", rad_strerror(radh));
+		return (PAM_SERVICE_ERR);
+	}
+	if (num_msgs == 0) {
+		msgs[num_msgs].msg = strdup("(null RADIUS challenge): ");
+		if (msgs[num_msgs].msg == NULL) {
+			syslog(LOG_CRIT, "Out of memory");
+			return (PAM_SERVICE_ERR);
+		}
+		msgs[num_msgs].msg_style = PAM_TEXT_INFO;
+		msg_ptrs[num_msgs] = &msgs[num_msgs];
+		num_msgs++;
+	}
+	msgs[num_msgs-1].msg_style = PAM_PROMPT_ECHO_ON;
+	if ((retval = pam_get_item(pamh, PAM_CONV, &item)) != PAM_SUCCESS) {
+		syslog(LOG_CRIT, "do_challenge: cannot get PAM_CONV");
+		return (retval);
+	}
+	conv = (const struct pam_conv *)item;
+	if ((retval = conv->conv(num_msgs, msg_ptrs, &resp,
+	    conv->appdata_ptr)) != PAM_SUCCESS)
+		return (retval);
+	if (build_access_request(radh, user, resp[num_msgs-1].resp, nas_id,
+	    nas_ipaddr, rhost, state, statelen) == -1)
+		return (PAM_SERVICE_ERR);
+	memset(resp[num_msgs-1].resp, 0, strlen(resp[num_msgs-1].resp));
+	free(resp[num_msgs-1].resp);
+	free(resp);
+	while (num_msgs > 0)
+		free(msgs[--num_msgs].msg);
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct rad_handle *radh;
+	const char *user, *pass;
+	const void *rhost, *tmpuser;
+	const char *conf_file, *template_user, *nas_id, *nas_ipaddr;
+	int retval;
+	int e;
+
+	conf_file = openpam_get_option(pamh, PAM_OPT_CONF);
+	template_user = openpam_get_option(pamh, PAM_OPT_TEMPLATE_USER);
+	nas_id = openpam_get_option(pamh, PAM_OPT_NAS_ID);
+	nas_ipaddr = openpam_get_option(pamh, PAM_OPT_NAS_IPADDR);
+	pam_get_item(pamh, PAM_RHOST, &rhost);
+
+	retval = pam_get_user(pamh, &user, NULL);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	PAM_LOG_DEBUG("Got user: %s", user);
+
+	retval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass, PASSWORD_PROMPT);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	PAM_LOG_DEBUG("Got password");
+
+	radh = rad_open();
+	if (radh == NULL) {
+		syslog(LOG_CRIT, "rad_open failed");
+		return (PAM_SERVICE_ERR);
+	}
+
+	PAM_LOG_DEBUG("Radius opened");
+
+	if (rad_config(radh, conf_file) == -1) {
+		syslog(LOG_ALERT, "rad_config: %s", rad_strerror(radh));
+		rad_close(radh);
+		return (PAM_SERVICE_ERR);
+	}
+
+	PAM_LOG_DEBUG("Radius config file read");
+
+	if (build_access_request(radh, user, pass, nas_id, nas_ipaddr, rhost,
+	    NULL, 0) == -1) {
+		rad_close(radh);
+		return (PAM_SERVICE_ERR);
+	}
+
+	PAM_LOG_DEBUG("Radius build access done");
+
+	for (;;) {
+		switch (rad_send_request(radh)) {
+
+		case RAD_ACCESS_ACCEPT:
+			e = do_accept(pamh, radh);
+			rad_close(radh);
+			if (e == -1)
+				return (PAM_SERVICE_ERR);
+			if (template_user != NULL) {
+
+				PAM_LOG_DEBUG("Trying template user: %s",
+				    template_user);
+
+				/*
+				 * If the given user name doesn't exist in
+				 * the local password database, change it
+				 * to the value given in the "template_user"
+				 * option.
+				 */
+				retval = pam_get_item(pamh, PAM_USER, &tmpuser);
+				if (retval != PAM_SUCCESS)
+					return (retval);
+				if (getpwnam(tmpuser) == NULL) {
+					pam_set_item(pamh, PAM_USER,
+					    template_user);
+					PAM_LOG_DEBUG("Using template user");
+				}
+
+			}
+			return (PAM_SUCCESS);
+
+		case RAD_ACCESS_REJECT:
+			retval = do_reject(pamh, radh);
+			rad_close(radh);
+			PAM_VERBOSE_ERROR("Radius rejection");
+			return (PAM_AUTH_ERR);
+
+		case RAD_ACCESS_CHALLENGE:
+			retval = do_challenge(pamh, radh, user, nas_id,
+			    nas_ipaddr, rhost);
+			if (retval != PAM_SUCCESS) {
+				rad_close(radh);
+				return (retval);
+			}
+			break;
+
+		case -1:
+			syslog(LOG_CRIT, "rad_send_request: %s",
+			    rad_strerror(radh));
+			rad_close(radh);
+			PAM_VERBOSE_ERROR("Radius failure");
+			return (PAM_AUTHINFO_UNAVAIL);
+
+		default:
+			syslog(LOG_CRIT,
+			    "rad_send_request: unexpected return value");
+			rad_close(radh);
+			PAM_VERBOSE_ERROR("Radius error");
+			return (PAM_SERVICE_ERR);
+		}
+	}
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_radius");
--- a/modules/pam_rhosts/pam_rhosts.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_rhosts/pam_rhosts.c	1697370909.154304227
@@ -0,0 +1,97 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2002 Danny Braniss
+ * All rights reserved.
+ * Copyright (c) 2001,2002 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <pwd.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+
+#define PAM_SM_AUTH
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+
+#define OPT_ALLOW_ROOT "allow_root"
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct passwd *pw;
+	const char *user;
+	const void *ruser, *rhost;
+	int err, superuser;
+
+	err = pam_get_user(pamh, &user, NULL);
+	if (err != PAM_SUCCESS)
+		return (err);
+
+	if ((pw = getpwnam(user)) == NULL)
+		return (PAM_USER_UNKNOWN);
+	if (pw->pw_uid == 0 &&
+	    openpam_get_option(pamh, OPT_ALLOW_ROOT) == NULL)
+		return (PAM_AUTH_ERR);
+
+	err = pam_get_item(pamh, PAM_RUSER, &ruser);
+	if (err != PAM_SUCCESS)
+		return (PAM_AUTH_ERR);
+
+	err = pam_get_item(pamh, PAM_RHOST, &rhost);
+	if (err != PAM_SUCCESS)
+		return (PAM_AUTH_ERR);
+
+	superuser = (strcmp(user, "root") == 0);
+	err = ruserok(rhost, superuser, ruser, user);
+	if (err != 0)
+		return (PAM_AUTH_ERR);
+
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_rhosts");
--- a/modules/pam_securetty/pam_securetty.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_securetty/pam_securetty.c	1697371149.514174255
@@ -0,0 +1,108 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2001 Mark R V Murray
+ * All rights reserved.
+ * Copyright (c) 2001 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <pwd.h>
+#include <ttyent.h>
+#include <string.h>
+
+#define PAM_SM_ACCOUNT
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+
+#define TTY_PREFIX	"/dev/"
+
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(radius)
+#define PAM_LOG PAM_LOG_radius()
+#define PAM_LOG_DEBUG(...) \
+        os_log_debug(PAM_LOG, __VA_ARGS__)
+#define PAM_VERBOSE_ERROR(...) \
+        os_log_error(PAM_LOG, __VA_ARGS__)
+#endif
+
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct passwd *pwd;
+	struct ttyent *ty;
+	const char *user;
+	const void *tty;
+	int pam_err;
+
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	if (user == NULL || (pwd = getpwnam(user)) == NULL)
+		return (PAM_SERVICE_ERR);
+
+	PAM_LOG_DEBUG("Got user: %s", user);
+
+	/* If the user is not root, secure ttys do not apply */
+	if (pwd->pw_uid != 0)
+		return (PAM_SUCCESS);
+
+	pam_err = pam_get_item(pamh, PAM_TTY, &tty);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	PAM_LOG_DEBUG("Got TTY: %s", (const char *)tty);
+
+	/* Ignore any "/dev/" on the PAM_TTY item */
+	if (tty != NULL && strncmp(TTY_PREFIX, tty, sizeof(TTY_PREFIX)) == 0) {
+		PAM_LOG_DEBUG("WARNING: PAM_TTY starts with " TTY_PREFIX);
+		tty = (const char *)tty + sizeof(TTY_PREFIX) - 1;
+	}
+
+	if (tty != NULL && (ty = getttynam(tty)) != NULL &&
+	    (ty->ty_status & TTY_SECURE) != 0)
+		return (PAM_SUCCESS);
+
+	PAM_VERBOSE_ERROR("Not on secure TTY");
+	return (PAM_AUTH_ERR);
+}
+
+PAM_MODULE_ENTRY("pam_securetty");
--- a/modules/pam_ssh/authfd.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ssh/authfd.h	1697444071.801557259
@@ -0,0 +1,121 @@
+/* $OpenBSD: authfd.h,v 1.51 2021/12/19 22:10:24 djm Exp $ */
+
+/*
+ * Author: Tatu Ylonen <ylo@cs.hut.fi>
+ * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
+ *                    All rights reserved
+ * Functions to interface with the SSH_AUTHENTICATION_FD socket.
+ *
+ * As far as I am concerned, the code I have written for this software
+ * can be used freely for any purpose.  Any derived versions of this
+ * software must be clearly marked as such, and if the derived work is
+ * incompatible with the protocol description in the RFC file, it must be
+ * called by a name other than "ssh" or "Secure Shell".
+ */
+
+#ifndef AUTHFD_H
+#define AUTHFD_H
+
+struct sshbuf;
+struct sshkey;
+
+/* List of identities returned by ssh_fetch_identitylist() */
+struct ssh_identitylist {
+	size_t nkeys;
+	struct sshkey **keys;
+	char **comments;
+};
+
+/* Key destination restrictions */
+struct dest_constraint_hop {
+	char *user;	/* wildcards allowed */
+	char *hostname; /* used to matching cert principals and for display */
+	int is_ca;
+	u_int nkeys;	/* number of entries in *both* 'keys' and 'key_is_ca' */
+	struct sshkey **keys;
+	int *key_is_ca;
+};
+struct dest_constraint {
+	struct dest_constraint_hop from;
+	struct dest_constraint_hop to;
+};
+
+int	ssh_get_authentication_socket(int *fdp);
+int	ssh_get_authentication_socket_path(const char *authsocket, int *fdp);
+void	ssh_close_authentication_socket(int sock);
+
+int	ssh_lock_agent(int sock, int lock, const char *password);
+int	ssh_fetch_identitylist(int sock, struct ssh_identitylist **idlp);
+void	ssh_free_identitylist(struct ssh_identitylist *idl);
+int	ssh_add_identity_constrained(int sock, struct sshkey *key,
+    const char *comment, u_int life, u_int confirm, u_int maxsign,
+    const char *provider, struct dest_constraint **dest_constraints,
+    size_t ndest_constraints);
+int	ssh_agent_has_key(int sock, const struct sshkey *key);
+int	ssh_remove_identity(int sock, const struct sshkey *key);
+int	ssh_update_card(int sock, int add, const char *reader_id,
+	    const char *pin, u_int life, u_int confirm,
+	    struct dest_constraint **dest_constraints,
+	    size_t ndest_constraints);
+int	ssh_remove_all_identities(int sock, int version);
+
+int	ssh_agent_sign(int sock, const struct sshkey *key,
+	    u_char **sigp, size_t *lenp,
+	    const u_char *data, size_t datalen, const char *alg, u_int compat);
+
+int	ssh_agent_bind_hostkey(int sock, const struct sshkey *key,
+    const struct sshbuf *session_id, const struct sshbuf *signature,
+    int forwarding);
+
+/* Messages for the authentication agent connection. */
+#define SSH_AGENTC_REQUEST_RSA_IDENTITIES	1
+#define SSH_AGENT_RSA_IDENTITIES_ANSWER		2
+#define SSH_AGENTC_RSA_CHALLENGE		3
+#define SSH_AGENT_RSA_RESPONSE			4
+#define SSH_AGENT_FAILURE			5
+#define SSH_AGENT_SUCCESS			6
+#define SSH_AGENTC_ADD_RSA_IDENTITY		7
+#define SSH_AGENTC_REMOVE_RSA_IDENTITY		8
+#define SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES	9
+
+/* private OpenSSH extensions for SSH2 */
+#define SSH2_AGENTC_REQUEST_IDENTITIES		11
+#define SSH2_AGENT_IDENTITIES_ANSWER		12
+#define SSH2_AGENTC_SIGN_REQUEST		13
+#define SSH2_AGENT_SIGN_RESPONSE		14
+#define SSH2_AGENTC_ADD_IDENTITY		17
+#define SSH2_AGENTC_REMOVE_IDENTITY		18
+#define SSH2_AGENTC_REMOVE_ALL_IDENTITIES	19
+
+/* smartcard */
+#define SSH_AGENTC_ADD_SMARTCARD_KEY		20
+#define SSH_AGENTC_REMOVE_SMARTCARD_KEY		21
+
+/* lock/unlock the agent */
+#define SSH_AGENTC_LOCK				22
+#define SSH_AGENTC_UNLOCK			23
+
+/* add key with constraints */
+#define SSH_AGENTC_ADD_RSA_ID_CONSTRAINED	24
+#define SSH2_AGENTC_ADD_ID_CONSTRAINED		25
+#define SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED 26
+
+/* generic extension mechanism */
+#define SSH_AGENTC_EXTENSION			27
+
+#define	SSH_AGENT_CONSTRAIN_LIFETIME		1
+#define	SSH_AGENT_CONSTRAIN_CONFIRM		2
+#define	SSH_AGENT_CONSTRAIN_MAXSIGN		3
+#define	SSH_AGENT_CONSTRAIN_EXTENSION		255
+
+/* extended failure messages */
+#define SSH2_AGENT_FAILURE			30
+
+/* additional error code for ssh.com's ssh-agent2 */
+#define SSH_COM_AGENT2_FAILURE			102
+
+#define	SSH_AGENT_OLD_SIGNATURE			0x01
+#define	SSH_AGENT_RSA_SHA2_256			0x02
+#define	SSH_AGENT_RSA_SHA2_512			0x04
+
+#endif				/* AUTHFD_H */
--- a/modules/pam_ssh/authfile.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ssh/authfile.h	1697444074.348247180
@@ -0,0 +1,54 @@
+/* $OpenBSD: authfile.h,v 1.25 2020/01/25 23:02:13 djm Exp $ */
+
+/*
+ * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef AUTHFILE_H
+#define AUTHFILE_H
+
+struct sshbuf;
+struct sshkey;
+
+/* XXX document these */
+/* XXX some of these could probably be merged/retired */
+
+int sshkey_save_private(struct sshkey *, const char *,
+    const char *, const char *, int, const char *, int);
+int sshkey_load_cert(const char *, struct sshkey **);
+int sshkey_load_public(const char *, struct sshkey **, char **);
+int sshkey_load_private(const char *, const char *, struct sshkey **, char **);
+int sshkey_load_private_cert(int, const char *, const char *,
+    struct sshkey **);
+int sshkey_load_private_type(int, const char *, const char *,
+    struct sshkey **, char **);
+int sshkey_load_private_type_fd(int fd, int type, const char *passphrase,
+    struct sshkey **keyp, char **commentp);
+int sshkey_perm_ok(int, const char *);
+int sshkey_in_file(struct sshkey *, const char *, int, int);
+int sshkey_check_revoked(struct sshkey *key, const char *revoked_keys_file);
+int sshkey_advance_past_options(char **cpp);
+int sshkey_save_public(const struct sshkey *key, const char *path,
+    const char *comment);
+
+#endif
--- a/modules/pam_ssh/pam_ssh.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ssh/pam_ssh.c	1697444019.790087355
@@ -0,0 +1,443 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 2003 Networks Associates Technology, Inc.
+ * Copyright (c) 2004-2011 Dag-Erling Smørgrav
+ * All rights reserved.
+ *
+ * This software was developed for the FreeBSD Project by ThinkSec AS and
+ * NAI Labs, the Security Research Division of Network Associates, Inc.
+ * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
+ * DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+#include <sys/wait.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+#define PAM_SM_AUTH
+#define PAM_SM_SESSION
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#include <security/openpam.h>
+
+#include <openssl/evp.h>
+
+#define __bounded__(x, y, z)
+#include "authfd.h"
+#include "authfile.h"
+#include "sshkey.h"
+
+#define ssh_add_identity(auth, key, comment) \
+	ssh_add_identity_constrained(auth, key, comment, 0, 0, 0, NULL, NULL, 0)
+
+extern char **environ;
+
+struct pam_ssh_key {
+	struct sshkey	*key;
+	char		*comment;
+};
+
+static const char *pam_ssh_prompt = "SSH passphrase: ";
+static const char *pam_ssh_have_keys = "pam_ssh_have_keys";
+
+static const char *pam_ssh_keyfiles[] = {
+	".ssh/id_rsa",		/* SSH2 RSA key */
+	".ssh/id_dsa",		/* SSH2 DSA key */
+	".ssh/id_ecdsa",	/* SSH2 ECDSA key */
+	".ssh/id_ed25519",	/* SSH2 Ed25519 key */
+	NULL
+};
+
+static const char *pam_ssh_agent = "/usr/bin/ssh-agent";
+static char str_ssh_agent[] = "ssh-agent";
+static char str_dash_s[] = "-s";
+static char *const pam_ssh_agent_argv[] = { str_ssh_agent, str_dash_s, NULL };
+static char *const pam_ssh_agent_envp[] = { NULL };
+
+/*
+ * Attempts to load a private key from the specified file in the specified
+ * directory, using the specified passphrase.  If successful, returns a
+ * struct pam_ssh_key containing the key and its comment.
+ */
+static struct pam_ssh_key *
+pam_ssh_load_key(const char *dir, const char *kfn, const char *passphrase,
+    int nullok)
+{
+	char fn[PATH_MAX];
+	struct pam_ssh_key *psk;
+	struct sshkey *key;
+	char *comment;
+	int ret;
+
+	if (snprintf(fn, sizeof(fn), "%s/%s", dir, kfn) > (int)sizeof(fn))
+		return (NULL);
+	/*
+	 * If the key is unencrypted, OpenSSL ignores the passphrase, so
+	 * it will seem like the user typed in the right one.  This allows
+	 * a user to circumvent nullok by providing a dummy passphrase.
+	 * Verify that the key really *is* encrypted by trying to load it
+	 * with an empty passphrase, and if the key is not encrypted,
+	 * accept only an empty passphrase.
+	 */
+	ret = sshkey_load_private(fn, "", &key, &comment);
+	if (ret == 0 && !(*passphrase == '\0' && nullok)) {
+		sshkey_free(key);
+		return (NULL);
+	}
+	if (ret != 0)
+		ret = sshkey_load_private(fn, passphrase, &key, &comment);
+	if (ret != 0) {
+		openpam_log(PAM_LOG_DEBUG, "failed to load key from %s", fn);
+		return (NULL);
+	}
+
+	openpam_log(PAM_LOG_DEBUG, "loaded '%s' from %s", comment, fn);
+	if ((psk = malloc(sizeof(*psk))) == NULL) {
+		sshkey_free(key);
+		free(comment);
+		return (NULL);
+	}
+	psk->key = key;
+	psk->comment = comment;
+	return (psk);
+}
+
+/*
+ * Wipes a private key and frees the associated resources.
+ */
+static void
+pam_ssh_free_key(pam_handle_t *pamh __unused,
+    void *data, int pam_err __unused)
+{
+	struct pam_ssh_key *psk;
+
+	psk = data;
+	sshkey_free(psk->key);
+	free(psk->comment);
+	free(psk);
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char **kfn, *passphrase, *user;
+	const void *item;
+	struct passwd *pwd;
+	struct pam_ssh_key *psk;
+	int nkeys, nullok, pam_err, pass;
+
+	nullok = (openpam_get_option(pamh, "nullok") != NULL);
+
+	/* PEM is not loaded by default */
+	OpenSSL_add_all_algorithms();
+
+	/* get user name and home directory */
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	pwd = getpwnam(user);
+	if (pwd == NULL)
+		return (PAM_USER_UNKNOWN);
+	if (pwd->pw_dir == NULL)
+		return (PAM_AUTH_ERR);
+
+	nkeys = 0;
+	pass = (pam_get_item(pamh, PAM_AUTHTOK, &item) == PAM_SUCCESS &&
+	    item != NULL);
+ load_keys:
+	/* get passphrase */
+	pam_err = pam_get_authtok(pamh, PAM_AUTHTOK,
+	    &passphrase, pam_ssh_prompt);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	/* switch to user credentials */
+	pam_err = openpam_borrow_cred(pamh, pwd);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	/* try to load keys from all keyfiles we know of */
+	for (kfn = pam_ssh_keyfiles; *kfn != NULL; ++kfn) {
+		psk = pam_ssh_load_key(pwd->pw_dir, *kfn, passphrase, nullok);
+		if (psk != NULL) {
+			pam_set_data(pamh, *kfn, psk, pam_ssh_free_key);
+			++nkeys;
+		}
+	}
+
+	/* switch back to arbitrator credentials */
+	openpam_restore_cred(pamh);
+
+	/*
+	 * If we tried an old token and didn't get anything, and
+	 * try_first_pass was specified, try again after prompting the
+	 * user for a new passphrase.
+	 */
+	if (nkeys == 0 && pass == 1 &&
+	    openpam_get_option(pamh, "try_first_pass") != NULL) {
+		pam_set_item(pamh, PAM_AUTHTOK, NULL);
+		pass = 0;
+		goto load_keys;
+	}
+
+	/* no keys? */
+	if (nkeys == 0)
+		return (PAM_AUTH_ERR);
+
+	pam_set_data(pamh, pam_ssh_have_keys, NULL, NULL);
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+/*
+ * Parses a line from ssh-agent's output.
+ */
+static void
+pam_ssh_process_agent_output(pam_handle_t *pamh, FILE *f)
+{
+	char *line, *p, *key, *val;
+	size_t len;
+
+	while ((line = fgetln(f, &len)) != NULL) {
+		if (len < 4 || strncmp(line, "SSH_", 4) != 0)
+			continue;
+
+		/* find equal sign at end of key */
+		for (p = key = line; p < line + len; ++p)
+			if (*p == '=')
+				break;
+		if (p == line + len || *p != '=')
+			continue;
+		*p = '\0';
+
+		/* find semicolon at end of value */
+		for (val = ++p; p < line + len; ++p)
+			if (*p == ';')
+				break;
+		if (p == line + len || *p != ';')
+			continue;
+		*p = '\0';
+
+		/* store key-value pair in environment */
+		openpam_log(PAM_LOG_DEBUG, "got %s: %s", key, val);
+		pam_setenv(pamh, key, val, 1);
+	}
+}
+
+/*
+ * Starts an ssh agent and stores the environment variables derived from
+ * its output.
+ */
+static int
+pam_ssh_start_agent(pam_handle_t *pamh)
+{
+	int agent_pipe[2];
+	pid_t pid;
+	FILE *f;
+
+	/* get a pipe which we will use to read the agent's output */
+	if (pipe(agent_pipe) == -1)
+		return (PAM_SYSTEM_ERR);
+
+	/* start the agent */
+	openpam_log(PAM_LOG_DEBUG, "starting an ssh agent");
+	pid = fork();
+	if (pid == (pid_t)-1) {
+		/* failed */
+		close(agent_pipe[0]);
+		close(agent_pipe[1]);
+		return (PAM_SYSTEM_ERR);
+	}
+	if (pid == 0) {
+		int fd;
+
+		/* child: drop privs, close fds and start agent */
+		setgid(getegid());
+		setuid(geteuid());
+		close(STDIN_FILENO);
+		open(_PATH_DEVNULL, O_RDONLY);
+		dup2(agent_pipe[1], STDOUT_FILENO);
+		dup2(agent_pipe[1], STDERR_FILENO);
+		for (fd = 3; fd < getdtablesize(); ++fd)
+			close(fd);
+		execve(pam_ssh_agent, pam_ssh_agent_argv, pam_ssh_agent_envp);
+		_exit(127);
+	}
+
+	/* parent */
+	close(agent_pipe[1]);
+	if ((f = fdopen(agent_pipe[0], "r")) == NULL)
+		return (PAM_SYSTEM_ERR);
+	pam_ssh_process_agent_output(pamh, f);
+	fclose(f);
+
+	return (PAM_SUCCESS);
+}
+
+/*
+ * Adds previously stored keys to a running agent.
+ */
+static int
+pam_ssh_add_keys_to_agent(pam_handle_t *pamh)
+{
+	const struct pam_ssh_key *psk;
+	const char **kfn;
+	const void *item;
+	char **envlist, **env;
+	int fd, pam_err;
+
+	/* switch to PAM environment */
+	envlist = environ;
+	if ((environ = pam_getenvlist(pamh)) == NULL) {
+		environ = envlist;
+		return (PAM_SYSTEM_ERR);
+	}
+
+	/* get a connection to the agent */
+	if (ssh_get_authentication_socket(&fd) != 0) {
+		openpam_log(PAM_LOG_DEBUG, "failed to connect to the agent");
+		pam_err = PAM_SYSTEM_ERR;
+		goto end;
+	}
+
+	/* look for keys to add to it */
+	for (kfn = pam_ssh_keyfiles; *kfn != NULL; ++kfn) {
+		pam_err = pam_get_data(pamh, *kfn, &item);
+		if (pam_err == PAM_SUCCESS && item != NULL) {
+			psk = item;
+			if (ssh_add_identity(fd, psk->key, psk->comment) == 0)
+				openpam_log(PAM_LOG_DEBUG,
+				    "added %s to ssh agent", psk->comment);
+			else
+				openpam_log(PAM_LOG_DEBUG, "failed "
+				    "to add %s to ssh agent", psk->comment);
+			/* we won't need the key again, so wipe it */
+			pam_set_data(pamh, *kfn, NULL, NULL);
+		}
+	}
+	pam_err = PAM_SUCCESS;
+
+	/* disconnect from agent */
+	ssh_close_authentication_socket(fd);
+
+ end:
+	/* switch back to original environment */
+	for (env = environ; *env != NULL; ++env)
+		free(*env);
+	free(environ);
+	environ = envlist;
+
+	return (pam_err);
+}
+
+PAM_EXTERN int
+pam_sm_open_session(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct passwd *pwd;
+	const char *user;
+	const void *data;
+	int pam_err;
+
+	/* no keys, no work */
+	if (pam_get_data(pamh, pam_ssh_have_keys, &data) != PAM_SUCCESS &&
+	    openpam_get_option(pamh, "want_agent") == NULL)
+		return (PAM_SUCCESS);
+
+	/* switch to user credentials */
+	pam_err = pam_get_user(pamh, &user, NULL);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+	pwd = getpwnam(user);
+	if (pwd == NULL)
+		return (PAM_USER_UNKNOWN);
+	pam_err = openpam_borrow_cred(pamh, pwd);
+	if (pam_err != PAM_SUCCESS)
+		return (pam_err);
+
+	/* start the agent */
+	pam_err = pam_ssh_start_agent(pamh);
+	if (pam_err != PAM_SUCCESS) {
+		openpam_restore_cred(pamh);
+		return (pam_err);
+	}
+
+	/* we have an agent, see if we can add any keys to it */
+	pam_err = pam_ssh_add_keys_to_agent(pamh);
+	if (pam_err != PAM_SUCCESS) {
+		/* XXX ignore failures */
+	}
+
+	openpam_restore_cred(pamh);
+	return (PAM_SUCCESS);
+}
+
+PAM_EXTERN int
+pam_sm_close_session(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	const char *ssh_agent_pid;
+	char *end;
+	int status;
+	pid_t pid;
+
+	if ((ssh_agent_pid = pam_getenv(pamh, "SSH_AGENT_PID")) == NULL) {
+		openpam_log(PAM_LOG_DEBUG, "no ssh agent");
+		return (PAM_SUCCESS);
+	}
+	pid = (pid_t)strtol(ssh_agent_pid, &end, 10);
+	if (*ssh_agent_pid == '\0' || *end != '\0') {
+		openpam_log(PAM_LOG_DEBUG, "invalid ssh agent pid");
+		return (PAM_SESSION_ERR);
+	}
+	openpam_log(PAM_LOG_DEBUG, "killing ssh agent %d", (int)pid);
+	if (kill(pid, SIGTERM) == -1 ||
+	    (waitpid(pid, &status, 0) == -1 && errno != ECHILD))
+		return (PAM_SYSTEM_ERR);
+	return (PAM_SUCCESS);
+}
+
+PAM_MODULE_ENTRY("pam_ssh");
--- a/modules/pam_ssh/sshkey.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_ssh/sshkey.h	1697444076.861155230
@@ -0,0 +1,351 @@
+/* $OpenBSD: sshkey.h,v 1.62 2023/06/21 05:10:26 djm Exp $ */
+
+/*
+ * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SSHKEY_H
+#define SSHKEY_H
+
+#include <sys/types.h>
+
+#ifdef WITH_OPENSSL
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+# ifdef OPENSSL_HAS_ECC
+#  include <openssl/ec.h>
+#  include <openssl/ecdsa.h>
+# else /* OPENSSL_HAS_ECC */
+#  define EC_KEY	void
+#  define EC_GROUP	void
+#  define EC_POINT	void
+# endif /* OPENSSL_HAS_ECC */
+#define SSH_OPENSSL_VERSION OpenSSL_version(OPENSSL_VERSION)
+#else /* WITH_OPENSSL */
+# define BIGNUM		void
+# define RSA		void
+# define DSA		void
+# define EC_KEY		void
+# define EC_GROUP	void
+# define EC_POINT	void
+#define SSH_OPENSSL_VERSION "without OpenSSL"
+#endif /* WITH_OPENSSL */
+
+#define SSH_RSA_MINIMUM_MODULUS_SIZE	1024
+#define SSH_KEY_MAX_SIGN_DATA_SIZE	(1 << 20)
+
+struct sshbuf;
+
+/* Key types */
+enum sshkey_types {
+	KEY_RSA,
+	KEY_DSA,
+	KEY_ECDSA,
+	KEY_ED25519,
+	KEY_RSA_CERT,
+	KEY_DSA_CERT,
+	KEY_ECDSA_CERT,
+	KEY_ED25519_CERT,
+	KEY_XMSS,
+	KEY_XMSS_CERT,
+	KEY_ECDSA_SK,
+	KEY_ECDSA_SK_CERT,
+	KEY_ED25519_SK,
+	KEY_ED25519_SK_CERT,
+	KEY_UNSPEC
+};
+
+/* Default fingerprint hash */
+#define SSH_FP_HASH_DEFAULT	SSH_DIGEST_SHA256
+
+/* Fingerprint representation formats */
+enum sshkey_fp_rep {
+	SSH_FP_DEFAULT = 0,
+	SSH_FP_HEX,
+	SSH_FP_BASE64,
+	SSH_FP_BUBBLEBABBLE,
+	SSH_FP_RANDOMART
+};
+
+/* Private key serialisation formats, used on the wire */
+enum sshkey_serialize_rep {
+	SSHKEY_SERIALIZE_DEFAULT = 0,
+	SSHKEY_SERIALIZE_STATE = 1,	/* only state is serialized */
+	SSHKEY_SERIALIZE_FULL = 2,	/* include keys for saving to disk */
+	SSHKEY_SERIALIZE_SHIELD = 3,	/* everything, for encrypting in ram */
+	SSHKEY_SERIALIZE_INFO = 254,	/* minimal information */
+};
+
+/* Private key disk formats */
+enum sshkey_private_format {
+	SSHKEY_PRIVATE_OPENSSH = 0,
+	SSHKEY_PRIVATE_PEM = 1,
+	SSHKEY_PRIVATE_PKCS8 = 2,
+};
+
+/* key is stored in external hardware */
+#define SSHKEY_FLAG_EXT		0x0001
+
+#define SSHKEY_CERT_MAX_PRINCIPALS	256
+/* XXX opaquify? */
+struct sshkey_cert {
+	struct sshbuf	*certblob; /* Kept around for use on wire */
+	u_int		 type; /* SSH2_CERT_TYPE_USER or SSH2_CERT_TYPE_HOST */
+	u_int64_t	 serial;
+	char		*key_id;
+	u_int		 nprincipals;
+	char		**principals;
+	u_int64_t	 valid_after, valid_before;
+	struct sshbuf	*critical;
+	struct sshbuf	*extensions;
+	struct sshkey	*signature_key;
+	char		*signature_type;
+};
+
+/* XXX opaquify? */
+struct sshkey {
+	int	 type;
+	int	 flags;
+	/* KEY_RSA */
+	RSA	*rsa;
+	/* KEY_DSA */
+	DSA	*dsa;
+	/* KEY_ECDSA and KEY_ECDSA_SK */
+	int	 ecdsa_nid;	/* NID of curve */
+	EC_KEY	*ecdsa;
+	/* KEY_ED25519 and KEY_ED25519_SK */
+	u_char	*ed25519_sk;
+	u_char	*ed25519_pk;
+	/* KEY_XMSS */
+	char	*xmss_name;
+	char	*xmss_filename;	/* for state file updates */
+	void	*xmss_state;	/* depends on xmss_name, opaque */
+	u_char	*xmss_sk;
+	u_char	*xmss_pk;
+	/* KEY_ECDSA_SK and KEY_ED25519_SK */
+	char	*sk_application;
+	uint8_t	sk_flags;
+	struct sshbuf *sk_key_handle;
+	struct sshbuf *sk_reserved;
+	/* Certificates */
+	struct sshkey_cert *cert;
+	/* Private key shielding */
+	u_char	*shielded_private;
+	size_t	shielded_len;
+	u_char	*shield_prekey;
+	size_t	shield_prekey_len;
+};
+
+#define	ED25519_SK_SZ	crypto_sign_ed25519_SECRETKEYBYTES
+#define	ED25519_PK_SZ	crypto_sign_ed25519_PUBLICKEYBYTES
+
+/* Additional fields contained in signature */
+struct sshkey_sig_details {
+	uint32_t sk_counter;	/* U2F signature counter */
+	uint8_t sk_flags;	/* U2F signature flags; see ssh-sk.h */
+};
+
+struct sshkey_impl_funcs {
+	u_int (*size)(const struct sshkey *);	/* optional */
+	int (*alloc)(struct sshkey *);		/* optional */
+	void (*cleanup)(struct sshkey *);	/* optional */
+	int (*equal)(const struct sshkey *, const struct sshkey *);
+	int (*serialize_public)(const struct sshkey *, struct sshbuf *,
+	    enum sshkey_serialize_rep);
+	int (*deserialize_public)(const char *, struct sshbuf *,
+	    struct sshkey *);
+	int (*serialize_private)(const struct sshkey *, struct sshbuf *,
+	    enum sshkey_serialize_rep);
+	int (*deserialize_private)(const char *, struct sshbuf *,
+	    struct sshkey *);
+	int (*generate)(struct sshkey *, int);	/* optional */
+	int (*copy_public)(const struct sshkey *, struct sshkey *);
+	int (*sign)(struct sshkey *, u_char **, size_t *,
+	    const u_char *, size_t, const char *,
+	    const char *, const char *, u_int); /* optional */
+	int (*verify)(const struct sshkey *, const u_char *, size_t,
+	    const u_char *, size_t, const char *, u_int,
+	    struct sshkey_sig_details **);
+};
+
+struct sshkey_impl {
+	const char *name;
+	const char *shortname;
+	const char *sigalg;
+	int type;
+	int nid;
+	int cert;
+	int sigonly;
+	int keybits;
+	const struct sshkey_impl_funcs *funcs;
+};
+
+struct sshkey	*sshkey_new(int);
+void		 sshkey_free(struct sshkey *);
+int		 sshkey_equal_public(const struct sshkey *,
+    const struct sshkey *);
+int		 sshkey_equal(const struct sshkey *, const struct sshkey *);
+char		*sshkey_fingerprint(const struct sshkey *,
+    int, enum sshkey_fp_rep);
+int		 sshkey_fingerprint_raw(const struct sshkey *k,
+    int, u_char **retp, size_t *lenp);
+const char	*sshkey_type(const struct sshkey *);
+const char	*sshkey_cert_type(const struct sshkey *);
+int		 sshkey_format_text(const struct sshkey *, struct sshbuf *);
+int		 sshkey_write(const struct sshkey *, FILE *);
+int		 sshkey_read(struct sshkey *, char **);
+u_int		 sshkey_size(const struct sshkey *);
+
+int		 sshkey_generate(int type, u_int bits, struct sshkey **keyp);
+int		 sshkey_from_private(const struct sshkey *, struct sshkey **);
+
+int		 sshkey_is_shielded(struct sshkey *);
+int		 sshkey_shield_private(struct sshkey *);
+int		 sshkey_unshield_private(struct sshkey *);
+
+int	 sshkey_type_from_name(const char *);
+int	 sshkey_is_cert(const struct sshkey *);
+int	 sshkey_is_sk(const struct sshkey *);
+int	 sshkey_type_is_cert(int);
+int	 sshkey_type_plain(int);
+
+/* Returns non-zero if key name match sigalgs pattern list. (handles RSA) */
+int	 sshkey_match_keyname_to_sigalgs(const char *, const char *);
+
+int	 sshkey_to_certified(struct sshkey *);
+int	 sshkey_drop_cert(struct sshkey *);
+int	 sshkey_cert_copy(const struct sshkey *, struct sshkey *);
+int	 sshkey_cert_check_authority(const struct sshkey *, int, int, int,
+    uint64_t, const char *, const char **);
+int	 sshkey_cert_check_authority_now(const struct sshkey *, int, int, int,
+    const char *, const char **);
+int	 sshkey_cert_check_host(const struct sshkey *, const char *,
+    int , const char *, const char **);
+size_t	 sshkey_format_cert_validity(const struct sshkey_cert *,
+    char *, size_t) __attribute__((__bounded__(__string__, 2, 3)));
+int	 sshkey_check_cert_sigtype(const struct sshkey *, const char *);
+
+int	 sshkey_certify(struct sshkey *, struct sshkey *,
+    const char *, const char *, const char *);
+/* Variant allowing use of a custom signature function (e.g. for ssh-agent) */
+typedef int sshkey_certify_signer(struct sshkey *, u_char **, size_t *,
+    const u_char *, size_t, const char *, const char *, const char *,
+    u_int, void *);
+int	 sshkey_certify_custom(struct sshkey *, struct sshkey *, const char *,
+    const char *, const char *, sshkey_certify_signer *, void *);
+
+int		 sshkey_ecdsa_nid_from_name(const char *);
+int		 sshkey_curve_name_to_nid(const char *);
+const char *	 sshkey_curve_nid_to_name(int);
+u_int		 sshkey_curve_nid_to_bits(int);
+int		 sshkey_ecdsa_bits_to_nid(int);
+int		 sshkey_ecdsa_key_to_nid(EC_KEY *);
+int		 sshkey_ec_nid_to_hash_alg(int nid);
+int		 sshkey_ec_validate_public(const EC_GROUP *, const EC_POINT *);
+int		 sshkey_ec_validate_private(const EC_KEY *);
+const char	*sshkey_ssh_name(const struct sshkey *);
+const char	*sshkey_ssh_name_plain(const struct sshkey *);
+int		 sshkey_names_valid2(const char *, int, int);
+char		*sshkey_alg_list(int, int, int, char);
+
+int	 sshkey_from_blob(const u_char *, size_t, struct sshkey **);
+int	 sshkey_fromb(struct sshbuf *, struct sshkey **);
+int	 sshkey_froms(struct sshbuf *, struct sshkey **);
+int	 sshkey_to_blob(const struct sshkey *, u_char **, size_t *);
+int	 sshkey_to_base64(const struct sshkey *, char **);
+int	 sshkey_putb(const struct sshkey *, struct sshbuf *);
+int	 sshkey_puts(const struct sshkey *, struct sshbuf *);
+int	 sshkey_puts_opts(const struct sshkey *, struct sshbuf *,
+    enum sshkey_serialize_rep);
+int	 sshkey_plain_to_blob(const struct sshkey *, u_char **, size_t *);
+int	 sshkey_putb_plain(const struct sshkey *, struct sshbuf *);
+
+int	 sshkey_sign(struct sshkey *, u_char **, size_t *,
+    const u_char *, size_t, const char *, const char *, const char *, u_int);
+int	 sshkey_verify(const struct sshkey *, const u_char *, size_t,
+    const u_char *, size_t, const char *, u_int, struct sshkey_sig_details **);
+int	 sshkey_check_sigtype(const u_char *, size_t, const char *);
+const char *sshkey_sigalg_by_name(const char *);
+int	 sshkey_get_sigtype(const u_char *, size_t, char **);
+
+/* for debug */
+void	sshkey_dump_ec_point(const EC_GROUP *, const EC_POINT *);
+void	sshkey_dump_ec_key(const EC_KEY *);
+
+/* private key parsing and serialisation */
+int	sshkey_private_serialize(struct sshkey *key, struct sshbuf *buf);
+int	sshkey_private_serialize_opt(struct sshkey *key, struct sshbuf *buf,
+    enum sshkey_serialize_rep);
+int	sshkey_private_deserialize(struct sshbuf *buf,  struct sshkey **keyp);
+
+/* private key file format parsing and serialisation */
+int	sshkey_private_to_fileblob(struct sshkey *key, struct sshbuf *blob,
+    const char *passphrase, const char *comment,
+    int format, const char *openssh_format_cipher, int openssh_format_rounds);
+int	sshkey_parse_private_fileblob(struct sshbuf *buffer,
+    const char *passphrase, struct sshkey **keyp, char **commentp);
+int	sshkey_parse_private_fileblob_type(struct sshbuf *blob, int type,
+    const char *passphrase, struct sshkey **keyp, char **commentp);
+int	sshkey_parse_pubkey_from_private_fileblob_type(struct sshbuf *blob,
+    int type, struct sshkey **pubkeyp);
+
+int sshkey_check_rsa_length(const struct sshkey *, int);
+/* XXX should be internal, but used by ssh-keygen */
+int ssh_rsa_complete_crt_parameters(struct sshkey *, const BIGNUM *);
+
+/* stateful keys (e.g. XMSS) */
+int	 sshkey_set_filename(struct sshkey *, const char *);
+int	 sshkey_enable_maxsign(struct sshkey *, u_int32_t);
+u_int32_t sshkey_signatures_left(const struct sshkey *);
+int	 sshkey_forward_state(const struct sshkey *, u_int32_t, int);
+int	 sshkey_private_serialize_maxsign(struct sshkey *key,
+    struct sshbuf *buf, u_int32_t maxsign, int);
+
+void	 sshkey_sig_details_free(struct sshkey_sig_details *);
+
+#ifdef SSHKEY_INTERNAL
+int	sshkey_sk_fields_equal(const struct sshkey *a, const struct sshkey *b);
+void	sshkey_sk_cleanup(struct sshkey *k);
+int	sshkey_serialize_sk(const struct sshkey *key, struct sshbuf *b);
+int	sshkey_copy_public_sk(const struct sshkey *from, struct sshkey *to);
+int	sshkey_deserialize_sk(struct sshbuf *b, struct sshkey *key);
+int	sshkey_serialize_private_sk(const struct sshkey *key,
+    struct sshbuf *buf);
+int	sshkey_private_deserialize_sk(struct sshbuf *buf, struct sshkey *k);
+#ifdef WITH_OPENSSL
+int	check_rsa_length(const RSA *rsa); /* XXX remove */
+#endif
+#endif
+
+#if !defined(WITH_OPENSSL)
+# undef RSA
+# undef DSA
+# undef EC_KEY
+# undef EC_GROUP
+# undef EC_POINT
+#elif !defined(OPENSSL_HAS_ECC)
+# undef EC_KEY
+# undef EC_GROUP
+# undef EC_POINT
+#endif
+
+#endif /* SSHKEY_H */
--- a/modules/pam_tacplus/pam_tacplus.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_tacplus/pam_tacplus.c	1697691317.691358093
@@ -0,0 +1,294 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright 1998 Juniper Networks, Inc.
+ * All rights reserved.
+ * Copyright (c) 2001-2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#include <sys/param.h>
+
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <taclib.h>
+#include <unistd.h>
+
+#define PAM_SM_AUTH
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+#if __FreeBSD__
+#include <security/pam_mod_misc.h>
+#endif
+
+#define PAM_OPT_CONF		"conf"
+#define PAM_OPT_TEMPLATE_USER	"template_user"
+
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(tacplus)
+#define PAM_LOG PAM_LOG_tacplus()
+#define PAM_LOG_DEBUG(...) \
+	os_log_debug(PAM_LOG, __VA_ARGS__)
+#define PAM_VERBOSE_ERROR(...) \
+	os_log_error(PAM_LOG, __VA_ARGS__)
+#define PAM_OPT_ECHO_PASS       "echo_pass"
+#endif
+
+typedef int (*set_func)(struct tac_handle *, const char *);
+
+static int	 do_item(pam_handle_t *, struct tac_handle *, int,
+		    set_func, const char *);
+static char	*get_msg(struct tac_handle *);
+static int	 set_msg(struct tac_handle *, const char *);
+
+static int
+do_item(pam_handle_t *pamh, struct tac_handle *tach, int item,
+    set_func func, const char *funcname)
+{
+	int retval;
+	const void *value;
+
+	retval = pam_get_item(pamh, item, &value);
+	if (retval != PAM_SUCCESS)
+	    return retval;
+	if (value != NULL && (*func)(tach, (const char *)value) == -1) {
+		syslog(LOG_CRIT, "%s: %s", funcname, tac_strerror(tach));
+		tac_close(tach);
+		return PAM_SERVICE_ERR;
+	}
+	return PAM_SUCCESS;
+}
+
+static char *
+get_msg(struct tac_handle *tach)
+{
+	char *msg;
+
+	msg = tac_get_msg(tach);
+	if (msg == NULL) {
+		syslog(LOG_CRIT, "tac_get_msg: %s", tac_strerror(tach));
+		tac_close(tach);
+		return NULL;
+	}
+	return msg;
+}
+
+static int
+set_msg(struct tac_handle *tach, const char *msg)
+{
+	if (tac_set_msg(tach, msg) == -1) {
+		syslog(LOG_CRIT, "tac_set_msg: %s", tac_strerror(tach));
+		tac_close(tach);
+		return -1;
+	}
+	return 0;
+}
+
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	int retval;
+	struct tac_handle *tach;
+	const char *conf_file, *template_user;
+
+	conf_file = openpam_get_option(pamh, PAM_OPT_CONF);
+	template_user = openpam_get_option(pamh, PAM_OPT_TEMPLATE_USER);
+
+	tach = tac_open();
+	if (tach == NULL) {
+		syslog(LOG_CRIT, "tac_open failed");
+		return (PAM_SERVICE_ERR);
+	}
+	if (tac_config(tach, conf_file) == -1) {
+		syslog(LOG_ALERT, "tac_config: %s", tac_strerror(tach));
+		tac_close(tach);
+		return (PAM_SERVICE_ERR);
+	}
+	if (tac_create_authen(tach, TAC_AUTHEN_LOGIN, TAC_AUTHEN_TYPE_ASCII,
+	    TAC_AUTHEN_SVC_LOGIN) == -1) {
+		syslog(LOG_CRIT, "tac_create_authen: %s", tac_strerror(tach));
+		tac_close(tach);
+		return (PAM_SERVICE_ERR);
+	}
+
+	PAM_LOG_DEBUG("Done tac_open() ... tac_close()");
+
+	retval = do_item(pamh, tach, PAM_USER, tac_set_user, "tac_set_user");
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	PAM_LOG_DEBUG("Done user");
+
+	retval = do_item(pamh, tach, PAM_TTY, tac_set_port, "tac_set_port");
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	PAM_LOG_DEBUG("Done tty");
+
+	retval = do_item(pamh, tach, PAM_RHOST, tac_set_rem_addr,
+	    "tac_set_rem_addr");
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	for (;;) {
+		char *srvr_msg;
+		size_t msg_len;
+		const char *user_msg;
+		char *data_msg;
+		int sflags;
+		int status;
+
+		sflags = tac_send_authen(tach);
+		if (sflags == -1) {
+			syslog(LOG_CRIT, "tac_send_authen: %s",
+			    tac_strerror(tach));
+			tac_close(tach);
+			return (PAM_AUTHINFO_UNAVAIL);
+		}
+		status = TAC_AUTHEN_STATUS(sflags);
+		openpam_set_option(pamh, PAM_OPT_ECHO_PASS,
+		    TAC_AUTHEN_NOECHO(sflags) ? NULL : "");
+		switch (status) {
+
+		case TAC_AUTHEN_STATUS_PASS:
+			tac_close(tach);
+			if (template_user != NULL) {
+				const void *item;
+				const char *user;
+
+				PAM_LOG_DEBUG("Trying template user: %s",
+				    template_user);
+
+				/*
+				 * If the given user name doesn't exist in
+				 * the local password database, change it
+				 * to the value given in the "template_user"
+				 * option.
+				 */
+				retval = pam_get_item(pamh, PAM_USER, &item);
+				if (retval != PAM_SUCCESS)
+					return (retval);
+				user = (const char *)item;
+				if (getpwnam(user) == NULL) {
+					pam_set_item(pamh, PAM_USER,
+					    template_user);
+					PAM_LOG_DEBUG("Using template user");
+				}
+			}
+			return (PAM_SUCCESS);
+
+		case TAC_AUTHEN_STATUS_FAIL:
+			tac_close(tach);
+			PAM_VERBOSE_ERROR("TACACS+ authentication failed");
+			return (PAM_AUTH_ERR);
+
+		case TAC_AUTHEN_STATUS_GETUSER:
+		case TAC_AUTHEN_STATUS_GETPASS:
+			if ((srvr_msg = get_msg(tach)) == NULL)
+				return (PAM_SERVICE_ERR);
+			if (status == TAC_AUTHEN_STATUS_GETUSER)
+				retval = pam_get_user(pamh, &user_msg,
+				    *srvr_msg ? srvr_msg : NULL);
+			else if (status == TAC_AUTHEN_STATUS_GETPASS)
+				retval = pam_get_authtok(pamh,
+				    PAM_AUTHTOK, &user_msg,
+				    *srvr_msg ? srvr_msg : "Password:");
+			free(srvr_msg);
+			if (retval != PAM_SUCCESS) {
+				/* XXX - send a TACACS+ abort packet */
+				tac_close(tach);
+				return (retval);
+			}
+			if (set_msg(tach, user_msg) == -1)
+				return (PAM_SERVICE_ERR);
+			break;
+
+		case TAC_AUTHEN_STATUS_GETDATA:
+			if ((srvr_msg = get_msg(tach)) == NULL)
+				return (PAM_SERVICE_ERR);
+			retval = pam_prompt(pamh,
+			    openpam_get_option(pamh, PAM_OPT_ECHO_PASS) ?
+			    PAM_PROMPT_ECHO_ON : PAM_PROMPT_ECHO_OFF,
+			    &data_msg, "%s", *srvr_msg ? srvr_msg : "Data:");
+			free(srvr_msg);
+			if (retval != PAM_SUCCESS) {
+				/* XXX - send a TACACS+ abort packet */
+				tac_close(tach);
+				return (retval);
+			}
+			retval = set_msg(tach, data_msg);
+			memset(data_msg, 0, strlen(data_msg));
+			free(data_msg);
+			if (retval == -1)
+				return (PAM_SERVICE_ERR);
+			break;
+
+		case TAC_AUTHEN_STATUS_ERROR:
+			srvr_msg = (char *)tac_get_data(tach, &msg_len);
+			if (srvr_msg != NULL && msg_len != 0) {
+				syslog(LOG_CRIT, "tac_send_authen:"
+				    " server detected error: %s", srvr_msg);
+				free(srvr_msg);
+			}
+			else
+				syslog(LOG_CRIT,
+				    "tac_send_authen: server detected error");
+			tac_close(tach);
+			return (PAM_AUTHINFO_UNAVAIL);
+			break;
+
+		case TAC_AUTHEN_STATUS_RESTART:
+		case TAC_AUTHEN_STATUS_FOLLOW:
+		default:
+			syslog(LOG_CRIT,
+			    "tac_send_authen: unexpected status %#x", status);
+			tac_close(tach);
+			return (PAM_AUTHINFO_UNAVAIL);
+		}
+	}
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_IGNORE);
+}
+
+PAM_MODULE_ENTRY("pam_tacplus");
--- a/modules/pam_unix/_secure_path.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/_secure_path.c	1697798861.247974313
@@ -0,0 +1,74 @@
+/*-
+ * Based on code copyright (c) 1995,1997 by
+ * Berkeley Software Design, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, is permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice immediately at the beginning of the file, without modification,
+ *    this list of conditions, and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. This work was done expressly for inclusion into FreeBSD.  Other use
+ *    is permitted provided this notation is included.
+ * 4. Absolutely no warranty of function or purpose is made by the authors.
+ * 5. Modifications may be freely made to this file providing the above
+ *    conditions are met.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+#include <libutil.h>
+#include <stddef.h>
+#include <syslog.h>
+
+/*
+ * Check for common security problems on a given path
+ * It must be:
+ * 1. A regular file, and exists
+ * 2. Owned and writable only by root (or given owner)
+ * 3. Group ownership is given group or is non-group writable
+ *
+ * Returns:	-2 if file does not exist,
+ *		-1 if security test failure
+ *		0  otherwise
+ */
+
+int
+_secure_path(const char *path, uid_t uid, gid_t gid)
+{
+    int		r = -1;
+    struct stat	sb;
+    const char	*msg = NULL;
+
+    if (lstat(path, &sb) < 0) {
+	if (errno == ENOENT) /* special case */
+	    r = -2;  /* if it is just missing, skip the log entry */
+	else
+	    msg = "%s: cannot stat %s: %m";
+    }
+    else if (!S_ISREG(sb.st_mode))
+    	msg = "%s: %s is not a regular file";
+    else if (sb.st_mode & S_IWOTH)
+    	msg = "%s: %s is world writable";
+    else if ((int)uid != -1 && sb.st_uid != uid && sb.st_uid != 0) {
+    	if (uid == 0)
+    		msg = "%s: %s is not owned by root";
+    	else
+    		msg = "%s: %s is not owned by uid %d";
+    } else if ((int)gid != -1 && sb.st_gid != gid && (sb.st_mode & S_IWGRP))
+    	msg = "%s: %s is group writeable by non-authorised groups";
+    else
+    	r = 0;
+    if (msg != NULL)
+	syslog(LOG_ERR, msg, "_secure_path", path, uid);
+    return r;
+}
--- a/modules/pam_unix/flopen.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/flopen.c	1697798865.852930370
@@ -0,0 +1,147 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2007-2009 Dag-Erling Coïdan Smørgrav
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/file.h>
+#include <sys/stat.h>
+
+#include <errno.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#include <libutil.h>
+
+/*
+ * Reliably open and lock a file.
+ *
+ * Please do not modify this code without first reading the revision history
+ * and discussing your changes with <des@freebsd.org>.  Don't be fooled by the
+ * code's apparent simplicity; there would be no need for this function if it
+ * was easy to get right.
+ */
+static int
+vflopenat(int dirfd, const char *path, int flags, va_list ap)
+{
+	int fd, operation, serrno, trunc;
+	struct stat sb, fsb;
+	mode_t mode;
+
+#ifdef O_EXLOCK
+	flags &= ~O_EXLOCK;
+#endif
+
+	mode = 0;
+	if (flags & O_CREAT) {
+		mode = (mode_t)va_arg(ap, int); /* mode_t promoted to int */
+	}
+
+        operation = LOCK_EX;
+        if (flags & O_NONBLOCK)
+                operation |= LOCK_NB;
+
+	trunc = (flags & O_TRUNC);
+	flags &= ~O_TRUNC;
+
+	for (;;) {
+		if ((fd = openat(dirfd, path, flags, mode)) == -1)
+			/* non-existent or no access */
+			return (-1);
+		if (flock(fd, operation) == -1) {
+			/* unsupported or interrupted */
+			serrno = errno;
+			(void)close(fd);
+			errno = serrno;
+			return (-1);
+		}
+		if (fstatat(dirfd, path, &sb, 0) == -1) {
+			/* disappeared from under our feet */
+			(void)close(fd);
+			continue;
+		}
+		if (fstat(fd, &fsb) == -1) {
+			/* can't happen [tm] */
+			serrno = errno;
+			(void)close(fd);
+			errno = serrno;
+			return (-1);
+		}
+		if (sb.st_dev != fsb.st_dev ||
+		    sb.st_ino != fsb.st_ino) {
+			/* changed under our feet */
+			(void)close(fd);
+			continue;
+		}
+		if (trunc && ftruncate(fd, 0) != 0) {
+			/* can't happen [tm] */
+			serrno = errno;
+			(void)close(fd);
+			errno = serrno;
+			return (-1);
+		}
+		/*
+		 * The following change is provided as a specific example to
+		 * avoid.
+		 */
+#if 0
+		if (fcntl(fd, F_SETFD, FD_CLOEXEC) != 0) {
+			serrno = errno;
+			(void)close(fd);
+			errno = serrno;
+			return (-1);
+		}
+#endif
+		return (fd);
+	}
+}
+
+int
+flopen(const char *path, int flags, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, flags);
+	ret = vflopenat(AT_FDCWD, path, flags, ap);
+	va_end(ap);
+	return (ret);
+}
+
+int
+flopenat(int dirfd, const char *path, int flags, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, flags);
+	ret = vflopenat(dirfd, path, flags, ap);
+	va_end(ap);
+	return (ret);
+}
--- a/modules/pam_unix/gr_util.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/gr_util.c	1697798869.536124859
@@ -0,0 +1,669 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2008 Sean C. Farley <scf@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/errno.h>
+#include <sys/stat.h>
+
+#include <ctype.h>
+#include <err.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <inttypes.h>
+#include <libutil.h>
+#include <paths.h>
+#include <pwd.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <os/availability.h>
+API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
+void * reallocarray(void * in_ptr, size_t nmemb, size_t size) __DARWIN_EXTSN(reallocarray) __result_use_check;
+
+static int lockfd = -1;
+static char group_dir[PATH_MAX];
+static char group_file[PATH_MAX];
+static char tempname[PATH_MAX];
+static int initialized;
+static size_t grmemlen(const struct group *, const char *, int *);
+static struct group *grcopy(const struct group *gr, char *mem, const char *, int ndx);
+
+/*
+ * Initialize statics
+ */
+int
+gr_init(const char *dir, const char *group)
+{
+
+	if (dir == NULL) {
+		strcpy(group_dir, _PATH_PWD);
+	} else {
+		if (strlen(dir) >= sizeof(group_dir)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+		strcpy(group_dir, dir);
+	}
+
+	if (group == NULL) {
+		if (dir == NULL) {
+			strcpy(group_file, _PATH_GROUP);
+		} else if (snprintf(group_file, sizeof(group_file), "%s/group",
+			group_dir) > (int)sizeof(group_file)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+	} else {
+		if (strlen(group) >= sizeof(group_file)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+		strcpy(group_file, group);
+	}
+
+	initialized = 1;
+	return (0);
+}
+
+/*
+ * Lock the group file
+ */
+int
+gr_lock(void)
+{
+	if (*group_file == '\0')
+		return (-1);
+
+	for (;;) {
+		struct stat st;
+
+		lockfd = flopen(group_file, O_RDONLY|O_NONBLOCK|O_CLOEXEC, 0);
+		if (lockfd == -1) {
+			if (errno == EWOULDBLOCK) {
+				errx(1, "the group file is busy");
+			} else {
+				err(1, "could not lock the group file");
+			}
+		}
+		if (fstat(lockfd, &st) == -1)
+			err(1, "fstat() failed");
+		if (st.st_nlink != 0)
+			break;
+		close(lockfd);
+		lockfd = -1;
+	}
+	return (lockfd);
+}
+
+/*
+ * Create and open a presmuably safe temp file for editing group data
+ */
+int
+gr_tmp(int mfd)
+{
+	char buf[8192];
+	ssize_t nr;
+	const char *p;
+	int tfd;
+
+	if (*group_file == '\0')
+		return (-1);
+	if ((p = strrchr(group_file, '/')))
+		++p;
+	else
+		p = group_file;
+	if (snprintf(tempname, sizeof(tempname), "%.*sgroup.XXXXXX",
+		(int)(p - group_file), group_file) >= (int)sizeof(tempname)) {
+		errno = ENAMETOOLONG;
+		return (-1);
+	}
+	if ((tfd = mkostemp(tempname, 0)) == -1)
+		return (-1);
+	if (mfd != -1) {
+		while ((nr = read(mfd, buf, sizeof(buf))) > 0)
+			if (write(tfd, buf, (size_t)nr) != nr)
+				break;
+		if (nr != 0) {
+			unlink(tempname);
+			*tempname = '\0';
+			close(tfd);
+			return (-1);
+		}
+	}
+	return (tfd);
+}
+
+/*
+ * Copy the group file from one descriptor to another, replacing, deleting
+ * or adding a single record on the way.
+ */
+int
+gr_copy(int ffd, int tfd, const struct group *gr, struct group *old_gr)
+{
+	char *buf, *end, *line, *p, *q, *r, *tmp;
+	struct group *fgr;
+	const struct group *sgr;
+	size_t len, size;
+	int eof, readlen;
+	char t;
+
+	if (old_gr == NULL && gr == NULL)
+		return(-1);
+
+	sgr = old_gr;
+	/* deleting a group */
+	if (gr == NULL) {
+		line = NULL;
+	} else {
+		if ((line = gr_make(gr)) == NULL)
+			return (-1);
+	}
+
+	/* adding a group */
+	if (sgr == NULL)
+		sgr = gr;
+
+	/* initialize the buffer */
+	if ((buf = malloc(size = 1024)) == NULL)
+		goto err;
+
+	eof = 0;
+	len = 0;
+	p = q = end = buf;
+	for (;;) {
+		/* find the end of the current line */
+		for (p = q; q < end && *q != '\0'; ++q)
+			if (*q == '\n')
+				break;
+
+		/* if we don't have a complete line, fill up the buffer */
+		if (q >= end) {
+			if (eof)
+				break;
+			while ((size_t)(q - p) >= size) {
+				if ((tmp = reallocarray(buf, 2, size)) == NULL) {
+					warnx("group line too long");
+					goto err;
+				}
+				p = tmp + (p - buf);
+				q = tmp + (q - buf);
+				end = tmp + (end - buf);
+				buf = tmp;
+				size = size * 2;
+			}
+			if (p < end) {
+				q = memmove(buf, p, end -p);
+				end -= p - buf;
+			} else {
+				p = q = end = buf;
+			}
+			readlen = read(ffd, end, size - (end - buf));
+			if (readlen == -1)
+				goto err;
+			else
+				len = (size_t)readlen;
+			if (len == 0 && p == buf)
+				break;
+			end += len;
+			len = end - buf;
+			if (len < size) {
+				eof = 1;
+				if (len > 0 && buf[len -1] != '\n')
+					++len, *end++ = '\n';
+			}
+			continue;
+		}
+
+		/* is it a blank line or a comment? */
+		for (r = p; r < q && isspace(*r); ++r)
+			/* nothing */;
+		if (r == q || *r == '#') {
+			/* yep */
+			if (write(tfd, p, q -p + 1) != q - p + 1)
+				goto err;
+			++q;
+			continue;
+		}
+
+		/* is it the one we're looking for? */
+
+		t = *q;
+		*q = '\0';
+
+		fgr = gr_scan(r);
+
+		/* fgr is either a struct group for the current line,
+		 * or NULL if the line is malformed.
+		 */
+
+		*q = t;
+		if (fgr == NULL || fgr->gr_gid != sgr->gr_gid) {
+			/* nope */
+			if (fgr != NULL)
+				free(fgr);
+			if (write(tfd, p, q - p + 1) != q - p + 1)
+				goto err;
+			++q;
+			continue;
+		}
+		if (old_gr && !gr_equal(fgr, old_gr)) {
+			warnx("entry inconsistent");
+			free(fgr);
+			errno = EINVAL; /* hack */
+			goto err;
+		}
+		free(fgr);
+
+		/* it is, replace or remove it */
+		if (line != NULL) {
+			len = strlen(line);
+			if (write(tfd, line, len) != (int) len)
+				goto err;
+		} else {
+			/* when removed, avoid the \n */
+			q++;
+		}
+		/* we're done, just copy the rest over */
+		for (;;) {
+			if (write(tfd, q, end - q) != end - q)
+				goto err;
+			q = buf;
+			readlen = read(ffd, buf, size);
+			if (readlen == 0)
+				break;
+			else
+				len = (size_t)readlen;
+			if (readlen == -1)
+				goto err;
+			end = buf + len;
+		}
+		goto done;
+	}
+
+	/* if we got here, we didn't find the old entry */
+	if (line == NULL) {
+		errno = ENOENT;
+		goto err;
+	}
+	len = strlen(line);
+	if ((size_t)write(tfd, line, len) != len ||
+	   write(tfd, "\n", 1) != 1)
+		goto err;
+ done:
+	free(line);
+	free(buf);
+	return (0);
+ err:
+	free(line);
+	free(buf);
+	return (-1);
+}
+
+/*
+ * Regenerate the group file
+ */
+int
+gr_mkdb(void)
+{
+	int fd;
+
+	if (chmod(tempname, 0644) != 0)
+		return (-1);
+
+	if (rename(tempname, group_file) != 0)
+		return (-1);
+
+	/*
+	 * Make sure new group file is safe on disk. To improve performance we
+	 * will call fsync() to the directory where file lies
+	 */
+	if ((fd = open(group_dir, O_RDONLY|O_DIRECTORY)) == -1)
+		return (-1);
+
+	if (fsync(fd) != 0) {
+		close(fd);
+		return (-1);
+	}
+
+	close(fd);
+	return(0);
+}
+
+/*
+ * Clean up. Preserves errno for the caller's convenience.
+ */
+void
+gr_fini(void)
+{
+	int serrno;
+
+	if (!initialized)
+		return;
+	initialized = 0;
+	serrno = errno;
+	if (*tempname != '\0') {
+		unlink(tempname);
+		*tempname = '\0';
+	}
+	if (lockfd != -1)
+		close(lockfd);
+	errno = serrno;
+}
+
+/*
+ * Compares two struct group's.
+ */
+int
+gr_equal(const struct group *gr1, const struct group *gr2)
+{
+
+	/* Check that the non-member information is the same. */
+	if (gr1->gr_name == NULL || gr2->gr_name == NULL) {
+		if (gr1->gr_name != gr2->gr_name)
+			return (false);
+	} else if (strcmp(gr1->gr_name, gr2->gr_name) != 0)
+		return (false);
+	if (gr1->gr_passwd == NULL || gr2->gr_passwd == NULL) {
+		if (gr1->gr_passwd != gr2->gr_passwd)
+			return (false);
+	} else if (strcmp(gr1->gr_passwd, gr2->gr_passwd) != 0)
+		return (false);
+	if (gr1->gr_gid != gr2->gr_gid)
+		return (false);
+
+	/*
+	 * Check all members in both groups.
+	 * getgrnam can return gr_mem with a pointer to NULL.
+	 * gr_dup and gr_add strip out this superfluous NULL, setting
+	 * gr_mem to NULL for no members.
+	*/
+	if (gr1->gr_mem != NULL && gr2->gr_mem != NULL) {
+		int i;
+
+		for (i = 0;
+		    gr1->gr_mem[i] != NULL && gr2->gr_mem[i] != NULL; i++) {
+			if (strcmp(gr1->gr_mem[i], gr2->gr_mem[i]) != 0)
+				return (false);
+		}
+		if (gr1->gr_mem[i] != NULL || gr2->gr_mem[i] != NULL)
+			return (false);
+	} else if (gr1->gr_mem != NULL && gr1->gr_mem[0] != NULL) {
+		return (false);
+	} else if (gr2->gr_mem != NULL && gr2->gr_mem[0] != NULL) {
+		return (false);
+	}
+
+	return (true);
+}
+
+/*
+ * Make a group line out of a struct group.
+ */
+char *
+gr_make(const struct group *gr)
+{
+	const char *group_line_format = "%s:%s:%ju:";
+	const char *sep;
+	char *line;
+	char *p;
+	size_t line_size;
+	int ndx;
+
+	/* Calculate the length of the group line. */
+	line_size = snprintf(NULL, 0, group_line_format, gr->gr_name,
+	    gr->gr_passwd, (uintmax_t)gr->gr_gid) + 1;
+	if (gr->gr_mem != NULL) {
+		for (ndx = 0; gr->gr_mem[ndx] != NULL; ndx++)
+			line_size += strlen(gr->gr_mem[ndx]) + 1;
+		if (ndx > 0)
+			line_size--;
+	}
+
+	/* Create the group line and fill it. */
+	if ((line = p = malloc(line_size)) == NULL)
+		return (NULL);
+	p += sprintf(p, group_line_format, gr->gr_name, gr->gr_passwd,
+	    (uintmax_t)gr->gr_gid);
+	if (gr->gr_mem != NULL) {
+		sep = "";
+		for (ndx = 0; gr->gr_mem[ndx] != NULL; ndx++) {
+			p = stpcpy(p, sep);
+			p = stpcpy(p, gr->gr_mem[ndx]);
+			sep = ",";
+		}
+	}
+
+	return (line);
+}
+
+/*
+ * Duplicate a struct group.
+ */
+struct group *
+gr_dup(const struct group *gr)
+{
+	return (gr_add(gr, NULL));
+}
+/*
+ * Add a new member name to a struct group.
+ */
+struct group *
+gr_add(const struct group *gr, const char *newmember)
+{
+	char *mem;
+	size_t len;
+	int num_mem;
+
+	num_mem = 0;
+	len = grmemlen(gr, newmember, &num_mem);
+	/* Create new group and copy old group into it. */
+	if ((mem = malloc(len)) == NULL)
+		return (NULL);
+	return (grcopy(gr, mem, newmember, num_mem));
+}
+
+/* It is safer to walk the pointers given at gr_mem since there is no
+ * guarantee the gr_mem + strings are contiguous in the given struct group
+ * but compactify the new group into the following form.
+ *
+ * The new struct is laid out like this in memory. The example given is
+ * for a group with two members only.
+ *
+ * {
+ * (char *name)
+ * (char *passwd)
+ * (int gid)
+ * (gr_mem * newgrp + sizeof(struct group) + sizeof(**)) points to gr_mem area
+ * gr_mem area
+ * (member1 *) 
+ * (member2 *)
+ * (NULL)
+ * (name string)
+ * (passwd string)
+ * (member1 string)
+ * (member2 string)
+ * }
+ */
+/*
+ * Copy the contents of a group plus given name to a preallocated group struct
+ */
+static struct group *
+grcopy(const struct group *gr, char *dst, const char *name, int ndx)
+{
+	int i;
+	struct group *newgr;
+
+	newgr = (struct group *)(void *)dst;	/* avoid alignment warning */
+	dst += sizeof(*newgr);
+	if (ndx != 0) {
+		newgr->gr_mem = (char **)(void *)(dst);	/* avoid alignment warning */
+		dst += (ndx + 1) * sizeof(*newgr->gr_mem);
+	} else
+		newgr->gr_mem = NULL;
+	if (gr->gr_name != NULL) {
+		newgr->gr_name = dst;
+		dst = stpcpy(dst, gr->gr_name) + 1;
+	} else
+		newgr->gr_name = NULL;
+	if (gr->gr_passwd != NULL) {
+		newgr->gr_passwd = dst;
+		dst = stpcpy(dst, gr->gr_passwd) + 1;
+	} else
+		newgr->gr_passwd = NULL;
+	newgr->gr_gid = gr->gr_gid;
+	i = 0;
+	/* Original group struct might have a NULL gr_mem */
+	if (gr->gr_mem != NULL) {
+		for (; gr->gr_mem[i] != NULL; i++) {
+			newgr->gr_mem[i] = dst;
+			dst = stpcpy(dst, gr->gr_mem[i]) + 1;
+		}
+	}
+	/* If name is not NULL, newgr->gr_mem is known to be not NULL */
+	if (name != NULL) {
+		newgr->gr_mem[i++] = dst;
+		dst = stpcpy(dst, name) + 1;
+	}
+	/* if newgr->gr_mem is not NULL add NULL marker */
+	if (newgr->gr_mem != NULL)
+		newgr->gr_mem[i] = NULL;
+
+	return (newgr);
+}
+
+/*
+ *  Calculate length of a struct group + given name
+ */
+static size_t
+grmemlen(const struct group *gr, const char *name, int *num_mem)
+{
+	size_t len;
+	int i;
+
+	if (gr == NULL)
+		return (0);
+	/* Calculate size of the group. */
+	len = sizeof(*gr);
+	if (gr->gr_name != NULL)
+		len += strlen(gr->gr_name) + 1;
+	if (gr->gr_passwd != NULL)
+		len += strlen(gr->gr_passwd) + 1;
+	i = 0;
+	if (gr->gr_mem != NULL) {
+		for (; gr->gr_mem[i] != NULL; i++) {
+			len += strlen(gr->gr_mem[i]) + 1;
+			len += sizeof(*gr->gr_mem);
+		}
+	}
+	if (name != NULL) {
+		i++;
+		len += strlen(name) + 1;
+		len += sizeof(*gr->gr_mem);
+	}
+	/* Allow for NULL pointer */
+	if (i != 0)
+		len += sizeof(*gr->gr_mem);
+	*num_mem = i;
+	return(len);
+}
+
+/*
+ * Scan a line and place it into a group structure.
+ */
+static bool
+__gr_scan(char *line, struct group *gr)
+{
+	char *loc;
+	int ndx;
+
+	/* Assign non-member information to structure. */
+	gr->gr_name = line;
+	if ((loc = strchr(line, ':')) == NULL)
+		return (false);
+	*loc = '\0';
+	gr->gr_passwd = loc + 1;
+	if (*gr->gr_passwd == ':')
+		*gr->gr_passwd = '\0';
+	else {
+		if ((loc = strchr(loc + 1, ':')) == NULL)
+			return (false);
+		*loc = '\0';
+	}
+	if (sscanf(loc + 1, "%u", &gr->gr_gid) != 1)
+		return (false);
+
+	/* Assign member information to structure. */
+	if ((loc = strchr(loc + 1, ':')) == NULL)
+		return (false);
+	line = loc + 1;
+	gr->gr_mem = NULL;
+	ndx = 0;
+	do {
+		gr->gr_mem = reallocf(gr->gr_mem, sizeof(*gr->gr_mem) *
+		    (ndx + 1));
+		if (gr->gr_mem == NULL)
+			return (false);
+
+		/* Skip locations without members (i.e., empty string). */
+		do {
+			gr->gr_mem[ndx] = strsep(&line, ",");
+		} while (gr->gr_mem[ndx] != NULL && *gr->gr_mem[ndx] == '\0');
+	} while (gr->gr_mem[ndx++] != NULL);
+
+	return (true);
+}
+
+/*
+ * Create a struct group from a line.
+ */
+struct group *
+gr_scan(const char *line)
+{
+	struct group gr;
+	char *line_copy;
+	struct group *new_gr;
+
+	if ((line_copy = strdup(line)) == NULL)
+		return (NULL);
+	if (!__gr_scan(line_copy, &gr)) {
+		free(line_copy);
+		return (NULL);
+	}
+	new_gr = gr_dup(&gr);
+	free(line_copy);
+	if (gr.gr_mem != NULL)
+		free(gr.gr_mem);
+
+	return (new_gr);
+}
--- a/modules/pam_unix/libutil.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/libutil.h	1697798944.497845192
@@ -0,0 +1,234 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1996  Peter Wemm <peter@FreeBSD.org>.
+ * All rights reserved.
+ * Copyright (c) 2002 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, is permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _LIBUTIL_H_
+#define	_LIBUTIL_H_
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+#include <sys/types.h>
+#include <stdint.h>
+
+#define	PROPERTY_MAX_NAME	64
+#define	PROPERTY_MAX_VALUE	512
+
+/* For properties.c. */
+typedef struct _property {
+	struct _property *next;
+	char	*name;
+	char	*value;
+} *properties;
+
+/* Avoid pulling in all the include files for no need. */
+struct in_addr;
+struct pidfh;
+struct sockaddr;
+struct termios;
+struct winsize;
+
+__BEGIN_DECLS
+char	*auth_getval(const char *_name);
+void	clean_environment(const char * const *_white,
+	    const char * const *_more_white);
+int	expand_number(const char *_buf, uint64_t *_num);
+int	extattr_namespace_to_string(int _attrnamespace, char **_string);
+int	extattr_string_to_namespace(const char *_string, int *_attrnamespace);
+int	flopen(const char *_path, int _flags, ...);
+int	flopenat(int _dirfd, const char *_path, int _flags, ...);
+int	forkpty(int *_amaster, char *_name,
+	    struct termios *_termp, struct winsize *_winp);
+const char *
+	getlocalbase(void);
+void	hexdump(const void *_ptr, int _length, const char *_hdr, int _flags);
+int	humanize_number(char *_buf, size_t _len, int64_t _number,
+	    const char *_suffix, int _scale, int _flags);
+struct kinfo_file *
+	kinfo_getfile(pid_t _pid, int *_cntp);
+struct kinfo_vmentry *
+	kinfo_getvmmap(pid_t _pid, int *_cntp);
+struct kinfo_vmobject *
+	kinfo_getvmobject(int *_cntp);
+struct kinfo_proc *
+	kinfo_getallproc(int *_cntp);
+struct kinfo_proc *
+	kinfo_getproc(pid_t _pid);
+int	kld_isloaded(const char *_name);
+int	kld_load(const char *_name);
+int	login_tty(int _fd);
+int	openpty(int *_amaster, int *_aslave, char *_name,
+	    struct termios *_termp, struct winsize *_winp);
+int	pidfile_close(struct pidfh *_pfh);
+int	pidfile_fileno(const struct pidfh *_pfh);
+struct pidfh *
+	pidfile_open(const char *_path, mode_t _mode, pid_t *_pidptr);
+int	pidfile_remove(struct pidfh *_pfh);
+int	pidfile_write(struct pidfh *_pfh);
+void	properties_free(properties _list);
+char	*property_find(properties _list, const char *_name);
+properties
+	properties_read(int _fd);
+int	realhostname(char *_host, size_t _hsize, const struct in_addr *_ip);
+int	realhostname_sa(char *_host, size_t _hsize, struct sockaddr *_addr,
+	    int _addrlen);
+int	_secure_path(const char *_path, uid_t _uid, gid_t _gid);
+void	trimdomain(char *_fullhost, int _hostsize);
+const char *
+	uu_lockerr(int _uu_lockresult);
+int	uu_lock(const char *_ttyname);
+int	uu_unlock(const char *_ttyname);
+int	uu_lock_txfr(const char *_ttyname, pid_t _pid);
+
+/*
+ * Conditionally prototype the following functions if the include
+ * files upon which they depend have been included.
+ */
+#ifdef _STDIO_H_
+char	*fparseln(FILE *_fp, size_t *_len, size_t *_lineno,
+	    const char _delim[3], int _flags);
+#endif
+
+#ifdef _PWD_H_
+int	pw_copy(int _ffd, int _tfd, const struct passwd *_pw,
+	    struct passwd *_old_pw);
+struct passwd
+	*pw_dup(const struct passwd *_pw);
+int	pw_edit(int _notsetuid);
+int	pw_equal(const struct passwd *_pw1, const struct passwd *_pw2);
+void	pw_fini(void);
+int	pw_init(const char *_dir, const char *_master);
+void	pw_initpwd(struct passwd *_pw);
+char	*pw_make(const struct passwd *_pw);
+char	*pw_make_v7(const struct passwd *_pw);
+int	pw_mkdb(const char *_user);
+int	pw_lock(void);
+struct passwd *
+	pw_scan(const char *_line, int _flags);
+const char *
+	pw_tempname(void);
+int	pw_tmp(int _mfd);
+#endif
+
+#ifdef _GRP_H_
+int 	gr_copy(int __ffd, int _tfd, const struct group *_gr,
+	    struct group *_old_gr);
+struct group *
+	gr_dup(const struct group *_gr);
+struct group *
+	gr_add(const struct group *_gr, const char *_newmember);
+int	gr_equal(const struct group *_gr1, const struct group *_gr2);
+void	gr_fini(void);
+int	gr_init(const char *_dir, const char *_master);
+int	gr_lock(void);
+char	*gr_make(const struct group *_gr);
+int	gr_mkdb(void);
+struct group *
+	gr_scan(const char *_line);
+int	gr_tmp(int _mdf);
+#endif
+
+#ifdef _UFS_UFS_QUOTA_H_
+struct fstab;
+struct quotafile;
+int	quota_check_path(const struct quotafile *_qf, const char *_path);
+void	quota_close(struct quotafile *_qf);
+int	quota_convert(struct quotafile *_qf, int _wordsize);
+const char *
+	quota_fsname(const struct quotafile *_qf);
+int	quota_maxid(struct quotafile *_qf);
+int	quota_off(struct quotafile *_qf);
+int	quota_on(struct quotafile *_qf);
+struct quotafile *
+	quota_open(struct fstab *_fs, int _quotatype, int _openflags);
+const char *
+	quota_qfname(const struct quotafile *_qf);
+int	quota_read(struct quotafile *_qf, struct dqblk *_dqb, int _id);
+int	quota_write_limits(struct quotafile *_qf, struct dqblk *_dqb, int _id);
+int	quota_write_usage(struct quotafile *_qf, struct dqblk *_dqb, int _id);
+#endif
+
+__END_DECLS
+
+/* fparseln(3) */
+#define	FPARSELN_UNESCESC	0x01
+#define	FPARSELN_UNESCCONT	0x02
+#define	FPARSELN_UNESCCOMM	0x04
+#define	FPARSELN_UNESCREST	0x08
+#define	FPARSELN_UNESCALL	0x0f
+
+/* Flags for hexdump(3). */
+#define	HD_COLUMN_MASK		0xff
+#define	HD_DELIM_MASK		0xff00
+#define	HD_OMIT_COUNT		(1 << 16)
+#define	HD_OMIT_HEX		(1 << 17)
+#define	HD_OMIT_CHARS		(1 << 18)
+
+/* Values for humanize_number(3)'s flags parameter. */
+#define	HN_DECIMAL		0x01
+#define	HN_NOSPACE		0x02
+#define	HN_B			0x04
+#define	HN_DIVISOR_1000		0x08
+#define	HN_IEC_PREFIXES		0x10
+
+/* Values for humanize_number(3)'s scale parameter. */
+#define	HN_GETSCALE		0x10
+#define	HN_AUTOSCALE		0x20
+
+/* Return values from realhostname(). */
+#define	HOSTNAME_FOUND		0
+#define	HOSTNAME_INCORRECTNAME	1
+#define	HOSTNAME_INVALIDADDR	2
+#define	HOSTNAME_INVALIDNAME	3
+
+/* Flags for pw_scan(). */
+#define	PWSCAN_MASTER		0x01
+#define	PWSCAN_WARN		0x02
+
+/* Return values from uu_lock(). */
+#define	UU_LOCK_INUSE		1
+#define	UU_LOCK_OK		0
+#define	UU_LOCK_OPEN_ERR	(-1)
+#define	UU_LOCK_READ_ERR	(-2)
+#define	UU_LOCK_CREAT_ERR	(-3)
+#define	UU_LOCK_WRITE_ERR	(-4)
+#define	UU_LOCK_LINK_ERR	(-5)
+#define	UU_LOCK_TRY_ERR		(-6)
+#define	UU_LOCK_OWNER_ERR	(-7)
+
+#endif /* !_LIBUTIL_H_ */
--- a/modules/pam_unix/login_cap.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/login_cap.c	1697798874.765017900
@@ -0,0 +1,823 @@
+/*-
+ * Copyright (c) 1996 by
+ * Sean Eric Fagan <sef@kithrup.com>
+ * David Nugent <davidn@blaze.net.au>
+ * All rights reserved.
+ *
+ * Portions copyright (c) 1995,1997
+ * Berkeley Software Design, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, is permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice immediately at the beginning of the file, without modification,
+ *    this list of conditions, and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. This work was done expressly for inclusion into FreeBSD.  Other use
+ *    is permitted provided this notation is included.
+ * 4. Absolutely no warranty of function or purpose is made by the authors.
+ * 5. Modifications may be freely made to this file providing the above
+ *    conditions are met.
+ *
+ * Low-level routines relating to the user capabilities database
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/param.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <libutil.h>
+#include <login_cap.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#include <os/availability.h>
+API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
+void * reallocarray(void * in_ptr, size_t nmemb, size_t size) __DARWIN_EXTSN(reallocarray) __result_use_check;
+
+/*
+ * allocstr()
+ * Manage a single static pointer for handling a local char* buffer,
+ * resizing as necessary to contain the string.
+ *
+ * allocarray()
+ * Manage a static array for handling a group of strings, resizing
+ * when necessary.
+ */
+
+static int lc_object_count = 0;
+
+static size_t internal_stringsz = 0;
+static char * internal_string = NULL;
+static size_t internal_arraysz = 0;
+static const char ** internal_array = NULL;
+
+static char path_login_conf[] = _PATH_LOGIN_CONF;
+
+static char *
+allocstr(const char *str)
+{
+    char    *p;
+
+    size_t sz = strlen(str) + 1;	/* realloc() only if necessary */
+    if (sz <= internal_stringsz)
+	p = strcpy(internal_string, str);
+    else if ((p = realloc(internal_string, sz)) != NULL) {
+	internal_stringsz = sz;
+	internal_string = strcpy(p, str);
+    }
+    return p;
+}
+
+
+static const char **
+allocarray(size_t sz)
+{
+    static const char    **p;
+
+    if (sz <= internal_arraysz)
+	p = internal_array;
+    else if ((p = reallocarray(internal_array, sz, sizeof(char*))) != NULL) {
+	internal_arraysz = sz;
+	internal_array = p;
+    }
+    return p;
+}
+
+
+/*
+ * arrayize()
+ * Turn a simple string <str> separated by any of
+ * the set of <chars> into an array.  The last element
+ * of the array will be NULL, as is proper.
+ * Free using freearraystr()
+ */
+
+static const char **
+arrayize(const char *str, const char *chars, int *size)
+{
+    int	    i;
+    char *ptr;
+    const char *cptr;
+    const char **res = NULL;
+
+    /* count the sub-strings */
+    for (i = 0, cptr = str; *cptr; i++) {
+	int count = strcspn(cptr, chars);
+	cptr += count;
+	if (*cptr)
+	    ++cptr;
+    }
+
+    /* alloc the array */
+    if ((ptr = allocstr(str)) != NULL) {
+	if ((res = allocarray(++i)) == NULL)
+	    free((void *)(uintptr_t)(const void *)str);
+	else {
+	    /* now split the string */
+	    i = 0;
+	    while (*ptr) {
+		int count = strcspn(ptr, chars);
+		res[i++] = ptr;
+		ptr += count;
+		if (*ptr)
+		    *ptr++ = '\0';
+	    }
+	    res[i] = NULL;
+	}
+    }
+
+    if (size)
+	*size = i;
+
+    return res;
+}
+
+
+/*
+ * login_close()
+ * Frees up all resources relating to a login class
+ *
+ */
+
+void
+login_close(login_cap_t * lc)
+{
+    if (lc) {
+	free(lc->lc_style);
+	free(lc->lc_class);
+	free(lc->lc_cap);
+	free(lc);
+	if (--lc_object_count == 0) {
+	    free(internal_string);
+	    free(internal_array);
+	    internal_array = NULL;
+	    internal_arraysz = 0;
+	    internal_string = NULL;
+	    internal_stringsz = 0;
+	    cgetclose();
+	}
+    }
+}
+
+
+/*
+ * login_getclassbyname()
+ * Get the login class by its name.
+ * If the name given is NULL or empty, the default class
+ * LOGIN_DEFCLASS (i.e., "default") is fetched.
+ * If the name given is LOGIN_MECLASS and
+ * 'pwd' argument is non-NULL and contains an non-NULL
+ * dir entry, then the file _FILE_LOGIN_CONF is picked
+ * up from that directory and used before the system
+ * login database. In that case the system login database
+ * is looked up using LOGIN_MECLASS, too, which is a bug.
+ * Return a filled-out login_cap_t structure, including
+ * class name, and the capability record buffer.
+ */
+
+login_cap_t *
+login_getclassbyname(char const *name, const struct passwd *pwd)
+{
+    login_cap_t	*lc;
+  
+    if ((lc = malloc(sizeof(login_cap_t))) != NULL) {
+	int         r, me, i = 0;
+	uid_t euid = 0;
+	gid_t egid = 0;
+	const char  *msg = NULL;
+	const char  *dir;
+	char	    userpath[MAXPATHLEN];
+
+	static char *login_dbarray[] = { NULL, NULL, NULL };
+
+	me = (name != NULL && strcmp(name, LOGIN_MECLASS) == 0);
+	dir = (!me || pwd == NULL) ? NULL : pwd->pw_dir;
+	/*
+	 * Switch to user mode before checking/reading its ~/.login_conf
+	 * - some NFSes have root read access disabled.
+	 *
+	 * XXX: This fails to configure additional groups.
+	 */
+	if (dir) {
+	    euid = geteuid();
+	    egid = getegid();
+	    (void)setegid(pwd->pw_gid);
+	    (void)seteuid(pwd->pw_uid);
+	}
+
+	if (dir && snprintf(userpath, MAXPATHLEN, "%s/%s", dir,
+			    _FILE_LOGIN_CONF) < MAXPATHLEN) {
+	    if (_secure_path(userpath, pwd->pw_uid, pwd->pw_gid) != -1)
+		login_dbarray[i++] = userpath;
+	}
+	/*
+	 * XXX: Why to add the system database if the class is `me'?
+	 */
+	if (_secure_path(path_login_conf, 0, 0) != -1)
+	    login_dbarray[i++] = path_login_conf;
+	login_dbarray[i] = NULL;
+
+	memset(lc, 0, sizeof(login_cap_t));
+	lc->lc_cap = lc->lc_class = lc->lc_style = NULL;
+
+	if (name == NULL || *name == '\0')
+	    name = LOGIN_DEFCLASS;
+
+	switch (cgetent(&lc->lc_cap, login_dbarray, name)) {
+	case -1:		/* Failed, entry does not exist */
+	    if (me)
+		break;	/* Don't retry default on 'me' */
+	    if (i == 0)
+	        r = -1;
+	    else if ((r = open(login_dbarray[0], O_RDONLY | O_CLOEXEC)) >= 0)
+	        close(r);
+	    /*
+	     * If there's at least one login class database,
+	     * and we aren't searching for a default class
+	     * then complain about a non-existent class.
+	     */
+	    if (r >= 0 || strcmp(name, LOGIN_DEFCLASS) != 0)
+		syslog(LOG_ERR, "login_getclass: unknown class '%s'", name);
+	    /* fall-back to default class */
+	    name = LOGIN_DEFCLASS;
+	    msg = "%s: no default/fallback class '%s'";
+	    if (cgetent(&lc->lc_cap, login_dbarray, name) != 0 && r >= 0)
+		break;
+	    /* FALLTHROUGH - just return system defaults */
+	case 0:		/* success! */
+	    if ((lc->lc_class = strdup(name)) != NULL) {
+		if (dir) {
+		    (void)seteuid(euid);
+		    (void)setegid(egid);
+		}
+		++lc_object_count;
+		return lc;
+	    }
+	    msg = "%s: strdup: %m";
+	    break;
+	case -2:
+	    msg = "%s: retrieving class information: %m";
+	    break;
+	case -3:
+	    msg = "%s: 'tc=' reference loop '%s'";
+	    break;
+	case 1:
+	    msg = "couldn't resolve 'tc=' reference in '%s'";
+	    break;
+	default:
+	    msg = "%s: unexpected cgetent() error '%s': %m";
+	    break;
+	}
+	if (dir) {
+	    (void)seteuid(euid);
+	    (void)setegid(egid);
+	}
+	if (msg != NULL)
+	    syslog(LOG_ERR, msg, "login_getclass", name);
+	free(lc);
+    }
+
+    return NULL;
+}
+
+
+
+/*
+ * login_getclass()
+ * Get the login class for the system (only) login class database.
+ * Return a filled-out login_cap_t structure, including
+ * class name, and the capability record buffer.
+ */
+
+login_cap_t *
+login_getclass(const char *cls)
+{
+    return login_getclassbyname(cls, NULL);
+}
+
+
+/*
+ * login_getpwclass()
+ * Get the login class for a given password entry from
+ * the system (only) login class database.
+ * If the password entry's class field is not set, or
+ * the class specified does not exist, then use the
+ * default of LOGIN_DEFCLASS (i.e., "default") for an unprivileged
+ * user or that of LOGIN_DEFROOTCLASS (i.e., "root") for a super-user.
+ * Return a filled-out login_cap_t structure, including
+ * class name, and the capability record buffer.
+ */
+
+login_cap_t *
+login_getpwclass(const struct passwd *pwd)
+{
+    const char	*cls = NULL;
+
+    if (pwd != NULL) {
+	cls = pwd->pw_class;
+	if (cls == NULL || *cls == '\0')
+	    cls = (pwd->pw_uid == 0) ? LOGIN_DEFROOTCLASS : LOGIN_DEFCLASS;
+    }
+    /*
+     * XXX: pwd should be unused by login_getclassbyname() unless cls is `me',
+     *      so NULL can be passed instead of pwd for more safety.
+     */
+    return login_getclassbyname(cls, pwd);
+}
+
+
+/*
+ * login_getuserclass()
+ * Get the `me' login class, allowing user overrides via ~/.login_conf.
+ * Note that user overrides are allowed only in the `me' class.
+ */
+
+login_cap_t *
+login_getuserclass(const struct passwd *pwd)
+{
+    return login_getclassbyname(LOGIN_MECLASS, pwd);
+}
+
+
+/*
+ * login_getcapstr()
+ * Given a login_cap entry, and a capability name, return the
+ * value defined for that capability, a default if not found, or
+ * an error string on error.
+ */
+
+const char *
+login_getcapstr(login_cap_t *lc, const char *cap, const char *def, const char *error)
+{
+    char    *res;
+    int	    ret;
+
+    if (lc == NULL || cap == NULL || lc->lc_cap == NULL || *cap == '\0')
+	return def;
+
+    if ((ret = cgetstr(lc->lc_cap, cap, &res)) == -1)
+	return def;
+    return (ret >= 0) ? res : error;
+}
+
+
+/*
+ * login_getcaplist()
+ * Given a login_cap entry, and a capability name, return the
+ * value defined for that capability split into an array of
+ * strings.
+ */
+
+const char **
+login_getcaplist(login_cap_t *lc, const char *cap, const char *chars)
+{
+    const char *lstring;
+
+    if (chars == NULL)
+	chars = ", \t";
+    if ((lstring = login_getcapstr(lc, cap, NULL, NULL)) != NULL)
+	return arrayize(lstring, chars, NULL);
+    return NULL;
+}
+
+
+/*
+ * login_getpath()
+ * From the login_cap_t <lc>, get the capability <cap> which is
+ * formatted as either a space or comma delimited list of paths
+ * and append them all into a string and separate by semicolons.
+ * If there is an error of any kind, return <error>.
+ */
+
+const char *
+login_getpath(login_cap_t *lc, const char *cap, const char *error)
+{
+    const char *str;
+    char *ptr;
+    int count;
+
+    str = login_getcapstr(lc, cap, NULL, NULL);
+    if (str == NULL)
+	return error;
+    ptr = __DECONST(char *, str); /* XXXX Yes, very dodgy */
+    while (*ptr) {
+	count = strcspn(ptr, ", \t");
+	ptr += count;
+	if (*ptr)
+	    *ptr++ = ':';
+    }
+    return str;
+}
+
+
+static int
+isinfinite(const char *s)
+{
+    static const char *infs[] = {
+	"infinity",
+	"inf",
+	"unlimited",
+	"unlimit",
+	"-1",
+	NULL
+    };
+    const char **i = &infs[0];
+
+    while (*i != NULL) {
+	if (strcasecmp(s, *i) == 0)
+	    return 1;
+	++i;
+    }
+    return 0;
+}
+
+
+static u_quad_t
+rmultiply(u_quad_t n1, u_quad_t n2)
+{
+    u_quad_t	m, r;
+    int		b1, b2;
+
+    static int bpw = 0;
+
+    /* Handle simple cases */
+    if (n1 == 0 || n2 == 0)
+	return 0;
+    if (n1 == 1)
+	return n2;
+    if (n2 == 1)
+	return n1;
+
+    /*
+     * sizeof() returns number of bytes needed for storage.
+     * This may be different from the actual number of useful bits.
+     */
+    if (!bpw) {
+	bpw = sizeof(u_quad_t) * 8;
+	while (((u_quad_t)1 << (bpw-1)) == 0)
+	    --bpw;
+    }
+
+    /*
+     * First check the magnitude of each number. If the sum of the
+     * magnatude is way to high, reject the number. (If this test
+     * is not done then the first multiply below may overflow.)
+     */
+    for (b1 = bpw; (((u_quad_t)1 << (b1-1)) & n1) == 0; --b1)
+	; 
+    for (b2 = bpw; (((u_quad_t)1 << (b2-1)) & n2) == 0; --b2)
+	; 
+    if (b1 + b2 - 2 > bpw) {
+	errno = ERANGE;
+	return (UQUAD_MAX);
+    }
+
+    /*
+     * Decompose the multiplication to be:
+     * h1 = n1 & ~1
+     * h2 = n2 & ~1
+     * l1 = n1 & 1
+     * l2 = n2 & 1
+     * (h1 + l1) * (h2 + l2)
+     * (h1 * h2) + (h1 * l2) + (l1 * h2) + (l1 * l2)
+     *
+     * Since h1 && h2 do not have the low bit set, we can then say:
+     *
+     * (h1>>1 * h2>>1 * 4) + ...
+     *
+     * So if (h1>>1 * h2>>1) > (1<<(bpw - 2)) then the result will
+     * overflow.
+     *
+     * Finally, if MAX - ((h1 * l2) + (l1 * h2) + (l1 * l2)) < (h1*h2)
+     * then adding in residual amout will cause an overflow.
+     */
+
+    m = (n1 >> 1) * (n2 >> 1);
+    if (m >= ((u_quad_t)1 << (bpw-2))) {
+	errno = ERANGE;
+	return (UQUAD_MAX);
+    }
+    m *= 4;
+
+    r = (n1 & n2 & 1)
+	+ (n2 & 1) * (n1 & ~(u_quad_t)1)
+	+ (n1 & 1) * (n2 & ~(u_quad_t)1);
+
+    if ((u_quad_t)(m + r) < m) {
+	errno = ERANGE;
+	return (UQUAD_MAX);
+    }
+    m += r;
+
+    return (m);
+}
+
+
+/*
+ * login_getcaptime()
+ * From the login_cap_t <lc>, get the capability <cap>, which is
+ * formatted as a time (e.g., "<cap>=10h3m2s").  If <cap> is not
+ * present in <lc>, return <def>; if there is an error of some kind,
+ * return <error>.
+ */
+
+rlim_t
+login_getcaptime(login_cap_t *lc, const char *cap, rlim_t def, rlim_t error)
+{
+    char    *res, *ep, *oval;
+    int	    r;
+    rlim_t  tot;
+
+    errno = 0;
+    if (lc == NULL || lc->lc_cap == NULL)
+	return def;
+
+    /*
+     * Look for <cap> in lc_cap.
+     * If it's not there (-1), return <def>.
+     * If there's an error, return <error>.
+     */
+
+    if ((r = cgetstr(lc->lc_cap, cap, &res)) == -1)
+	return def;
+    else if (r < 0) {
+	errno = ERANGE;
+	return error;
+    }
+
+    /* "inf" and "infinity" are special cases */
+    if (isinfinite(res))
+	return RLIM_INFINITY;
+
+    /*
+     * Now go through the string, turning something like 1h2m3s into
+     * an integral value.  Whee.
+     */
+
+    errno = 0;
+    tot = 0;
+    oval = res;
+    while (*res) {
+	rlim_t tim = strtoq(res, &ep, 0);
+	rlim_t mult = 1;
+
+	if (ep == NULL || ep == res || errno != 0) {
+	invalid:
+	    syslog(LOG_WARNING, "login_getcaptime: class '%s' bad value %s=%s",
+		   lc->lc_class, cap, oval);
+	    errno = ERANGE;
+	    return error;
+	}
+	/* Look for suffixes */
+	switch (*ep++) {
+	case 0:
+	    ep--;
+	    break;	/* end of string */
+	case 's': case 'S':	/* seconds */
+	    break;
+	case 'm': case 'M':	/* minutes */
+	    mult = 60;
+	    break;
+	case 'h': case 'H':	/* hours */
+	    mult = 60L * 60L;
+	    break;
+	case 'd': case 'D':	/* days */
+	    mult = 60L * 60L * 24L;
+	    break;
+	case 'w': case 'W':	/* weeks */
+	    mult = 60L * 60L * 24L * 7L;
+	    break;
+	case 'y': case 'Y':	/* 365-day years */
+	    mult = 60L * 60L * 24L * 365L;
+	    break;
+	default:
+	    goto invalid;
+	}
+	res = ep;
+	tot += rmultiply(tim, mult);
+	if (errno)
+	    goto invalid;
+    }
+
+    return tot;
+}
+
+
+/*
+ * login_getcapnum()
+ * From the login_cap_t <lc>, extract the numerical value <cap>.
+ * If it is not present, return <def> for a default, and return
+ * <error> if there is an error.
+ * Like login_getcaptime(), only it only converts to a number, not
+ * to a time; "infinity" and "inf" are 'special.'
+ */
+
+rlim_t
+login_getcapnum(login_cap_t *lc, const char *cap, rlim_t def, rlim_t error)
+{
+    char    *ep, *res;
+    int	    r;
+    rlim_t  val;
+
+    if (lc == NULL || lc->lc_cap == NULL)
+	return def;
+
+    /*
+     * For BSDI compatibility, try for the tag=<val> first
+     */
+    if ((r = cgetstr(lc->lc_cap, cap, &res)) == -1) {
+	long	lval;
+	/* string capability not present, so try for tag#<val> as numeric */
+	if ((r = cgetnum(lc->lc_cap, cap, &lval)) == -1)
+	    return def; /* Not there, so return default */
+	else if (r >= 0)
+	    return (rlim_t)lval;
+    }
+
+    if (r < 0) {
+	errno = ERANGE;
+	return error;
+    }
+
+    if (isinfinite(res))
+	return RLIM_INFINITY;
+
+    errno = 0;
+    val = strtoq(res, &ep, 0);
+    if (ep == NULL || ep == res || errno != 0) {
+	syslog(LOG_WARNING, "login_getcapnum: class '%s' bad value %s=%s",
+	       lc->lc_class, cap, res);
+	errno = ERANGE;
+	return error;
+    }
+
+    return val;
+}
+
+
+
+/*
+ * login_getcapsize()
+ * From the login_cap_t <lc>, extract the capability <cap>, which is
+ * formatted as a size (e.g., "<cap>=10M"); it can also be "infinity".
+ * If not present, return <def>, or <error> if there is an error of
+ * some sort.
+ */
+
+rlim_t
+login_getcapsize(login_cap_t *lc, const char *cap, rlim_t def, rlim_t error)
+{
+    char    *ep, *res, *oval;
+    int	    r;
+    rlim_t  tot;
+
+    if (lc == NULL || lc->lc_cap == NULL)
+	return def;
+
+    if ((r = cgetstr(lc->lc_cap, cap, &res)) == -1)
+	return def;
+    else if (r < 0) {
+	errno = ERANGE;
+	return error;
+    }
+
+    if (isinfinite(res))
+	return RLIM_INFINITY;
+
+    errno = 0;
+    tot = 0;
+    oval = res;
+    while (*res) {
+	rlim_t siz = strtoq(res, &ep, 0);
+	rlim_t mult = 1;
+
+	if (ep == NULL || ep == res || errno != 0) {
+	invalid:
+	    syslog(LOG_WARNING, "login_getcapsize: class '%s' bad value %s=%s",
+		   lc->lc_class, cap, oval);
+	    errno = ERANGE;
+	    return error;
+	}
+	switch (*ep++) {
+	case 0:	/* end of string */
+	    ep--;
+	    break;
+	case 'b': case 'B':	/* 512-byte blocks */
+	    mult = 512;
+	    break;
+	case 'k': case 'K':	/* 1024-byte Kilobytes */
+	    mult = 1024;
+	    break;
+	case 'm': case 'M':	/* 1024-k kbytes */
+	    mult = 1024 * 1024;
+	    break;
+	case 'g': case 'G':	/* 1Gbyte */
+	    mult = 1024 * 1024 * 1024;
+	    break;
+	case 't': case 'T':	/* 1TBte */
+	    mult = 1024LL * 1024LL * 1024LL * 1024LL;
+	    break;
+	default:
+	    goto invalid;
+	}
+	res = ep;
+	tot += rmultiply(siz, mult);
+	if (errno)
+	    goto invalid;
+    }
+
+    return tot;
+}
+
+
+/*
+ * login_getcapbool()
+ * From the login_cap_t <lc>, check for the existence of the capability
+ * of <cap>.  Return <def> if <lc>->lc_cap is NULL, otherwise return
+ * the whether or not <cap> exists there.
+ */
+
+int
+login_getcapbool(login_cap_t *lc, const char *cap, int def)
+{
+    if (lc == NULL || lc->lc_cap == NULL)
+	return def;
+    return (cgetcap(lc->lc_cap, cap, ':') != NULL);
+}
+
+
+/*
+ * login_getstyle()
+ * Given a login_cap entry <lc>, and optionally a type of auth <auth>,
+ * and optionally a style <style>, find the style that best suits these
+ * rules:
+ *	1.  If <auth> is non-null, look for an "auth-<auth>=" string
+ *	in the capability; if not present, default to "auth=".
+ *	2.  If there is no auth list found from (1), default to
+ *	"passwd" as an authorization list.
+ *	3.  If <style> is non-null, look for <style> in the list of
+ *	authorization methods found from (2); if <style> is NULL, default
+ *	to LOGIN_DEFSTYLE ("passwd").
+ *	4.  If the chosen style is found in the chosen list of authorization
+ *	methods, return that; otherwise, return NULL.
+ * E.g.:
+ *     login_getstyle(lc, NULL, "ftp");
+ *     login_getstyle(lc, "login", NULL);
+ *     login_getstyle(lc, "skey", "network");
+ */
+
+const char *
+login_getstyle(login_cap_t *lc, const char *style, const char *auth)
+{
+    int	    i;
+    const char **authtypes = NULL;
+    char    *auths= NULL;
+    char    realauth[64];
+
+    static const char *defauthtypes[] = { LOGIN_DEFSTYLE, NULL };
+
+    if (auth != NULL && *auth != '\0') {
+	if (snprintf(realauth, sizeof realauth, "auth-%s", auth) < (int)sizeof(realauth))
+	    authtypes = login_getcaplist(lc, realauth, NULL);
+    }
+
+    if (authtypes == NULL)
+	authtypes = login_getcaplist(lc, "auth", NULL);
+
+    if (authtypes == NULL)
+	authtypes = defauthtypes;
+
+    /*
+     * We have at least one authtype now; auths is a comma-separated
+     * (or space-separated) list of authentication types.  We have to
+     * convert from this to an array of char*'s; authtypes then gets this.
+     */
+    i = 0;
+    if (style != NULL && *style != '\0') {
+	while (authtypes[i] != NULL && strcmp(style, authtypes[i]) != 0)
+	    i++;
+    }
+
+    lc->lc_style = NULL;
+    if (authtypes[i] != NULL && (auths = strdup(authtypes[i])) != NULL)
+	lc->lc_style = auths;
+
+    if (lc->lc_style != NULL)
+	lc->lc_style = strdup(lc->lc_style);
+
+    return lc->lc_style;
+}
--- a/modules/pam_unix/login_cap.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/login_cap.h	1697798952.794150888
@@ -0,0 +1,164 @@
+/*-
+ * Copyright (c) 1996 by
+ * Sean Eric Fagan <sef@kithrup.com>
+ * David Nugent <davidn@blaze.net.au>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, is permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice immediately at the beginning of the file, without modification,
+ *    this list of conditions, and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. This work was done expressly for inclusion into FreeBSD.  Other use
+ *    is permitted provided this notation is included.
+ * 4. Absolutely no warranty of function or purpose is made by the authors.
+ * 5. Modifications may be freely made to this file providing the above
+ *    conditions are met.
+ *
+ * Low-level routines relating to the user capabilities database
+ *
+ *	Was login_cap.h,v 1.9 1997/05/07 20:00:01 eivind Exp
+ * $FreeBSD$
+ */
+
+#ifndef _LOGIN_CAP_H_
+#define _LOGIN_CAP_H_
+
+#define LOGIN_DEFCLASS		"default"
+#define LOGIN_DEFROOTCLASS	"root"
+#define LOGIN_MECLASS		"me"
+#define LOGIN_DEFSTYLE		"passwd"
+#define LOGIN_DEFSERVICE	"login"
+#define LOGIN_DEFUMASK		022
+#define LOGIN_DEFPRI		0
+#define _PATH_LOGIN_CONF	"/etc/login.conf"
+#define _FILE_LOGIN_CONF	".login_conf"
+#define _PATH_AUTHPROG		"/usr/libexec/login_"
+
+#define LOGIN_SETGROUP		0x0001		/* set group */
+#define LOGIN_SETLOGIN		0x0002		/* set login (via setlogin) */
+#define LOGIN_SETPATH		0x0004		/* set path */
+#define LOGIN_SETPRIORITY	0x0008		/* set priority */
+#define LOGIN_SETRESOURCES	0x0010		/* set resources (cputime, etc.) */
+#define LOGIN_SETUMASK		0x0020		/* set umask, obviously */
+#define LOGIN_SETUSER		0x0040		/* set user (via setuid) */
+#define LOGIN_SETENV		0x0080		/* set user environment */
+#define LOGIN_SETMAC		0x0100		/* set user default MAC label */
+#define LOGIN_SETCPUMASK	0x0200		/* set user cpumask */
+#define LOGIN_SETLOGINCLASS	0x0400		/* set login class in the kernel */
+#define LOGIN_SETALL		0x07ff		/* set everything */
+
+#define BI_AUTH		"authorize"		/* accepted authentication */
+#define BI_REJECT	"reject"		/* rejected authentication */
+#define BI_CHALLENG	"reject challenge"	/* reject with a challenge */
+#define BI_SILENT	"reject silent"		/* reject silently */
+#define BI_REMOVE	"remove"		/* remove file on error */
+#define BI_ROOTOKAY	"authorize root"	/* root authenticated */
+#define BI_SECURE	"authorize secure"	/* okay on non-secure line */
+#define BI_SETENV	"setenv"		/* set environment variable */
+#define BI_VALUE	"value"			/* set local variable */
+
+#define AUTH_OKAY		0x01		/* user authenticated */
+#define AUTH_ROOTOKAY		0x02		/* root login okay */
+#define AUTH_SECURE		0x04		/* secure login */
+#define AUTH_SILENT		0x08		/* silent rejection */
+#define AUTH_CHALLENGE		0x10		/* a chellenge was given */
+
+#define AUTH_ALLOW		(AUTH_OKAY | AUTH_ROOTOKAY | AUTH_SECURE)
+
+typedef struct login_cap {
+    char    *lc_class;
+    char    *lc_cap;
+    char    *lc_style;
+} login_cap_t;
+
+typedef struct login_time {
+    u_short     lt_start;	/* Start time */
+    u_short     lt_end;		/* End time */
+#define LTM_NONE  0x00
+#define LTM_SUN   0x01
+#define LTM_MON   0x02
+#define LTM_TUE   0x04
+#define LTM_WED   0x08
+#define LTM_THU   0x10
+#define LTM_FRI   0x20
+#define LTM_SAT   0x40
+#define LTM_ANY   0x7F
+#define LTM_WK    0x3E
+#define LTM_WD    0x41
+    u_char	 lt_dow;	/* Days of week */
+} login_time_t;
+
+#define LC_MAXTIMES 64
+
+#include <sys/cdefs.h>
+__BEGIN_DECLS
+struct passwd;
+
+void login_close(login_cap_t *);
+login_cap_t *login_getclassbyname(const char *, const struct passwd *);
+login_cap_t *login_getclass(const char *);
+login_cap_t *login_getpwclass(const struct passwd *);
+login_cap_t *login_getuserclass(const struct passwd *);
+
+const char *login_getcapstr(login_cap_t *, const char *, const char *,
+    const char *);
+const char **login_getcaplist(login_cap_t *, const char *, const char *);
+const char *login_getstyle(login_cap_t *, const char *, const char *);
+const char *login_getpath(login_cap_t *, const char *, const char *);
+int login_getcapbool(login_cap_t *, const char *, int);
+const char *login_setcryptfmt(login_cap_t *, const char *, const char *);
+
+int setclasscontext(const char *, unsigned int);
+void setclasscpumask(login_cap_t *);
+int setusercontext(login_cap_t *, const struct passwd *, uid_t, unsigned int);
+void setclassresources(login_cap_t *);
+void setclassenvironment(login_cap_t *, const struct passwd *, int);
+
+/* Most of these functions are deprecated */
+int auth_approve(login_cap_t *, const char *, const char *);
+int auth_check(const char *, const char *, const char *, const char *, int *);
+void auth_env(void);
+char *auth_mkvalue(const char *);
+int auth_response(const char *, const char *, const char *, const char *, int *,
+    const char *, const char *);
+void auth_rmfiles(void);
+int auth_scan(int);
+int auth_script(const char *, ...);
+int auth_script_data(const char *, int, const char *, ...);
+char *auth_valud(const char *);
+int auth_setopt(const char *, const char *);
+void auth_clropts(void);
+
+void auth_checknologin(login_cap_t *);
+int auth_cat(const char *);
+
+int auth_ttyok(login_cap_t *, const char *);
+int auth_hostok(login_cap_t *, const char *, char const *);
+int auth_timeok(login_cap_t *, time_t);
+
+struct tm;
+
+login_time_t parse_lt(const char *);
+int in_lt(const login_time_t *, time_t *);
+int in_ltm(const login_time_t *, struct tm *, time_t *);
+int in_ltms(const login_time_t *, struct tm *, time_t *);
+int in_lts(const login_time_t *, time_t *);
+
+/* helper functions */
+
+int login_strinlist(const char **, char const *, int);
+int login_str2inlist(const char **, const char *, const char *, int);
+login_time_t * login_timelist(login_cap_t *, char const *, int *,
+    login_time_t **);
+int login_ttyok(login_cap_t *, const char *, const char *, const char *);
+int login_hostok(login_cap_t *, const char *, const char *, const char *,
+    const char *);
+
+__END_DECLS
+
+#endif /* _LOGIN_CAP_H_ */
--- a/modules/pam_unix/login_crypt.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/login_crypt.c	1697798879.170978143
@@ -0,0 +1,50 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2000 Brian Fundakowski Feldman
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+
+#include <login_cap.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+const char *
+login_setcryptfmt(login_cap_t *lc, const char *def, const char *error) {
+	const char *cipher;
+
+	cipher = login_getcapstr(lc, "passwd_format", def, NULL);
+	if (getenv("CRYPT_DEBUG") != NULL)
+		fprintf(stderr, "login_setcryptfmt: "
+		    "passwd_format = %s\n", cipher);
+	if (cipher == NULL)
+		return (error);
+	return (cipher);
+}
--- a/modules/pam_unix/pam_unix.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/pam_unix.c	1697815185.250040959
@@ -0,0 +1,503 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright 1998 Juniper Networks, Inc.
+ * All rights reserved.
+ * Copyright (c) 2002-2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software was developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <login_cap.h>
+#include <netdb.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <syslog.h>
+#include <time.h>
+#include <unistd.h>
+
+#include <libutil.h>
+
+#ifdef YP
+#include <ypclnt.h>
+#endif
+
+#define PAM_SM_AUTH
+#define PAM_SM_ACCOUNT
+#define	PAM_SM_PASSWORD
+
+#include <security/pam_appl.h>
+#include <security/pam_modules.h>
+
+#if __APPLE__
+#include "Logging.h"
+PAM_DEFINE_LOG(unix)
+#define PAM_LOG PAM_LOG_unix()
+#define PAM_LOG_DEBUG(...) \
+	os_log_debug(PAM_LOG, __VA_ARGS__)
+#define PAM_VERBOSE_ERROR(...) \
+	os_log_error(PAM_LOG, __VA_ARGS__)
+#define PAM_OPT_NULLOK		"nullok"
+#define PAM_OPT_EMPTYOK		"emptyok"
+#define PAM_OPT_AUTH_AS_SELF	"auth_as_self"
+#define PAM_OPT_ECHO_PASS	"echo_pass"
+#define PAM_OPT_DEBUG		"debug"
+#endif
+
+#define PASSWORD_HASH		"sha512"
+#define DEFAULT_WARN		(2L * 7L * 86400L)  /* Two weeks */
+#define	SALTSIZE		32
+
+#define	LOCKED_PREFIX		"*LOCKED*"
+#define	LOCKED_PREFIX_LEN	(sizeof(LOCKED_PREFIX) - 1)
+
+static void makesalt(char [SALTSIZE + 1]);
+
+static char password_hash[] =		PASSWORD_HASH;
+
+#define PAM_OPT_LOCAL_PASS	"local_pass"
+#define PAM_OPT_NIS_PASS	"nis_pass"
+
+static char *saltchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./";
+
+/*
+ * authentication management
+ */
+PAM_EXTERN int
+pam_sm_authenticate(pam_handle_t *pamh, int flags,
+    int argc __unused, const char *argv[] __unused)
+{
+	login_cap_t *lc;
+	struct passwd *pwd;
+	int retval;
+	const char *pass, *user, *realpw, *prompt;
+	const char *emptypasswd = "";
+
+	if (openpam_get_option(pamh, PAM_OPT_AUTH_AS_SELF)) {
+		user = getlogin();
+	} else {
+		retval = pam_get_user(pamh, &user, NULL);
+		if (retval != PAM_SUCCESS)
+			return (retval);
+	}
+	pwd = getpwnam(user);
+
+	PAM_LOG_DEBUG("Got user: %s", user);
+
+	if (pwd != NULL) {
+		PAM_LOG_DEBUG("Doing real authentication");
+		realpw = pwd->pw_passwd;
+		if (realpw[0] == '\0') {
+			if (!(flags & PAM_DISALLOW_NULL_AUTHTOK) &&
+			    openpam_get_option(pamh, PAM_OPT_NULLOK))
+				return (PAM_SUCCESS);
+			PAM_LOG_DEBUG("Password is empty, using fake password");
+			realpw = "*";
+		}
+		/*
+		 * Check whether the saved password hash matches the one
+		 * generated from an empty password - as opposed to empty
+		 * saved password hash, which is handled above.
+		 */
+		if (!(flags & PAM_DISALLOW_NULL_AUTHTOK) &&
+		    openpam_get_option(pamh, PAM_OPT_EMPTYOK) &&
+		    strcmp(crypt(emptypasswd, realpw), realpw) == 0)
+			return (PAM_SUCCESS);
+		lc = login_getpwclass(pwd);
+	} else {
+		PAM_LOG_DEBUG("Doing dummy authentication");
+		realpw = "*";
+		lc = login_getclass(NULL);
+	}
+	prompt = login_getcapstr(lc, "passwd_prompt", NULL, NULL);
+	retval = pam_get_authtok(pamh, PAM_AUTHTOK, &pass, prompt);
+	login_close(lc);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+	PAM_LOG_DEBUG("Got password");
+	if (strnlen(pass, _PASSWORD_LEN + 1) > _PASSWORD_LEN) {
+		PAM_LOG_DEBUG("Password is too long, using fake password");
+		realpw = "*";
+	}
+	if (strcmp(crypt(pass, realpw), realpw) == 0)
+		return (PAM_SUCCESS);
+
+	PAM_VERBOSE_ERROR("UNIX authentication refused");
+	return (PAM_AUTH_ERR);
+}
+
+PAM_EXTERN int
+pam_sm_setcred(pam_handle_t *pamh __unused, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+
+	return (PAM_SUCCESS);
+}
+
+/*
+ * account management
+ */
+PAM_EXTERN int
+pam_sm_acct_mgmt(pam_handle_t *pamh, int flags __unused,
+    int argc __unused, const char *argv[] __unused)
+{
+	struct addrinfo hints, *res;
+	struct passwd *pwd;
+	struct timeval tp;
+	login_cap_t *lc;
+	time_t warntime;
+	int retval;
+	const char *user;
+	const void *rhost, *tty;
+	char rhostip[MAXHOSTNAMELEN] = "";
+
+	retval = pam_get_user(pamh, &user, NULL);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	if (user == NULL || (pwd = getpwnam(user)) == NULL)
+		return (PAM_SERVICE_ERR);
+
+	PAM_LOG_DEBUG("Got user: %s", user);
+
+	retval = pam_get_item(pamh, PAM_RHOST, &rhost);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	retval = pam_get_item(pamh, PAM_TTY, &tty);
+	if (retval != PAM_SUCCESS)
+		return (retval);
+
+	if (*pwd->pw_passwd == '\0' &&
+	    (flags & PAM_DISALLOW_NULL_AUTHTOK) != 0)
+		return (PAM_NEW_AUTHTOK_REQD);
+
+	if (strncmp(pwd->pw_passwd, LOCKED_PREFIX, LOCKED_PREFIX_LEN) == 0)
+		return (PAM_AUTH_ERR);
+
+	lc = login_getpwclass(pwd);
+	if (lc == NULL) {
+		PAM_LOG_DEBUG("Unable to get login class for user %s", user);
+		return (PAM_SERVICE_ERR);
+	}
+
+	PAM_LOG_DEBUG("Got login_cap");
+
+	if (pwd->pw_change || pwd->pw_expire)
+		gettimeofday(&tp, NULL);
+
+	/*
+	 * Check pw_expire before pw_change - no point in letting the
+	 * user change the password on an expired account.
+	 */
+
+	if (pwd->pw_expire) {
+		warntime = 1209600;
+		if (tp.tv_sec >= pwd->pw_expire) {
+			login_close(lc);
+			return (PAM_ACCT_EXPIRED);
+		} else if (pwd->pw_expire - tp.tv_sec < warntime &&
+		    (flags & PAM_SILENT) == 0) {
+			pam_error(pamh, "Warning: your account expires on %s",
+			    ctime(&pwd->pw_expire));
+		}
+	}
+
+	retval = PAM_SUCCESS;
+	if (pwd->pw_change) {
+		warntime = 1209600;
+		if (tp.tv_sec >= pwd->pw_change) {
+			retval = PAM_NEW_AUTHTOK_REQD;
+		} else if (pwd->pw_change - tp.tv_sec < warntime &&
+		    (flags & PAM_SILENT) == 0) {
+			pam_error(pamh, "Warning: your password expires on %s",
+			    ctime(&pwd->pw_change));
+		}
+	}
+
+	/*
+	 * From here on, we must leave retval untouched (unless we
+	 * know we're going to fail), because we need to remember
+	 * whether we're supposed to return PAM_SUCCESS or
+	 * PAM_NEW_AUTHTOK_REQD.
+	 */
+
+	if (rhost && *(const char *)rhost != '\0') {
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_family = AF_UNSPEC;
+		if (getaddrinfo(rhost, NULL, &hints, &res) == 0) {
+			getnameinfo(res->ai_addr, res->ai_addrlen,
+			    rhostip, sizeof(rhostip), NULL, 0,
+			    NI_NUMERICHOST);
+		}
+		if (res != NULL)
+			freeaddrinfo(res);
+	}
+
+	login_close(lc);
+
+	return (retval);
+}
+
+/*
+ * password management
+ *
+ * standard Unix and NIS password changing
+ */
+PAM_EXTERN int
+pam_sm_chauthtok(pam_handle_t *pamh, int flags,
+    int argc __unused, const char *argv[] __unused)
+{
+#ifdef YP
+	struct ypclnt *ypclnt;
+	const void *yp_domain, *yp_server;
+#endif
+	char salt[SALTSIZE + 1];
+	login_cap_t *lc;
+	struct passwd *pwd, *old_pwd;
+	const char *user, *old_pass, *new_pass;
+	char *encrypted;
+	time_t passwordtime;
+	int pfd, tfd, retval;
+
+	if (openpam_get_option(pamh, PAM_OPT_AUTH_AS_SELF))
+		user = getlogin();
+	else {
+		retval = pam_get_user(pamh, &user, NULL);
+		if (retval != PAM_SUCCESS)
+			return (retval);
+	}
+	pwd = getpwnam(user);
+
+	if (pwd == NULL)
+		return (PAM_AUTHTOK_RECOVERY_ERR);
+
+	PAM_LOG_DEBUG("Got user: %s", user);
+
+	if (flags & PAM_PRELIM_CHECK) {
+
+		PAM_LOG_DEBUG("PRELIM round");
+
+		if (getuid() == 0)
+			/* root doesn't need the old password */
+			return (pam_set_item(pamh, PAM_OLDAUTHTOK, ""));
+#ifdef YP
+		if (getuid() == 0) {
+
+			yp_domain = yp_server = NULL;
+			(void)pam_get_data(pamh, "yp_domain", &yp_domain);
+			(void)pam_get_data(pamh, "yp_server", &yp_server);
+
+			ypclnt = ypclnt_new(yp_domain, "passwd.byname", yp_server);
+			if (ypclnt == NULL)
+				return (PAM_BUF_ERR);
+
+			if (ypclnt_connect(ypclnt) == -1) {
+				ypclnt_free(ypclnt);
+				return (PAM_SERVICE_ERR);
+			}
+
+			retval = ypclnt_havepasswdd(ypclnt);
+			ypclnt_free(ypclnt);
+			if (retval == 1)
+				return (pam_set_item(pamh, PAM_OLDAUTHTOK, ""));
+			else if (retval == -1)
+				return (PAM_SERVICE_ERR);
+		}
+#endif
+		if (pwd->pw_passwd[0] == '\0'
+		    && openpam_get_option(pamh, PAM_OPT_NULLOK)) {
+			/*
+			 * No password case. XXX Are we giving too much away
+			 * by not prompting for a password?
+			 * XXX check PAM_DISALLOW_NULL_AUTHTOK
+			 */
+			old_pass = "";
+			retval = PAM_SUCCESS;
+		} else {
+			retval = pam_get_authtok(pamh,
+			    PAM_OLDAUTHTOK, &old_pass, NULL);
+			if (retval != PAM_SUCCESS)
+				return (retval);
+		}
+		PAM_LOG_DEBUG("Got old password");
+		/* always encrypt first */
+		encrypted = crypt(old_pass, pwd->pw_passwd);
+		if (old_pass[0] == '\0' &&
+		    !openpam_get_option(pamh, PAM_OPT_NULLOK))
+			return (PAM_PERM_DENIED);
+		if (strcmp(encrypted, pwd->pw_passwd) != 0)
+			return (PAM_PERM_DENIED);
+	}
+	else if (flags & PAM_UPDATE_AUTHTOK) {
+		PAM_LOG_DEBUG("UPDATE round");
+
+/* Torrekie: pam_get_authtok(PAM_OLDAUTHTOK) ignores previous pam_set_item(PAM_OLDAUTHTOK) */
+#if !__APPLE__
+		retval = pam_get_authtok(pamh,
+		    PAM_OLDAUTHTOK, &old_pass, NULL);
+		if (retval != PAM_SUCCESS)
+			return (retval);
+		PAM_LOG_DEBUG("Got old password");
+#endif
+		/* get new password */
+		for (;;) {
+			retval = pam_get_authtok(pamh,
+			    PAM_AUTHTOK, &new_pass, NULL);
+			if (retval != PAM_TRY_AGAIN)
+				break;
+			pam_error(pamh, "Mismatch; try again, EOF to quit.");
+		}
+		PAM_LOG_DEBUG("Got new password");
+		if (retval != PAM_SUCCESS) {
+			PAM_VERBOSE_ERROR("Unable to get new password");
+			return (retval);
+		}
+
+		if (getuid() != 0 && new_pass[0] == '\0' &&
+		    !openpam_get_option(pamh, PAM_OPT_NULLOK))
+			return (PAM_PERM_DENIED);
+
+		if ((old_pwd = pw_dup(pwd)) == NULL)
+			return (PAM_BUF_ERR);
+
+		lc = login_getclass(pwd->pw_class);
+		if (login_setcryptfmt(lc, password_hash, NULL) == NULL)
+			openpam_log(PAM_LOG_ERROR,
+			    "can't set password cipher, relying on default");
+		
+		/* set password expiry date */
+		pwd->pw_change = 0;
+#ifndef __APPLE__
+		passwordtime = login_getcaptime(lc, "passwordtime", 0, 0);
+		if (passwordtime > 0)
+			pwd->pw_change = time(NULL) + passwordtime;
+#endif /* !__APPLE__ */
+		
+		login_close(lc);
+//		pwd->pw_passwd = crypt(new_pass, crypt_gensalt("$6$", 0, saltchars, strlen(saltchars)));
+		makesalt(salt);
+		pwd->pw_passwd = crypt(new_pass, salt);
+#ifdef YP
+		switch (old_pwd->pw_fields & _PWF_SOURCE) {
+		case _PWF_FILES:
+#endif
+			retval = PAM_SERVICE_ERR;
+			if (pw_init(NULL, NULL))
+				openpam_log(PAM_LOG_ERROR, "pw_init() failed");
+			else if ((pfd = pw_lock()) == -1)
+				openpam_log(PAM_LOG_ERROR, "pw_lock() failed");
+			else if ((tfd = pw_tmp(-1)) == -1)
+				openpam_log(PAM_LOG_ERROR, "pw_tmp() failed");
+			else if (pw_copy(pfd, tfd, pwd, old_pwd) == -1)
+				openpam_log(PAM_LOG_ERROR, "pw_copy() failed");
+			else if (pw_mkdb(pwd->pw_name) == -1)
+				openpam_log(PAM_LOG_ERROR, "pw_mkdb() failed");
+			else
+				retval = PAM_SUCCESS;
+			pw_fini();
+#ifdef YP
+			break;
+		case _PWF_NIS:
+			yp_domain = yp_server = NULL;
+			(void)pam_get_data(pamh, "yp_domain", &yp_domain);
+			(void)pam_get_data(pamh, "yp_server", &yp_server);
+			ypclnt = ypclnt_new(yp_domain,
+			    "passwd.byname", yp_server);
+			if (ypclnt == NULL) {
+				retval = PAM_BUF_ERR;
+			} else if (ypclnt_connect(ypclnt) == -1 ||
+			    ypclnt_passwd(ypclnt, pwd, old_pass) == -1) {
+				openpam_log(PAM_LOG_ERROR, "%s", ypclnt->error);
+				retval = PAM_SERVICE_ERR;
+			} else {
+				retval = PAM_SUCCESS;
+			}
+			ypclnt_free(ypclnt);
+			break;
+		default:
+			openpam_log(PAM_LOG_ERROR, "unsupported source 0x%x",
+			    pwd->pw_fields & _PWF_SOURCE);
+			retval = PAM_SERVICE_ERR;
+		}
+#endif
+		free(old_pwd);
+	}
+	else {
+		/* Very bad juju */
+		retval = PAM_ABORT;
+		PAM_LOG_DEBUG("Illegal 'flags'");
+	}
+
+	return (retval);
+}
+
+/* Mostly stolen from passwd(1)'s local_passwd.c - markm */
+
+static unsigned char itoa64[] =		/* 0 ... 63 => ascii - 64 */
+	"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
+
+static void
+to64(char *s, long v, int n)
+{
+	while (--n >= 0) {
+		*s++ = itoa64[v&0x3f];
+		v >>= 6;
+	}
+}
+
+/* Salt suitable for traditional DES and MD5 */
+static void
+makesalt(char salt[SALTSIZE + 1])
+{
+	int i;
+
+	/* These are not really random numbers, they are just
+	 * numbers that change to thwart construction of a
+	 * dictionary.
+	 */
+	for (i = 0; i < SALTSIZE; i += 4)
+		to64(&salt[i], arc4random(), 4);
+	salt[SALTSIZE] = '\0';
+}
+
+PAM_MODULE_ENTRY("pam_unix");
--- a/modules/pam_unix/pw_scan.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/pw_scan.c	1697799602.726859832
@@ -0,0 +1,207 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__SCCSID("@(#)pw_scan.c	8.3 (Berkeley) 4/2/94");
+__FBSDID("$FreeBSD$");
+
+/*
+ * This module is used to "verify" password entries by chpass(1) and
+ * pwd_mkdb(8).
+ */
+
+#include <sys/param.h>
+
+#include <err.h>
+#include <errno.h>
+#include <pwd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "pw_scan.h"
+
+/*
+ * Some software assumes that IDs are short.  We should emit warnings
+ * for id's which cannot be stored in a short, but we are more liberal
+ * by default, warning for IDs greater than USHRT_MAX.
+ *
+ * If pw_big_ids_warning is -1 on entry to pw_scan(), it will be set based
+ * on the existence of PW_SCAN_BIG_IDS in the environment.
+ *
+ * It is believed all baseline system software that can not handle the
+ * normal ID sizes is now gone so pw_big_ids_warning is disabled for now.
+ * But the code has been left in place in case end-users want to re-enable
+ * it and/or for the next time the ID sizes get bigger but pieces of the
+ * system lag behind.
+ */
+static int	pw_big_ids_warning = 0;
+
+void
+__pw_initpwd(struct passwd *pwd)
+{
+	static char nul[] = "";
+
+	memset(pwd, 0, sizeof(*pwd));
+	pwd->pw_uid = (uid_t)-1;  /* Considered least likely to lead to */
+	pwd->pw_gid = (gid_t)-1;  /* a security issue.                  */
+	pwd->pw_name = nul;
+	pwd->pw_passwd = nul;
+	pwd->pw_class = nul;
+	pwd->pw_gecos = nul;
+	pwd->pw_dir = nul;
+	pwd->pw_shell = nul;
+}
+
+int
+__pw_scan(char *bp, struct passwd *pw, int flags)
+{
+	uid_t id;
+	int root;
+	char *ep, *p, *sh;
+	unsigned long temp;
+
+	if (pw_big_ids_warning == -1)
+		pw_big_ids_warning = getenv("PW_SCAN_BIG_IDS") == NULL ? 1 : 0;
+
+	if (!(pw->pw_name = strsep(&bp, ":")))		/* login */
+		goto fmt;
+	root = !strcmp(pw->pw_name, "root");
+
+	if (!(pw->pw_passwd = strsep(&bp, ":")))	/* passwd */
+		goto fmt;
+
+	if (!(p = strsep(&bp, ":")))			/* uid */
+		goto fmt;
+	if (p[0]) {
+	} else {
+		if (pw->pw_name[0] != '+' && pw->pw_name[0] != '-') {
+			if (flags & _PWSCAN_WARN)
+				warnx("no uid for user %s", pw->pw_name);
+			return (0);
+		}
+	}
+	errno = 0;
+	temp = strtoul(p, &ep, 10);
+	if ((temp == ULONG_MAX && errno == ERANGE) || temp > UID_MAX) {
+		if (flags & _PWSCAN_WARN)
+			warnx("%s > max uid value (%u)", p, UID_MAX);
+		return (0);
+	}
+	id = temp;
+	if (*ep != '\0') {
+		if (flags & _PWSCAN_WARN)
+			warnx("%s uid is incorrect", p);
+		return (0);
+	}
+	if (root && id) {
+		if (flags & _PWSCAN_WARN)
+			warnx("root uid should be 0");
+		return (0);
+	}
+	if (flags & _PWSCAN_WARN && pw_big_ids_warning && id > USHRT_MAX) {
+		warnx("%s > recommended max uid value (%u)", p, USHRT_MAX);
+		/*return (0);*/ /* THIS SHOULD NOT BE FATAL! */
+	}
+	pw->pw_uid = id;
+
+	if (!(p = strsep(&bp, ":")))			/* gid */
+		goto fmt;
+	if (p[0]) {
+	} else {
+		if (pw->pw_name[0] != '+' && pw->pw_name[0] != '-') {
+			if (flags & _PWSCAN_WARN)
+				warnx("no gid for user %s", pw->pw_name);
+			return (0);
+		}
+	}
+	errno = 0;
+	temp = strtoul(p, &ep, 10);
+	if ((temp == ULONG_MAX && errno == ERANGE) || temp > GID_MAX) {
+		if (flags & _PWSCAN_WARN)
+			warnx("%s > max gid value (%u)", p, GID_MAX);
+		return (0);
+	}
+	id = temp;
+	if (*ep != '\0') {
+		if (flags & _PWSCAN_WARN)
+			warnx("%s gid is incorrect", p);
+		return (0);
+	}
+	if (flags & _PWSCAN_WARN && pw_big_ids_warning && id > USHRT_MAX) {
+		warnx("%s > recommended max gid value (%u)", p, USHRT_MAX);
+		/* return (0); This should not be fatal! */
+	}
+	pw->pw_gid = id;
+
+	if (flags & _PWSCAN_MASTER ) {
+		if (!(pw->pw_class = strsep(&bp, ":")))	/* class */
+			goto fmt;
+		
+		if (!(p = strsep(&bp, ":")))		/* change */
+			goto fmt;
+		pw->pw_change = atol(p);
+		
+		if (!(p = strsep(&bp, ":")))		/* expire */
+			goto fmt;
+		pw->pw_expire = atol(p);
+	}
+	if (!(pw->pw_gecos = strsep(&bp, ":")))		/* gecos */
+		goto fmt;
+
+	if (!(pw->pw_dir = strsep(&bp, ":")))		/* directory */
+		goto fmt;
+
+	if (!(pw->pw_shell = strsep(&bp, ":")))		/* shell */
+		goto fmt;
+
+	p = pw->pw_shell;
+	if (root && *p) {				/* empty == /bin/sh */
+		for (setusershell();;) {
+			if (!(sh = getusershell())) {
+				if (flags & _PWSCAN_WARN)
+					warnx("warning, unknown root shell");
+				break;
+			}
+			if (!strcmp(p, sh))
+				break;
+		}
+		endusershell();
+	}
+
+	if ((p = strsep(&bp, ":"))) {			/* too many */
+fmt:		
+		if (flags & _PWSCAN_WARN)
+			warnx("corrupted entry");
+		return (0);
+	}
+	return (1);
+}
--- a/modules/pam_unix/pw_scan.h	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/pw_scan.h	1697799606.876054686
@@ -0,0 +1,39 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)pw_scan.h	8.1 (Berkeley) 4/1/94
+ * $FreeBSD$
+ */
+
+#define _PWSCAN_MASTER 0x01
+#define _PWSCAN_WARN   0x02
+
+extern void	__pw_initpwd(struct passwd *);
+extern int	__pw_scan(char *, struct passwd *, int);
--- a/modules/pam_unix/pw_util.c	1900-01-00 00:00:00.000000000 +0000
+++ b/modules/pam_unix/pw_util.c	1697815853.759004539
@@ -0,0 +1,697 @@
+/*--
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ * Copyright (c) 2002 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * ThinkSec AS and NAI Labs, the Security Research Division of Network
+ * Associates, Inc.  under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+__SCCSID("@(#)pw_util.c	8.3 (Berkeley) 4/2/94");
+
+/*
+ * This file is used by all the "password" programs; vipw(8), chpass(1),
+ * and passwd(1).
+ */
+
+#include <sys/param.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <ctype.h>
+#include <err.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <paths.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <os/availability.h>
+API_AVAILABLE(macos(10.12), ios(10.0), tvos(10.0), watchos(3.0))
+void * reallocarray(void * in_ptr, size_t nmemb, size_t size) __DARWIN_EXTSN(reallocarray) __result_use_check;
+
+#include "libutil.h"
+
+static pid_t editpid = -1;
+static int lockfd = -1;
+static char masterpasswd[PATH_MAX];
+static char passwd_dir[PATH_MAX];
+static char tempname[PATH_MAX];
+static int initialized;
+
+#if 0
+void
+pw_cont(int sig)
+{
+
+	if (editpid != -1)
+		kill(editpid, sig);
+}
+#endif
+
+/*
+ * Initialize statics and set limits, signals & umask to try to avoid
+ * interruptions, crashes etc. that might expose passord data.
+ */
+int
+pw_init(const char *dir, const char *master)
+{
+#if 0
+	struct rlimit rlim;
+#endif
+
+	if (dir == NULL) {
+		strcpy(passwd_dir, _PATH_PWD);
+	} else {
+		if (strlen(dir) >= sizeof(passwd_dir)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+		strcpy(passwd_dir, dir);
+	}
+
+	if (master == NULL) {
+		if (dir == NULL) {
+			strcpy(masterpasswd, _PATH_MASTERPASSWD);
+		} else if (snprintf(masterpasswd, sizeof(masterpasswd), "%s/%s",
+		    passwd_dir, _MASTERPASSWD) > (int)sizeof(masterpasswd)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+	} else {
+		if (strlen(master) >= sizeof(masterpasswd)) {
+			errno = ENAMETOOLONG;
+			return (-1);
+		}
+		strcpy(masterpasswd, master);
+	}
+
+	/*
+	 * The code that follows is extremely disruptive to the calling
+	 * process, and is therefore disabled until someone can conceive
+	 * of a realistic scenario where it would fend off a compromise.
+	 * Race conditions concerning the temporary files can be guarded
+	 * against in other ways than masking signals (by checking stat(2)
+	 * results after creation).
+	 */
+#if 0
+	/* Unlimited resource limits. */
+	rlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;
+	(void)setrlimit(RLIMIT_CPU, &rlim);
+	(void)setrlimit(RLIMIT_FSIZE, &rlim);
+	(void)setrlimit(RLIMIT_STACK, &rlim);
+	(void)setrlimit(RLIMIT_DATA, &rlim);
+	(void)setrlimit(RLIMIT_RSS, &rlim);
+
+	/* Don't drop core (not really necessary, but GP's). */
+	rlim.rlim_cur = rlim.rlim_max = 0;
+	(void)setrlimit(RLIMIT_CORE, &rlim);
+
+	/* Turn off signals. */
+	(void)signal(SIGALRM, SIG_IGN);
+	(void)signal(SIGHUP, SIG_IGN);
+	(void)signal(SIGINT, SIG_IGN);
+	(void)signal(SIGPIPE, SIG_IGN);
+	(void)signal(SIGQUIT, SIG_IGN);
+	(void)signal(SIGTERM, SIG_IGN);
+	(void)signal(SIGCONT, pw_cont);
+
+	/* Create with exact permissions. */
+	(void)umask(0);
+#endif
+	initialized = 1;
+	return (0);
+}
+
+/*
+ * Lock the master password file.
+ */
+int
+pw_lock(void)
+{
+
+	if (*masterpasswd == '\0')
+		return (-1);
+
+	/*
+	 * If the master password file doesn't exist, the system is hosed.
+	 * Might as well try to build one.  Set the close-on-exec bit so
+	 * that users can't get at the encrypted passwords while editing.
+	 * Open should allow flock'ing the file; see 4.4BSD.	XXX
+	 */
+	for (;;) {
+		struct stat st;
+
+		lockfd = flopen(masterpasswd, O_RDONLY|O_NONBLOCK|O_CLOEXEC, 0);
+		if (lockfd == -1) {
+			if (errno == EWOULDBLOCK) {
+				errx(1, "the password db file is busy");
+			} else {
+				err(1, "could not lock the passwd file");
+			}
+		}
+
+		/*
+		 * If the password file was replaced while we were trying to
+		 * get the lock, our hardlink count will be 0 and we have to
+		 * close and retry.
+		 */
+		if (fstat(lockfd, &st) == -1)
+			err(1, "fstat() failed");
+		if (st.st_nlink != 0)
+			break;
+		close(lockfd);
+		lockfd = -1;
+	}
+	return (lockfd);
+}
+
+/*
+ * Create and open a presumably safe temp file for editing the password
+ * data, and copy the master password file into it.
+ */
+int
+pw_tmp(int mfd)
+{
+	char buf[8192];
+	ssize_t nr;
+	const char *p;
+	int tfd;
+
+	if (*masterpasswd == '\0')
+		return (-1);
+	if ((p = strrchr(masterpasswd, '/')))
+		++p;
+	else
+		p = masterpasswd;
+	if (snprintf(tempname, sizeof(tempname), "%.*spw.XXXXXX",
+		(int)(p - masterpasswd), masterpasswd) >= (int)sizeof(tempname)) {
+		errno = ENAMETOOLONG;
+		return (-1);
+	}
+	if ((tfd = mkostemp(tempname, 0)) == -1)
+		return (-1);
+	if (mfd != -1) {
+		while ((nr = read(mfd, buf, sizeof(buf))) > 0)
+			if (write(tfd, buf, (size_t)nr) != nr)
+				break;
+		if (nr != 0) {
+			unlink(tempname);
+			*tempname = '\0';
+			close(tfd);
+			return (-1);
+		}
+	}
+	return (tfd);
+}
+
+/*
+ * Regenerate the password database.
+ */
+int
+pw_mkdb(const char *user)
+{
+	int pstat;
+	pid_t pid;
+
+	(void)fflush(stderr);
+	switch ((pid = fork())) {
+	case -1:
+		return (-1);
+	case 0:
+		/* child */
+		if (user == NULL)
+			execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p",
+			    "-d", passwd_dir, tempname, (char *)NULL);
+		else
+			execl(_PATH_PWD_MKDB, "pwd_mkdb", "-p",
+			    "-d", passwd_dir, "-u", user, tempname,
+			    (char *)NULL);
+		_exit(1);
+		/* NOTREACHED */
+	default:
+		/* parent */
+		break;
+	}
+	if (waitpid(pid, &pstat, 0) == -1)
+		return (-1);
+	if (WIFEXITED(pstat) && WEXITSTATUS(pstat) == 0)
+		return (0);
+	errno = 0;
+	return (-1);
+}
+
+/*
+ * Edit the temp file.  Return -1 on error, >0 if the file was modified, 0
+ * if it was not.
+ */
+int
+pw_edit(int notsetuid)
+{
+	struct sigaction sa, sa_int, sa_quit;
+	sigset_t oldsigset, nsigset;
+	struct stat st1, st2;
+	const char *editor;
+	int pstat;
+
+	if ((editor = getenv("EDITOR")) == NULL)
+		editor = _PATH_VI;
+	if (stat(tempname, &st1) == -1)
+		return (-1);
+	sa.sa_handler = SIG_IGN;
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = 0;
+	sigaction(SIGINT, &sa, &sa_int);
+	sigaction(SIGQUIT, &sa, &sa_quit);
+	sigemptyset(&nsigset);
+	sigaddset(&nsigset, SIGCHLD);
+	sigprocmask(SIG_BLOCK, &nsigset, &oldsigset);
+	switch ((editpid = fork())) {
+	case -1:
+		return (-1);
+	case 0:
+		sigaction(SIGINT, &sa_int, NULL);
+		sigaction(SIGQUIT, &sa_quit, NULL);
+		sigprocmask(SIG_SETMASK, &oldsigset, NULL);
+		if (notsetuid) {
+			if (setgid(getgid()) == -1)
+				err(1, "setgid");
+			if (setuid(getuid()) == -1)
+				err(1, "setuid");
+		}
+		execlp(editor, editor, tempname, (char *)NULL);
+		err(1, "%s", editor);
+	default:
+		/* parent */
+		break;
+	}
+	for (;;) {
+		if (waitpid(editpid, &pstat, WUNTRACED) == -1) {
+			if (errno == EINTR)
+				continue;
+			unlink(tempname);
+			editpid = -1;
+			break;
+		} else if (WIFSTOPPED(pstat)) {
+			raise(WSTOPSIG(pstat));
+		} else if (WIFEXITED(pstat)) {
+			if (WEXITSTATUS(pstat) != 0)
+				errx(1, "\"%s\" exited with status %d", editor, WEXITSTATUS(pstat));
+			editpid = -1;
+			break;
+		} else {
+			unlink(tempname);
+			editpid = -1;
+			break;
+		}
+	}
+	sigaction(SIGINT, &sa_int, NULL);
+	sigaction(SIGQUIT, &sa_quit, NULL);
+	sigprocmask(SIG_SETMASK, &oldsigset, NULL);
+	if (stat(tempname, &st2) == -1)
+		return (-1);
+	return (st1.st_mtimespec.tv_sec != st2.st_mtimespec.tv_sec ||
+	    st1.st_mtimespec.tv_nsec != st2.st_mtimespec.tv_nsec);
+}
+
+/*
+ * Clean up.  Preserve errno for the caller's convenience.
+ */
+void
+pw_fini(void)
+{
+	int serrno, status;
+
+	if (!initialized)
+		return;
+	initialized = 0;
+	serrno = errno;
+	if (editpid != -1) {
+		kill(editpid, SIGTERM);
+		kill(editpid, SIGCONT);
+		waitpid(editpid, &status, 0);
+		editpid = -1;
+	}
+	if (*tempname != '\0') {
+		unlink(tempname);
+		*tempname = '\0';
+	}
+	if (lockfd != -1)
+		close(lockfd);
+	errno = serrno;
+}
+
+/*
+ * Compares two struct pwds.
+ */
+int
+pw_equal(const struct passwd *pw1, const struct passwd *pw2)
+{
+	return (strcmp(pw1->pw_name, pw2->pw_name) == 0 &&
+	    pw1->pw_uid == pw2->pw_uid &&
+	    pw1->pw_gid == pw2->pw_gid &&
+	    strcmp(pw1->pw_class, pw2->pw_class) == 0 &&
+	    pw1->pw_change == pw2->pw_change &&
+	    pw1->pw_expire == pw2->pw_expire &&
+	    strcmp(pw1->pw_gecos, pw2->pw_gecos) == 0 &&
+	    strcmp(pw1->pw_dir, pw2->pw_dir) == 0 &&
+	    strcmp(pw1->pw_shell, pw2->pw_shell) == 0);
+}
+
+/*
+ * Make a passwd line out of a struct passwd.
+ */
+char *
+pw_make(const struct passwd *pw)
+{
+	char *line;
+/* Torrekie: Darwin is using SIGNED uid/gid */
+#if __APPLE__
+	asprintf(&line, "%s:%s:%jd:%jd:%s:%ju:%ju:%s:%s:%s", pw->pw_name,
+	    pw->pw_passwd, pw->pw_uid, pw->pw_gid,
+#else
+	asprintf(&line, "%s:%s:%ju:%ju:%s:%ju:%ju:%s:%s:%s", pw->pw_name,
+	    pw->pw_passwd, (uintmax_t)pw->pw_uid, (uintmax_t)pw->pw_gid,
+#endif
+	    pw->pw_class, (uintmax_t)pw->pw_change, (uintmax_t)pw->pw_expire,
+	    pw->pw_gecos, pw->pw_dir, pw->pw_shell);
+	return (line);
+}
+
+/*
+ * Make a passwd line (in v7 format) out of a struct passwd
+ */
+char *
+pw_make_v7(const struct passwd *pw)
+{
+	char *line;
+#if __APPLE__
+	asprintf(&line, "%s:*:%jd:%jd:%s:%s:%s", pw->pw_name,
+	    pw->pw_uid, pw->pw_gid,
+#else
+	asprintf(&line, "%s:*:%ju:%ju:%s:%s:%s", pw->pw_name,
+	    (uintmax_t)pw->pw_uid, (uintmax_t)pw->pw_gid,
+#endif
+	    pw->pw_gecos, pw->pw_dir, pw->pw_shell);
+	return (line);
+}
+
+/*
+ * Copy password file from one descriptor to another, replacing, deleting
+ * or adding a single record on the way.
+ */
+int
+pw_copy(int ffd, int tfd, const struct passwd *pw, struct passwd *old_pw)
+{
+	char *buf, *end, *line, *p, *q, *r, *tmp;
+	struct passwd *fpw;
+	const struct passwd *spw;
+	size_t len, size;
+	int eof, readlen;
+	char t;
+
+	if (old_pw == NULL && pw == NULL)
+			return (-1);
+
+	spw = old_pw;
+	/* deleting a user */
+	if (pw == NULL) {
+		line = NULL;
+	} else {
+		if ((line = pw_make(pw)) == NULL)
+			return (-1);
+	}
+
+	/* adding a user */
+	if (spw == NULL)
+		spw = pw;
+
+	/* initialize the buffer */
+	if ((buf = malloc(size = 1024)) == NULL)
+		goto err;
+
+	eof = 0;
+	len = 0;
+	p = q = end = buf;
+	for (;;) {
+		/* find the end of the current line */
+		for (p = q; q < end && *q != '\0'; ++q)
+			if (*q == '\n')
+				break;
+
+		/* if we don't have a complete line, fill up the buffer */
+		if (q >= end) {
+			if (eof)
+				break;
+			while ((size_t)(q - p) >= size) {
+				if ((tmp = reallocarray(buf, 2, size)) == NULL) {
+					warnx("passwd line too long");
+					goto err;
+				}
+				p = tmp + (p - buf);
+				q = tmp + (q - buf);
+				end = tmp + (end - buf);
+				buf = tmp;
+				size = size * 2;
+			}
+			if (p < end) {
+				q = memmove(buf, p, end - p);
+				end -= p - buf;
+			} else {
+				p = q = end = buf;
+			}
+			readlen = read(ffd, end, size - (end - buf));
+			if (readlen == -1)
+				goto err;
+			else
+				len = (size_t)readlen;
+			if (len == 0 && p == buf)
+				break;
+			end += len;
+			len = end - buf;
+			if (len < size) {
+				eof = 1;
+				if (len > 0 && buf[len - 1] != '\n')
+					++len, *end++ = '\n';
+			}
+			continue;
+		}
+
+		/* is it a blank line or a comment? */
+		for (r = p; r < q && isspace(*r); ++r)
+			/* nothing */ ;
+		if (r == q || *r == '#') {
+			/* yep */
+			if (write(tfd, p, q - p + 1) != q - p + 1)
+				goto err;
+			++q;
+			continue;
+		}
+
+		/* is it the one we're looking for? */
+
+		t = *q;
+		*q = '\0';
+
+		fpw = pw_scan(r, PWSCAN_MASTER);
+
+		/*
+		 * fpw is either the struct passwd for the current line,
+		 * or NULL if the line is malformed.
+		 */
+
+		*q = t;
+		if (fpw == NULL || strcmp(fpw->pw_name, spw->pw_name) != 0) {
+			/* nope */
+			if (fpw != NULL)
+				free(fpw);
+			if (write(tfd, p, q - p + 1) != q - p + 1)
+				goto err;
+			++q;
+			continue;
+		}
+		if (old_pw && !pw_equal(fpw, old_pw)) {
+			warnx("entry inconsistent");
+			free(fpw);
+			errno = EINVAL; /* hack */
+			goto err;
+		}
+		free(fpw);
+
+		/* it is, replace or remove it */
+		if (line != NULL) {
+			len = strlen(line);
+			if (write(tfd, line, len) != (int)len)
+				goto err;
+		} else {
+			/* when removed, avoid the \n */
+			q++;
+		}
+		/* we're done, just copy the rest over */
+		for (;;) {
+			if (write(tfd, q, end - q) != end - q)
+				goto err;
+			q = buf;
+			readlen = read(ffd, buf, size);
+			if (readlen == 0)
+				break;
+			else
+				len = (size_t)readlen;
+			if (readlen == -1)
+				goto err;
+			end = buf + len;
+		}
+		goto done;
+	}
+
+	/* if we got here, we didn't find the old entry */
+	if (line == NULL) {
+		errno = ENOENT;
+		goto err;
+	}
+	len = strlen(line);
+	if ((size_t)write(tfd, line, len) != len ||
+	    write(tfd, "\n", 1) != 1)
+		goto err;
+ done:
+	free(line);
+	free(buf);
+	return (0);
+ err:
+	free(line);
+	free(buf);
+	return (-1);
+}
+
+/*
+ * Return the current value of tempname.
+ */
+const char *
+pw_tempname(void)
+{
+
+	return (tempname);
+}
+
+/*
+ * Duplicate a struct passwd.
+ */
+struct passwd *
+pw_dup(const struct passwd *pw)
+{
+	char *dst;
+	struct passwd *npw;
+	ssize_t len;
+
+	len = sizeof(*npw);
+	if (pw->pw_name != NULL)
+		len += strlen(pw->pw_name) + 1;
+	if (pw->pw_passwd != NULL)
+		len += strlen(pw->pw_passwd) + 1;
+	if (pw->pw_class != NULL)
+		len += strlen(pw->pw_class) + 1;
+	if (pw->pw_gecos != NULL)
+		len += strlen(pw->pw_gecos) + 1;
+	if (pw->pw_dir != NULL)
+		len += strlen(pw->pw_dir) + 1;
+	if (pw->pw_shell != NULL)
+		len += strlen(pw->pw_shell) + 1;
+	if ((npw = malloc((size_t)len)) == NULL)
+		return (NULL);
+	memcpy(npw, pw, sizeof(*npw));
+	dst = (char *)npw + sizeof(*npw);
+	if (pw->pw_name != NULL) {
+		npw->pw_name = dst;
+		dst = stpcpy(npw->pw_name, pw->pw_name) + 1;
+	}
+	if (pw->pw_passwd != NULL) {
+		npw->pw_passwd = dst;
+		dst = stpcpy(npw->pw_passwd, pw->pw_passwd) + 1;
+	}
+	if (pw->pw_class != NULL) {
+		npw->pw_class = dst;
+		dst = stpcpy(npw->pw_class, pw->pw_class) + 1;
+	}
+	if (pw->pw_gecos != NULL) {
+		npw->pw_gecos = dst;
+		dst = stpcpy(npw->pw_gecos, pw->pw_gecos) + 1;
+	}
+	if (pw->pw_dir != NULL) {
+		npw->pw_dir = dst;
+		dst = stpcpy(npw->pw_dir, pw->pw_dir) + 1;
+	}
+	if (pw->pw_shell != NULL) {
+		npw->pw_shell = dst;
+		dst = stpcpy(npw->pw_shell, pw->pw_shell) + 1;
+	}
+	return (npw);
+}
+
+#include "pw_scan.h"
+
+/*
+ * Wrapper around some internal libc functions.
+ */
+
+void
+pw_initpwd(struct passwd *pw)
+{
+
+	__pw_initpwd(pw);
+}
+
+struct passwd *
+pw_scan(const char *line, int flags)
+{
+	struct passwd pw, *ret;
+	char *bp;
+
+	if ((bp = strdup(line)) == NULL)
+		return (NULL);
+	__pw_initpwd(&pw);
+	if (!__pw_scan(bp, &pw, flags)) {
+		free(bp);
+		return (NULL);
+	}
+	ret = pw_dup(&pw);
+	free(bp);
+	return (ret);
+}
